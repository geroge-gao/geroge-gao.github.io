<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Matplotlib的Seaborn风格可视化]]></title>
    <url>%2F2019%2F10%2F04%2FMatplotlib%E7%9A%84Seaborn%E9%A3%8E%E6%A0%BC%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.Seaborn风格可视化1.1 什么事seaborn​ Seaborn是基于matplotlib的图形可视化python包。它提供了一种高度交互式界面，便于用户能够做出各种有吸引力的统计图表。Seaborn是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，在大多数情况下使用seaborn能做出很具有吸引力的图，而使用matplotlib就能制作具有更多特色的图。应该把Seaborn视为matplotlib的补充，而不是替代物。同时它能高度兼容numpy与pandas数据结构以及scipy与statsmodels等统计模式。 1.2 seaborn APISeaborn 要求原始数据的输入类型为 pandas 的 Dataframe 或 Numpy 数组，画图函数有以下几种形式: sns.图名(x=’X轴 列名’, y=’Y轴 列名’, data=原始数据df对象) sns.图名(x=’X轴 列名’, y=’Y轴 列名’, hue=’分组绘图参数’, data=原始数据df对象) sns.图名(x=np.array, y=np.array[, …]) 123456import numpy as npimport pandas as pdimport scipy as statsimport matplotlib.pyplot as pltimport seaborn as sns%matplotlib inline 2. 基本绘图设置1234567# 创建正弦函数def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1,7): plt.plot(x, np.sin(x+i*.5)*(7-i)*flip)sinplot() 2.1 简单切换成Seaborn风格1234# 切换Seaborn风格sns.set()fig = plt.figure(figsize=(8,6))sinplot() 1234567891011# 切换seaborn图标风格fig = plt.figure(figsize=(10,6), facecolor='white')ax1 = fig.add_subplot(211)sns.set_style('whitegrid')data = np.random.normal(size=(20,6))+np.arange(6)/2sns.boxplot(data=data)plt.title('style-whitegrid')ax2 = fig.add_subplot(212)sns.set_style('dark')sinplot() 2.3 设置图标坐标轴1234567891011121314151617181920212223242526#despine()# seaborn.despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False)# 设置风格sns.set_style("ticks")# 创建图表fig = plt.figure(figsize=(6,9))plt.subplots_adjust(hspace=0.3)ax1 = fig.add_subplot(3,1,1) sinplot()# 删除了上、右坐标轴sns.despine()ax2 = fig.add_subplot(3,1,2)sns.violinplot(data=data)# offset：与坐标轴之间的偏移# trim：为True时，将坐标轴限制在数据最大最小值#sns.despine(offset=10, trim=True)ax3 = fig.add_subplot(3,1,3)# top, right, left, bottom：布尔型，为True时不显示#sns.despine(left=True, right = False)sns.boxplot(data=data, palette="deep") 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b20e4f7a58&gt; 2.4 设置局部图标风格123456789with sns.axes_style("darkgrid"): plt.subplot(211) sinplot()# 设置局部图表风格，用with做代码块区分sns.set_style("whitegrid")plt.subplot(212)sinplot()# 外部表格风格 2.5 设置显示比例123456789#set_context()# 选择包括：'paper', 'notebook', 'talk', 'poster'## 与上面的cell比较你就会发现不同 sns.set_style("whitegrid")sns.set_context("poster")plt.subplot(212)sinplot() 2.6 调色板123456789# color_palette()# 默认6种颜色：deep, muted, pastel, bright, dark, colorblind# seaborn.color_palette(palette=None, n_colors=None, desat=None)current_palette = sns.color_palette()print(type(current_palette))# sns.palplot(current_palette[2:4])sns.palplot(current_palette) 1&lt;class &apos;seaborn.palettes._ColorPalette&apos;&gt; 2.7 颜色风格1234567891011121314# 颜色风格内容：Accent, Accent_r, Blues, Blues_r, BrBG, BrBG_r, BuGn, BuGn_r, BuPu, # BuPu_r, CMRmap, CMRmap_r, Dark2, Dark2_r, GnBu, GnBu_r, Greens, Greens_r, Greys, Greys_r, OrRd, OrRd_r, Oranges, Oranges_r, PRGn, PRGn_r, # Paired, Paired_r, Pastel1, Pastel1_r, Pastel2, Pastel2_r, PiYG, PiYG_r, PuBu, PuBuGn, PuBuGn_r, PuBu_r, PuOr, PuOr_r, PuRd, PuRd_r, Purples,# Purples_r, RdBu, RdBu_r, RdGy, RdGy_r, RdPu, RdPu_r, RdYlBu, RdYlBu_r, RdYlGn, RdYlGn_r, Reds, Reds_r, Set1, Set1_r, Set2, Set2_r, Set3, # Set3_r, Spectral, Spectral_r, Wistia, Wistia_r, YlGn, YlGnBu, YlGnBu_r, YlGn_r, YlOrBr, YlOrBr_r, YlOrRd, YlOrRd_r, afmhot, afmhot_r, # autumn, autumn_r, binary, binary_r, bone, bone_r, brg, brg_r, bwr, bwr_r, cool, cool_r, coolwarm, coolwarm_r, copper, copper_r, cubehelix, # cubehelix_r, flag, flag_r, gist_earth, gist_earth_r, gist_gray, gist_gray_r, gist_heat, gist_heat_r, gist_ncar, gist_ncar_r, gist_rainbow, # gist_rainbow_r, gist_stern, gist_stern_r, gist_yarg, gist_yarg_r, gnuplot, gnuplot2, gnuplot2_r, gnuplot_r, gray, gray_r, hot, hot_r, hsv, # hsv_r, icefire, icefire_r, inferno, inferno_r, jet, jet_r, magma, magma_r, mako, mako_r, nipy_spectral, nipy_spectral_r, ocean, ocean_r, # pink, pink_r, plasma, plasma_r, prism, prism_r, rainbow, rainbow_r, rocket, rocket_r, seismic, seismic_r, spectral, spectral_r, spring, # spring_r, summer, summer_r, terrain, terrain_r, viridis, viridis_r, vlag, vlag_r, winter, winter_rsns.palplot(sns.color_palette('Accent',12))sns.palplot(sns.color_palette('Accent_r',8)) 2.8 设置饱和度和亮度1234sns.palplot(sns.hls_palette(4,l=.3,s=.8))# l-&gt;亮度# s-&gt;饱和度 2.9 设置颜色线性变化1234567891011#设置颜色线性变化sns.palplot(sns.cubehelix_palette(16, gamma=2))sns.palplot(sns.cubehelix_palette(16, start=.5, rot=.75))sns.palplot(sns.cubehelix_palette(16,start=0.5, rot=0, dark=0.95, reverse=True))# n_colors → 颜色个数# start → 值区间在0-3，开始颜色# rot → 颜色旋转角度# gamma → 颜色伽马值，越大颜色越暗# dark，light → 值区间0-1，颜色深浅# reverse → 布尔值，默认为False，由浅到深 2.10 创建分散颜色123456plt.figure(figsize = (8,6))x = np.arange(25).reshape(5, 5)# 创建分散颜色cmap = sns.diverging_palette(200, 20, sep=20, as_cmap=True)sns.heatmap(x, cmap=cmap) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21a370cf8&gt; 123456789sns.set_style('whitegrid')fig=plt.figure(figsize=(12,8))with sns.color_palette('PuBuGn_d'): plt.subplot(211) sinplot() sns.set_palette('husl')plt.subplot(212)sinplot() 123456sns.set_style('darkgrid')sns.set_context('paper')import warningswarnings.filterwarnings('ignore')#不再发出警告 3. 分布数据可视化3.1 直方图12345678910111213141516#直方图#设计随即种子rs = np.random.RandomState(10)s = pd.Series(rs.randn(100)*100)sns.distplot(s, bins=10, hist=True, kde=False, norm_hist=False, rug=True,vertical=False,color='y', label='distplot', axlabel='x')plt.legend()# bins → 箱数# hist、ked → 是否显示箱/密度曲线# norm_hist → 直方图是否按照密度来显示# rug → 是否显示数据分布情况# vertical → 是否水平显示# color → 设置颜色# label → 图例# axlabel → x轴标注 1&lt;matplotlib.legend.Legend at 0x1b20e65e4e0&gt; 123456sns.distplot(s, rug=True, rug_kws=&#123;'color':'g'&#125;, kde_kws=&#123;"color": "k", "lw": 1, "label": "KDE",'linestyle':'--'&#125;, # 设置密度曲线颜色，线宽，标注、线形 hist_kws=&#123;"histtype": "step", "linewidth": 1,"alpha": 1, "color": "g"&#125;) # 设置箱子的风格、线宽、透明度、颜色 # 风格包括：'bar', 'barstacked', 'step', 'stepfilled' 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21bc8e828&gt; 3.2 密度图123456789101112131415161718# 密度图 - kdeplot()# 单个样本数据密度分布图sns.kdeplot(s, shade = False, # 是否填充 color = 'b', # 设置颜色 vertical = False # 设置是否水平 )sns.kdeplot(s,bw=5, label="bw: 0.2", linestyle = '-',linewidth = 1.2,alpha = 0.5)sns.kdeplot(s,bw=20, label="bw: 2", linestyle = '-',linewidth = 1.2,alpha = 0.5)# bw → 控制拟合的程度，类似直方图的箱数sns.rugplot(s,height = 0.1,color = 'k',alpha = 0.5)# 数据频率分布图 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21babf470&gt; 123456789101112131415161718# 密度图 - kdeplot()# 两个样本数据密度分布图rs = np.random.RandomState(2) # 设定随机数种子df = pd.DataFrame(rs.randn(100,2), columns = ['A','B'])sns.kdeplot(df['A'],df['B'], cbar = True, # 是否显示颜色图例 shade = True, # 是否填充 cmap = 'Reds', # 设置调色盘 shade_lowest=False, # 最外围颜色是否显示 n_levels = 10 # 曲线个数（如果非常多，则会越平滑） )# 两个维度数据生成曲线密度图，以颜色作为密度衰减显示sns.rugplot(df['A'], color="g", axis='x',alpha = 0.5)sns.rugplot(df['B'], color="r", axis='y',alpha = 0.5)# 注意设置x，y轴 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21bb63470&gt; 1234567891011121314151617# 密度图 - kdeplot()# 两个样本数据密度分布图# 多个密度图rs1 = np.random.RandomState(2) rs2 = np.random.RandomState(5) df1 = pd.DataFrame(rs1.randn(100,2)+2,columns = ['A','B'])df2 = pd.DataFrame(rs2.randn(100,2)-2,columns = ['A','B'])# 创建数据sns.kdeplot(df1['A'],df1['B'],cmap = 'Greens', shade = True,shade_lowest=False)sns.kdeplot(df2['A'],df2['B'],cmap = 'Blues', shade = True,shade_lowest=False)# 创建图表#sns.rugplot(df2['A']+df1['A'], color="g", axis='x',alpha = 0.5)#sns.rugplot(df2['B']+df1['B'], color="r", axis='y',alpha = 0.5) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21be56278&gt; 3.3 综合散点图1234567891011121314151617# 综合散点图 - jointplot()# 散点图 + 分布图rs = np.random.RandomState(2) df = pd.DataFrame(rs.randn(200,2),columns = ['A','B'])sns.jointplot(x=df['A'], y=df['B'], # 设置xy轴，显示columns名称 data=df, # 设置数据 color = 'k', # 设置颜色 s = 50, edgecolor="w",linewidth=1, # 设置散点大小、边缘线颜色及宽度(只针对scatter） kind = 'scatter', # 设置类型：“scatter”、“reg”、“resid”、“kde”、“hex” space = 0.2, # 设置散点图和布局图的间距 size = 8, # 图表大小（自动调整为正方形） ratio = 5, # 散点图与布局图高度比，整型 marginal_kws=dict(bins=15, rug=True) # 设置柱状图箱数，是否设置rug ) 1&lt;seaborn.axisgrid.JointGrid at 0x1b21bee2be0&gt; 12345678910# 综合散点图 - jointplot()# 散点图 + 分布图# 六边形图df = pd.DataFrame(rs.randn(500,2),columns = ['A','B'])with sns.axes_style("white"): sns.jointplot(x=df['A'], y=df['B'],data = df, kind="hex", color="g", marginal_kws=dict(bins=20)) 123456789101112131415# 综合散点图 - jointplot()# 散点图 + 分布图# 密度图rs = np.random.RandomState(15)df = pd.DataFrame(rs.randn(300,2),columns = ['A','B'])# 创建数据g = sns.jointplot(x=df['A'], y=df['B'],data = df, kind="kde", color="k", shade_lowest=False)# 创建密度图g.plot_joint(plt.scatter,c="w", s=30, linewidth=1, marker="*")# 添加散点图 1&lt;seaborn.axisgrid.JointGrid at 0x1b21c4325f8&gt; 1234567891011121314151617181920212223242526# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + ax_marg_x.hist() + ax_marg_y.hist()sns.set_style("white")# 设置风格tips = sns.load_dataset("tips")print(tips.head())# 导入数据g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g.plot_joint(plt.scatter, color ='m', edgecolor = 'white') # 设置框内图表，scatterg.ax_marg_x.hist(tips["total_bill"], color="b", alpha=.6, bins=np.arange(0, 60, 3)) # 设置x轴直方图，注意bins是数组g.ax_marg_y.hist(tips["tip"], color="r", alpha=.6, orientation="horizontal", bins=np.arange(0, 12, 1)) # 设置x轴直方图，注意需要orientation参数from scipy import statsg.annotate(stats.pearsonr) # 设置标注，可以为pearsonr，spearmanrplt.grid(linestyle = '--') 123456 total_bill tip sex smoker day time size0 16.99 1.01 Female No Sun Dinner 21 10.34 1.66 Male No Sun Dinner 32 21.01 3.50 Male No Sun Dinner 33 23.68 3.31 Male No Sun Dinner 24 24.59 3.61 Female No Sun Dinner 4 1234567891011# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + plot_marginals()g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g = g.plot_joint(plt.scatter,color="g", s=40, edgecolor="white") # 绘制散点图plt.grid(linestyle = '--')g.plot_marginals(sns.distplot, kde=True, color="g") # 绘制x，y轴直方图 1&lt;seaborn.axisgrid.JointGrid at 0x1b21c630da0&gt; 123456789101112# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + plot_marginals()# kde - 密度图g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g = g.plot_joint(sns.kdeplot,cmap = 'Reds_r') # 绘制密度图plt.grid(linestyle = '--')g.plot_marginals(sns.kdeplot, shade = True, color="r") # 绘制x，y轴密度图 1&lt;seaborn.axisgrid.JointGrid at 0x1b21d7aef60&gt; 3.4 矩阵散点图1234567891011121314151617# 矩阵散点图 - pairplot()sns.set_style("white")# 设置风格iris = sns.load_dataset("iris")print(iris.head())# 读取数据sns.pairplot(iris, kind = 'scatter', # 散点图/回归分布图 &#123;‘scatter’, ‘reg’&#125; diag_kind="hist", # 直方图/密度图 &#123;‘hist’, ‘kde’&#125; hue="species", # 按照某一字段进行分类 palette="husl", # 设置调色板 markers=["o", "s", "D"], # 设置不同系列的点样式（这里根据参考分类个数） size = 2, # 图表大小 ) 123456 sepal_length sepal_width petal_length petal_width species0 5.1 3.5 1.4 0.2 setosa1 4.9 3.0 1.4 0.2 setosa2 4.7 3.2 1.3 0.2 setosa3 4.6 3.1 1.5 0.2 setosa4 5.0 3.6 1.4 0.2 setosa 1&lt;seaborn.axisgrid.PairGrid at 0x1b21d8a44e0&gt; 123456# 矩阵散点图 - pairplot()# 只提取局部变量进行对比sns.pairplot(iris,vars=["sepal_width", "sepal_length"], kind = 'reg', diag_kind="kde", hue="species", palette="husl") 1&lt;seaborn.axisgrid.PairGrid at 0x1b21e003c18&gt; 123456789# 矩阵散点图 - pairplot()# 其他参数设置sns.pairplot(iris, diag_kind="kde", markers="+", plot_kws=dict(s=50, edgecolor="b", linewidth=1), # 设置点样式 diag_kws=dict(shade=True) # 设置密度图样式 ) 1&lt;seaborn.axisgrid.PairGrid at 0x1b21c37be48&gt; 123456789101112131415161718192021# 矩阵散点图 - PairGrid()# 可拆分绘制的散点图# map_diag() + map_offdiag()g = sns.PairGrid(iris,hue="species",palette = 'hls', vars = ['sepal_length','sepal_width','petal_length','petal_width'], # 可筛选 )# 创建一个绘图表格区域，设置好x、y对应数据，按照species分类g.map_diag(plt.hist, histtype = 'barstacked', # 可选：'bar', 'barstacked', 'step', 'stepfilled' linewidth = 1, edgecolor = 'w') # 对角线图表，plt.hist/sns.kdeplotg.map_offdiag(plt.scatter, edgecolor="w", s=40,linewidth = 1, # 设置点颜色、大小、描边宽度 ) # 其他图表，plt.scatter/plt.bar...g.add_legend()# 添加图例 1&lt;seaborn.axisgrid.PairGrid at 0x1b218fe3f98&gt; 12345678# 矩阵散点图 - PairGrid()# 可拆分绘制的散点图# map_diag() + map_lower() + map_upper()g = sns.PairGrid(iris)g.map_diag(sns.kdeplot, lw=3) # 设置对角线图表g.map_upper(plt.scatter, color = 'r') # 设置对角线上端图表g.map_lower(sns.kdeplot, cmap="Blues_d") # 设置对角线下端图表 1&lt;seaborn.axisgrid.PairGrid at 0x1b21ee966a0&gt; 4. 分类数据可视化4.1 分类散点图1234567891011121314# stripplot()# 按照不同类别对样本数据进行分布散点图绘制tips = sns.load_dataset("tips")print(tips.head())sns.stripplot(x="day", # x → 设置分组统计字段 y="total_bill", # y → 数据分布统计字段 # 这里xy数据对调，将会使得散点图横向分布 data=tips, # data → 对应数据 jitter = True, # jitter → 当点数据重合较多时，用该参数做一些调整，也可以设置间距如：jitter = 0.1 size = 5, edgecolor = 'w',linewidth=1,marker = 'o' # 设置点的大小、描边颜色或宽度、点样式 ) 123456 total_bill tip sex smoker day time size0 16.99 1.01 Female No Sun Dinner 21 10.34 1.66 Male No Sun Dinner 32 21.01 3.50 Male No Sun Dinner 33 23.68 3.31 Male No Sun Dinner 24 24.59 3.61 Female No Sun Dinner 4 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21f971320&gt; 12345# stripplot()# 通过hue参数再分类sns.stripplot(x="sex", y="total_bill", hue="day", data=tips, jitter=True) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21f9b2b00&gt; 12345678# stripplot()# 设置调色盘sns.stripplot(x="sex", y="total_bill", hue="day", data=tips, jitter=True, palette="Set2", # 设置调色盘 dodge=True, # 是否拆分 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fc11198&gt; 123456789# stripplot()# 筛选分类类别print(tips['day'].value_counts())# 查看day字段的唯一值sns.stripplot(x="day", y="total_bill", data=tips,jitter = True, order = ['Sat','Sun'])# order → 筛选类别 12345Sat 87Sun 76Thur 62Fri 19Name: day, dtype: int64 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fc8c748&gt; 4.2 分簇散点图1234567# swarmplot()# 分簇散点图sns.swarmplot(x="total_bill", y="day", data=tips, size = 5, edgecolor = 'w',linewidth=1,marker = 'o', palette = 'Reds')# 用法和stripplot类似 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fcdef28&gt; 4.3 箱型图123456789101112131415# boxplot()sns.boxplot(x="day", y="total_bill", data=tips, linewidth = 2, # 线宽 width = 0.8, # 箱之间的间隔比例 fliersize = 3, # 异常点大小 palette = 'hls', # 设置调色板 whis = 1.5, # 设置IQR notch = True, # 设置是否以中值做凹槽 order = ['Thur','Fri','Sat','Sun'], # 筛选类别 )# 绘制箱型图#sns.swarmplot(x="day", y="total_bill", data=tips,color ='k',size = 3,alpha = 0.8)# 可以添加散点图 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fd32710&gt; 123# 通过hue参数再分类sns.boxplot(x="day", y="total_bill", data=tips, hue = 'smoker', palette = 'Reds') 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fdce5c0&gt; 4.4 小提琴图12345678910111213# violinplot()sns.violinplot(x="day", y="total_bill", data=tips, linewidth = 2, # 线宽 width = 0.8, # 箱之间的间隔比例 palette = 'hls', # 设置调色板 order = ['Thur','Fri','Sat','Sun'], # 筛选类别 scale = 'area', # 测度小提琴图的宽度：area-面积相同，count-按照样本数量决定宽度，width-宽度一样 gridsize = 50, # 设置小提琴图边线的平滑度，越高越平滑 inner = 'box', # 设置内部显示类型 → “box”, “quartile”, “point”, “stick”, None #bw = 0.8 # 控制拟合程度，一般可以不设置 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21feb0d68&gt; 123456# 通过hue参数再分类sns.violinplot(x="day", y="total_bill", data=tips, hue = 'smoker', palette="muted", split=True, # 设置是否拆分小提琴图 inner="quartile") 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21ff37940&gt; 12345# 结合散点图sns.violinplot(x="day", y="total_bill", data=tips, palette = 'hls', inner = None)sns.swarmplot(x="day", y="total_bill", data=tips, color="w", alpha=.5)# 插入散点图 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fff0e80&gt; 4.5 LV图123456789101112# lvplot()sns.lvplot(x="day", y="total_bill", data=tips, palette="mako", #hue = 'smoker', width = 0.8, # 箱之间间隔比例 linewidth = 12, scale = 'area', # 设置框的大小 → “linear”、“exonential”、“area” k_depth = 'proportion', # 设置框的数量 → “proportion”、“tukey”、“trustworthy” )# 绘制LV图sns.swarmplot(x="day", y="total_bill", data=tips,color ='k',size = 3,alpha = 0.8)# 可以添加散点图 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b22101c400&gt; 4.6分类统计图1234567891011121314151617181920# barplot()# 柱状图 - 置信区间估计# 置信区间：样本均值 + 抽样误差titanic = sns.load_dataset("titanic")#print(titanic.head())#print('-----')# 加载数据sns.barplot(x="sex", y="survived", hue="class", data=titanic, palette = 'hls', order = ['male','female'], # 筛选类别 capsize = 0.05, # 误差线横向延伸宽度 saturation=.8, # 颜色饱和度 errcolor = 'gray',errwidth = 2, # 误差线颜色，宽度 ci = 'sd' # 置信区间误差 → 0-100内值、'sd'、None )#print(titanic.groupby(['sex','class']).mean()['survived'])#print(titanic.groupby(['sex','class']).std()['survived'])# 计算数据 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b2210a1048&gt; 1234567# barplot()# 柱状图 - 置信区间估计sns.barplot(x="day", y="total_bill", hue="sex", data=tips, palette = 'Blues',edgecolor = 'w')tips.groupby(['day','sex']).mean()# 计算数据 .dataframe tbody tr th:only-of-type { vertical-align: middle; } 1234567.dataframe tbody tr th &#123; vertical-align: top;&#125;.dataframe thead th &#123; text-align: right;&#125; total_bill tip size day sex Thur Male 18.714667 2.980333 2.433333 Female 16.715312 2.575625 2.468750 Fri Male 19.857000 2.693000 2.100000 Female 14.145556 2.781111 2.111111 Sat Male 20.802542 3.083898 2.644068 Female 19.680357 2.801786 2.250000 Sun Male 21.887241 3.220345 2.810345 Female 19.872222 3.367222 2.944444 12345678910111213141516171819202122# 1、barplot()# 柱状图 - 置信区间估计crashes = sns.load_dataset("car_crashes").sort_values("total", ascending=False)print(crashes.head())# 加载数据f, ax = plt.subplots(figsize=(6, 15))# 创建图表sns.set_color_codes("pastel")sns.barplot(x="total", y="abbrev", data=crashes, label="Total", color="b",edgecolor = 'w')# 设置第一个柱状图sns.set_color_codes("muted")sns.barplot(x="alcohol", y="abbrev", data=crashes, label="Alcohol-involved", color="b",edgecolor = 'w')# 设置第二个柱状图ax.legend(ncol=2, loc="lower right")sns.despine(left=True, bottom=True) 12345678910111213 total speeding alcohol not_distracted no_previous ins_premium \40 23.9 9.082 9.799 22.944 19.359 858.97 34 23.9 5.497 10.038 23.661 20.554 688.75 48 23.8 8.092 6.664 23.086 20.706 992.61 3 22.4 4.032 5.824 21.056 21.280 827.34 17 21.4 4.066 4.922 16.692 16.264 872.51 ins_losses abbrev 40 116.29 SC 34 109.72 ND 48 152.56 WV 3 142.39 AR 17 137.13 KY 1234567# countplot()# 计数柱状图sns.countplot(x="class", hue="who", data=titanic,palette = 'magma')#sns.countplot(y="class", hue="who", data=titanic,palette = 'magma') # x/y → 以x或者y轴绘图（横向，竖向）# 用法和barplot相似 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b22117aac8&gt; 123456789101112# pointplot()# 折线图 - 置信区间估计sns.pointplot(x="time", y="total_bill", hue = 'smoker',data=tips, palette = 'hls', dodge = True, # 设置点是否分开 join = True, # 是否连线 markers=["o", "x"], linestyles=["-", "--"], # 设置点样式、线型 )tips.groupby(['time','smoker']).mean()['total_bill']# 计算数据# # 用法和barplot相似 123456time smokerLunch Yes 17.399130 No 17.050889Dinner Yes 21.859429 No 20.095660Name: total_bill, dtype: float64 5.线性数据可视化5.1基本使用1234567891011# 基本用法tips = sns.load_dataset("tips")print(tips.head())# 加载数据sns.lmplot(x="total_bill", y="tip", hue = 'smoker',data=tips,palette="Set1", ci = 70, # 误差值 size = 5, # 图表大小 markers = ['+','o'], # 点样式 ) 123456 total_bill tip sex smoker day time size0 16.99 1.01 Female No Sun Dinner 21 10.34 1.66 Male No Sun Dinner 32 21.01 3.50 Male No Sun Dinner 33 23.68 3.31 Male No Sun Dinner 24 24.59 3.61 Female No Sun Dinner 4 1&lt;seaborn.axisgrid.FacetGrid at 0x1b21c57d7b8&gt; 5.2 多表格1sns.lmplot(x="total_bill", y="tip", col="smoker", data=tips) 1&lt;seaborn.axisgrid.FacetGrid at 0x1b2215774e0&gt; 1234567# 多图表1sns.lmplot(x="size", y="total_bill", hue="day", col="day",data=tips, aspect=0.6, # 长宽比 x_jitter=.30, # 给x或者y轴随机增加噪音点 col_wrap=4, # 每行的列数 ) 1&lt;seaborn.axisgrid.FacetGrid at 0x1b2216276a0&gt; 12345# 多图表2sns.lmplot(x="total_bill", y="tip", row="sex", col="time",data=tips, size=4)# 行为sex字段，列为time字段# x轴total_bill, y轴tip 1&lt;seaborn.axisgrid.FacetGrid at 0x1b22160a400&gt; 5.3 非线性回归1234# 非线性回归sns.lmplot(x="total_bill", y="tip",data=tips, order = 2) 1&lt;seaborn.axisgrid.FacetGrid at 0x1b2214d7b00&gt; 6. 其他图表可视化6.1 时间线图123456789101112131415# tsplot()x = np.linspace(0, 15, 31)data = np.sin(x) + np.random.rand(10, 31) + np.random.randn(10, 1)#print(data.shape)#print(pd.DataFrame(data).head())# 创建数据sns.tsplot(data=data, err_style="ci_band", # 误差数据风格，可选：ci_band, ci_bars, boot_traces, boot_kde, unit_traces, unit_points interpolate=True, # 是否连线 ci = [40,70,90], # 设置误差区间 color = 'r' # 设置颜色 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21668c860&gt; 123sns.tsplot(data=data, err_style="boot_traces", n_boot=300 # 迭代次数 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b216533048&gt; 12345678910111213gammas = sns.load_dataset("gammas")print(gammas.head())print('数据量为：%i条' % len(gammas))print('timepoint为0.0时的数据量为：%i条' % len(gammas[gammas['timepoint'] == 0]))print('timepoint共有%i个唯一值' % len(gammas['timepoint'].value_counts()))#print(gammas['timepoint'].value_counts()) # 查看唯一值具体信息# 导入数据sns.tsplot(time="timepoint", # 时间数据，x轴 value="BOLD signal", # y轴value unit="subject", # condition="ROI", # 分类 data=gammas) 123456789 timepoint ROI subject BOLD signal0 0.0 IPS 0 0.5134331 0.0 IPS 1 -0.4143682 0.0 IPS 2 0.2146953 0.0 IPS 3 0.8148094 0.0 IPS 4 -0.894992数据量为：6000条timepoint为0.0时的数据量为：60条timepoint共有100个唯一值 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b221f95a58&gt; 6.2 热图123456789# 热图 - heatmap()# 简单示例df = pd.DataFrame(np.random.rand(10,15))# 创建数据 - 10*12图表sns.heatmap(df, # 加载数据 vmin=0, vmax=1 # 设置图例最大最小值 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b221faac88&gt; 123456789101112131415161718# heatmap()# 参数设置flights = sns.load_dataset("flights")flights = flights.pivot("month", "year", "passengers") #print(flights.head())# 加载数据 sns.heatmap(flights, annot = True, # 是否显示数值 fmt = 'd', # 格式化字符串 linewidths = 0.2, # 格子边线宽度 #center = 100, # 调色盘的色彩中心值，若没有指定，则以cmap为主 #cmap = 'Reds', # 设置调色盘 cbar = True, # 是否显示图例色带 #cbar_kws=&#123;"orientation": "horizontal"&#125;, # 是否横向显示图例色带 #square = True, # 是否正方形显示图表 ) 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b223040588&gt; 123456789101112131415161718192021# heatmap()# 绘制半边热图sns.set(style="white")# 设置风格rs = np.random.RandomState(33)d = pd.DataFrame(rs.normal(size=(100, 26)))corr = d.corr() # 求解相关性矩阵表格# 创建数据mask = np.zeros_like(corr, dtype=np.bool)mask[np.triu_indices_from(mask)] = True# 设置一个“上三角形”蒙版cmap = sns.diverging_palette(220, 10, as_cmap=True)# 设置调色盘sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0, square=True, linewidths=0.2)# 生成半边热图 1&lt;matplotlib.axes._subplots.AxesSubplot at 0x1b2231f3128&gt; 6.3 图标矩阵12345678910111213141516attend = sns.load_dataset("attention")print(attend.head())# 加载数据g = sns.FacetGrid(attend, col="subject", col_wrap=5, # 设置每行的图表数量 size=1.5)g.map(plt.plot, "solutions", "score", marker="o",color = 'gray',linewidth = 2)# 绘制图表矩阵g.set(xlim = (0,4), ylim = (0,10), xticks = [0,1,2,3,4], yticks = [0,2,4,6,8,10] )# 设置x，y轴刻度 123456 Unnamed: 0 subject attention solutions score0 0 1 divided 1 2.01 1 2 divided 1 3.02 2 3 divided 1 3.03 3 4 divided 1 5.04 4 5 divided 1 4.0 1&lt;seaborn.axisgrid.FacetGrid at 0x1b22328cb00&gt; 12]]></content>
      <categories>
        <category>机器学习</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F04%2Fseason%E9%A3%8E%E6%A0%BC%E5%8F%AF%E8%A7%86%E5%8C%96%2Fseason%E9%A3%8E%E6%A0%BC%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.Seaborn风格可视化1.1 什么事seaborn​ Seaborn是基于matplotlib的图形可视化python包。它提供了一种高度交互式界面，便于用户能够做出各种有吸引力的统计图表。Seaborn是在matplotlib的基础上进行了更高级的API封装，从而使得作图更加容易，在大多数情况下使用seaborn能做出很具有吸引力的图，而使用matplotlib就能制作具有更多特色的图。应该把Seaborn视为matplotlib的补充，而不是替代物。同时它能高度兼容numpy与pandas数据结构以及scipy与statsmodels等统计模式。 1.2 seaborn APISeaborn 要求原始数据的输入类型为 pandas 的 Dataframe 或 Numpy 数组，画图函数有以下几种形式: sns.图名(x=’X轴 列名’, y=’Y轴 列名’, data=原始数据df对象) sns.图名(x=’X轴 列名’, y=’Y轴 列名’, hue=’分组绘图参数’, data=原始数据df对象) sns.图名(x=np.array, y=np.array[, …]) 123456import numpy as npimport pandas as pdimport scipy as statsimport matplotlib.pyplot as pltimport seaborn as sns%matplotlib inline 2. 基本绘图设置1234567# 创建正弦函数def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1,7): plt.plot(x, np.sin(x+i*.5)*(7-i)*flip)sinplot() 2.1 简单切换成Seaborn风格1234# 切换Seaborn风格sns.set()fig = plt.figure(figsize=(8,6))sinplot() 1234567891011# 切换seaborn图标风格fig = plt.figure(figsize=(10,6), facecolor='white')ax1 = fig.add_subplot(211)sns.set_style('whitegrid')data = np.random.normal(size=(20,6))+np.arange(6)/2sns.boxplot(data=data)plt.title('style-whitegrid')ax2 = fig.add_subplot(212)sns.set_style('dark')sinplot() 2.3 设置图标坐标轴123456789101112131415161718192021222324252627#despine()# seaborn.despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False)# 设置风格sns.set_style("ticks")# 创建图表fig = plt.figure(figsize=(6,9))plt.subplots_adjust(hspace=0.3)ax1 = fig.add_subplot(3,1,1) sinplot()# 删除了上、右坐标轴sns.despine()ax2 = fig.add_subplot(3,1,2)sns.violinplot(data=data)# offset：与坐标轴之间的偏移# trim：为True时，将坐标轴限制在数据最大最小值#sns.despine(offset=10, trim=True)ax3 = fig.add_subplot(3,1,3)# top, right, left, bottom：布尔型，为True时不显示#sns.despine(left=True, right = False)sns.boxplot(data=data, palette="deep") &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b20e4f7a58&gt; 2.4 设置局部图标风格123456789with sns.axes_style("darkgrid"): plt.subplot(211) sinplot()# 设置局部图表风格，用with做代码块区分sns.set_style("whitegrid")plt.subplot(212)sinplot()# 外部表格风格 2.5 设置显示比例123456789#set_context()# 选择包括：'paper', 'notebook', 'talk', 'poster'## 与上面的cell比较你就会发现不同 sns.set_style("whitegrid")sns.set_context("poster")plt.subplot(212)sinplot() 2.6 调色板123456789# color_palette()# 默认6种颜色：deep, muted, pastel, bright, dark, colorblind# seaborn.color_palette(palette=None, n_colors=None, desat=None)current_palette = sns.color_palette()print(type(current_palette))# sns.palplot(current_palette[2:4])sns.palplot(current_palette) &lt;class &#39;seaborn.palettes._ColorPalette&#39;&gt; 2.7 颜色风格1234567891011121314# 颜色风格内容：Accent, Accent_r, Blues, Blues_r, BrBG, BrBG_r, BuGn, BuGn_r, BuPu, # BuPu_r, CMRmap, CMRmap_r, Dark2, Dark2_r, GnBu, GnBu_r, Greens, Greens_r, Greys, Greys_r, OrRd, OrRd_r, Oranges, Oranges_r, PRGn, PRGn_r, # Paired, Paired_r, Pastel1, Pastel1_r, Pastel2, Pastel2_r, PiYG, PiYG_r, PuBu, PuBuGn, PuBuGn_r, PuBu_r, PuOr, PuOr_r, PuRd, PuRd_r, Purples,# Purples_r, RdBu, RdBu_r, RdGy, RdGy_r, RdPu, RdPu_r, RdYlBu, RdYlBu_r, RdYlGn, RdYlGn_r, Reds, Reds_r, Set1, Set1_r, Set2, Set2_r, Set3, # Set3_r, Spectral, Spectral_r, Wistia, Wistia_r, YlGn, YlGnBu, YlGnBu_r, YlGn_r, YlOrBr, YlOrBr_r, YlOrRd, YlOrRd_r, afmhot, afmhot_r, # autumn, autumn_r, binary, binary_r, bone, bone_r, brg, brg_r, bwr, bwr_r, cool, cool_r, coolwarm, coolwarm_r, copper, copper_r, cubehelix, # cubehelix_r, flag, flag_r, gist_earth, gist_earth_r, gist_gray, gist_gray_r, gist_heat, gist_heat_r, gist_ncar, gist_ncar_r, gist_rainbow, # gist_rainbow_r, gist_stern, gist_stern_r, gist_yarg, gist_yarg_r, gnuplot, gnuplot2, gnuplot2_r, gnuplot_r, gray, gray_r, hot, hot_r, hsv, # hsv_r, icefire, icefire_r, inferno, inferno_r, jet, jet_r, magma, magma_r, mako, mako_r, nipy_spectral, nipy_spectral_r, ocean, ocean_r, # pink, pink_r, plasma, plasma_r, prism, prism_r, rainbow, rainbow_r, rocket, rocket_r, seismic, seismic_r, spectral, spectral_r, spring, # spring_r, summer, summer_r, terrain, terrain_r, viridis, viridis_r, vlag, vlag_r, winter, winter_rsns.palplot(sns.color_palette('Accent',12))sns.palplot(sns.color_palette('Accent_r',8)) 2.8 设置饱和度和亮度1234sns.palplot(sns.hls_palette(4,l=.3,s=.8))# l-&gt;亮度# s-&gt;饱和度 2.9 设置颜色线性变化1234567891011#设置颜色线性变化sns.palplot(sns.cubehelix_palette(16, gamma=2))sns.palplot(sns.cubehelix_palette(16, start=.5, rot=.75))sns.palplot(sns.cubehelix_palette(16,start=0.5, rot=0, dark=0.95, reverse=True))# n_colors → 颜色个数# start → 值区间在0-3，开始颜色# rot → 颜色旋转角度# gamma → 颜色伽马值，越大颜色越暗# dark，light → 值区间0-1，颜色深浅# reverse → 布尔值，默认为False，由浅到深 2.10 创建分散颜色123456plt.figure(figsize = (8,6))x = np.arange(25).reshape(5, 5)# 创建分散颜色cmap = sns.diverging_palette(200, 20, sep=20, as_cmap=True)sns.heatmap(x, cmap=cmap) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21a370cf8&gt; 123456789sns.set_style('whitegrid')fig=plt.figure(figsize=(12,8))with sns.color_palette('PuBuGn_d'): plt.subplot(211) sinplot() sns.set_palette('husl')plt.subplot(212)sinplot() 123456sns.set_style('darkgrid')sns.set_context('paper')import warningswarnings.filterwarnings('ignore')#不再发出警告 3. 分布数据可视化3.1 直方图12345678910111213141516#直方图#设计随即种子rs = np.random.RandomState(10)s = pd.Series(rs.randn(100)*100)sns.distplot(s, bins=10, hist=True, kde=False, norm_hist=False, rug=True,vertical=False,color='y', label='distplot', axlabel='x')plt.legend()# bins → 箱数# hist、ked → 是否显示箱/密度曲线# norm_hist → 直方图是否按照密度来显示# rug → 是否显示数据分布情况# vertical → 是否水平显示# color → 设置颜色# label → 图例# axlabel → x轴标注 &lt;matplotlib.legend.Legend at 0x1b20e65e4e0&gt; 123456sns.distplot(s, rug=True, rug_kws=&#123;'color':'g'&#125;, kde_kws=&#123;"color": "k", "lw": 1, "label": "KDE",'linestyle':'--'&#125;, # 设置密度曲线颜色，线宽，标注、线形 hist_kws=&#123;"histtype": "step", "linewidth": 1,"alpha": 1, "color": "g"&#125;) # 设置箱子的风格、线宽、透明度、颜色 # 风格包括：'bar', 'barstacked', 'step', 'stepfilled' &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21bc8e828&gt; 3.2 密度图123456789101112131415161718# 密度图 - kdeplot()# 单个样本数据密度分布图sns.kdeplot(s, shade = False, # 是否填充 color = 'b', # 设置颜色 vertical = False # 设置是否水平 )sns.kdeplot(s,bw=5, label="bw: 0.2", linestyle = '-',linewidth = 1.2,alpha = 0.5)sns.kdeplot(s,bw=20, label="bw: 2", linestyle = '-',linewidth = 1.2,alpha = 0.5)# bw → 控制拟合的程度，类似直方图的箱数sns.rugplot(s,height = 0.1,color = 'k',alpha = 0.5)# 数据频率分布图 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21babf470&gt; 123456789101112131415161718# 密度图 - kdeplot()# 两个样本数据密度分布图rs = np.random.RandomState(2) # 设定随机数种子df = pd.DataFrame(rs.randn(100,2), columns = ['A','B'])sns.kdeplot(df['A'],df['B'], cbar = True, # 是否显示颜色图例 shade = True, # 是否填充 cmap = 'Reds', # 设置调色盘 shade_lowest=False, # 最外围颜色是否显示 n_levels = 10 # 曲线个数（如果非常多，则会越平滑） )# 两个维度数据生成曲线密度图，以颜色作为密度衰减显示sns.rugplot(df['A'], color="g", axis='x',alpha = 0.5)sns.rugplot(df['B'], color="r", axis='y',alpha = 0.5)# 注意设置x，y轴 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21bb63470&gt; 1234567891011121314151617# 密度图 - kdeplot()# 两个样本数据密度分布图# 多个密度图rs1 = np.random.RandomState(2) rs2 = np.random.RandomState(5) df1 = pd.DataFrame(rs1.randn(100,2)+2,columns = ['A','B'])df2 = pd.DataFrame(rs2.randn(100,2)-2,columns = ['A','B'])# 创建数据sns.kdeplot(df1['A'],df1['B'],cmap = 'Greens', shade = True,shade_lowest=False)sns.kdeplot(df2['A'],df2['B'],cmap = 'Blues', shade = True,shade_lowest=False)# 创建图表#sns.rugplot(df2['A']+df1['A'], color="g", axis='x',alpha = 0.5)#sns.rugplot(df2['B']+df1['B'], color="r", axis='y',alpha = 0.5) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21be56278&gt; 3.3 综合散点图1234567891011121314151617# 综合散点图 - jointplot()# 散点图 + 分布图rs = np.random.RandomState(2) df = pd.DataFrame(rs.randn(200,2),columns = ['A','B'])sns.jointplot(x=df['A'], y=df['B'], # 设置xy轴，显示columns名称 data=df, # 设置数据 color = 'k', # 设置颜色 s = 50, edgecolor="w",linewidth=1, # 设置散点大小、边缘线颜色及宽度(只针对scatter） kind = 'scatter', # 设置类型：“scatter”、“reg”、“resid”、“kde”、“hex” space = 0.2, # 设置散点图和布局图的间距 size = 8, # 图表大小（自动调整为正方形） ratio = 5, # 散点图与布局图高度比，整型 marginal_kws=dict(bins=15, rug=True) # 设置柱状图箱数，是否设置rug ) &lt;seaborn.axisgrid.JointGrid at 0x1b21bee2be0&gt; 12345678910# 综合散点图 - jointplot()# 散点图 + 分布图# 六边形图df = pd.DataFrame(rs.randn(500,2),columns = ['A','B'])with sns.axes_style("white"): sns.jointplot(x=df['A'], y=df['B'],data = df, kind="hex", color="g", marginal_kws=dict(bins=20)) 123456789101112131415# 综合散点图 - jointplot()# 散点图 + 分布图# 密度图rs = np.random.RandomState(15)df = pd.DataFrame(rs.randn(300,2),columns = ['A','B'])# 创建数据g = sns.jointplot(x=df['A'], y=df['B'],data = df, kind="kde", color="k", shade_lowest=False)# 创建密度图g.plot_joint(plt.scatter,c="w", s=30, linewidth=1, marker="*")# 添加散点图 &lt;seaborn.axisgrid.JointGrid at 0x1b21c4325f8&gt; 1234567891011121314151617181920212223242526# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + ax_marg_x.hist() + ax_marg_y.hist()sns.set_style("white")# 设置风格tips = sns.load_dataset("tips")print(tips.head())# 导入数据g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g.plot_joint(plt.scatter, color ='m', edgecolor = 'white') # 设置框内图表，scatterg.ax_marg_x.hist(tips["total_bill"], color="b", alpha=.6, bins=np.arange(0, 60, 3)) # 设置x轴直方图，注意bins是数组g.ax_marg_y.hist(tips["tip"], color="r", alpha=.6, orientation="horizontal", bins=np.arange(0, 12, 1)) # 设置x轴直方图，注意需要orientation参数from scipy import statsg.annotate(stats.pearsonr) # 设置标注，可以为pearsonr，spearmanrplt.grid(linestyle = '--') total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 1234567891011# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + plot_marginals()g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g = g.plot_joint(plt.scatter,color="g", s=40, edgecolor="white") # 绘制散点图plt.grid(linestyle = '--')g.plot_marginals(sns.distplot, kde=True, color="g") # 绘制x，y轴直方图 &lt;seaborn.axisgrid.JointGrid at 0x1b21c630da0&gt; 123456789101112# 综合散点图 - JointGrid()# 可拆分绘制的散点图# plot_joint() + plot_marginals()# kde - 密度图g = sns.JointGrid(x="total_bill", y="tip", data=tips)# 创建一个绘图表格区域，设置好x、y对应数据g = g.plot_joint(sns.kdeplot,cmap = 'Reds_r') # 绘制密度图plt.grid(linestyle = '--')g.plot_marginals(sns.kdeplot, shade = True, color="r") # 绘制x，y轴密度图 &lt;seaborn.axisgrid.JointGrid at 0x1b21d7aef60&gt; 3.4 矩阵散点图1234567891011121314151617# 矩阵散点图 - pairplot()sns.set_style("white")# 设置风格iris = sns.load_dataset("iris")print(iris.head())# 读取数据sns.pairplot(iris, kind = 'scatter', # 散点图/回归分布图 &#123;‘scatter’, ‘reg’&#125; diag_kind="hist", # 直方图/密度图 &#123;‘hist’, ‘kde’&#125; hue="species", # 按照某一字段进行分类 palette="husl", # 设置调色板 markers=["o", "s", "D"], # 设置不同系列的点样式（这里根据参考分类个数） size = 2, # 图表大小 ) sepal_length sepal_width petal_length petal_width species 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa 4 5.0 3.6 1.4 0.2 setosa &lt;seaborn.axisgrid.PairGrid at 0x1b21d8a44e0&gt; 123456# 矩阵散点图 - pairplot()# 只提取局部变量进行对比sns.pairplot(iris,vars=["sepal_width", "sepal_length"], kind = 'reg', diag_kind="kde", hue="species", palette="husl") &lt;seaborn.axisgrid.PairGrid at 0x1b21e003c18&gt; 123456789# 矩阵散点图 - pairplot()# 其他参数设置sns.pairplot(iris, diag_kind="kde", markers="+", plot_kws=dict(s=50, edgecolor="b", linewidth=1), # 设置点样式 diag_kws=dict(shade=True) # 设置密度图样式 ) &lt;seaborn.axisgrid.PairGrid at 0x1b21c37be48&gt; 123456789101112131415161718192021# 矩阵散点图 - PairGrid()# 可拆分绘制的散点图# map_diag() + map_offdiag()g = sns.PairGrid(iris,hue="species",palette = 'hls', vars = ['sepal_length','sepal_width','petal_length','petal_width'], # 可筛选 )# 创建一个绘图表格区域，设置好x、y对应数据，按照species分类g.map_diag(plt.hist, histtype = 'barstacked', # 可选：'bar', 'barstacked', 'step', 'stepfilled' linewidth = 1, edgecolor = 'w') # 对角线图表，plt.hist/sns.kdeplotg.map_offdiag(plt.scatter, edgecolor="w", s=40,linewidth = 1, # 设置点颜色、大小、描边宽度 ) # 其他图表，plt.scatter/plt.bar...g.add_legend()# 添加图例 &lt;seaborn.axisgrid.PairGrid at 0x1b218fe3f98&gt; 12345678# 矩阵散点图 - PairGrid()# 可拆分绘制的散点图# map_diag() + map_lower() + map_upper()g = sns.PairGrid(iris)g.map_diag(sns.kdeplot, lw=3) # 设置对角线图表g.map_upper(plt.scatter, color = 'r') # 设置对角线上端图表g.map_lower(sns.kdeplot, cmap="Blues_d") # 设置对角线下端图表 &lt;seaborn.axisgrid.PairGrid at 0x1b21ee966a0&gt; 4. 分类数据可视化4.1 分类散点图1234567891011121314# stripplot()# 按照不同类别对样本数据进行分布散点图绘制tips = sns.load_dataset("tips")print(tips.head())sns.stripplot(x="day", # x → 设置分组统计字段 y="total_bill", # y → 数据分布统计字段 # 这里xy数据对调，将会使得散点图横向分布 data=tips, # data → 对应数据 jitter = True, # jitter → 当点数据重合较多时，用该参数做一些调整，也可以设置间距如：jitter = 0.1 size = 5, edgecolor = 'w',linewidth=1,marker = 'o' # 设置点的大小、描边颜色或宽度、点样式 ) total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21f971320&gt; 12345# stripplot()# 通过hue参数再分类sns.stripplot(x="sex", y="total_bill", hue="day", data=tips, jitter=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21f9b2b00&gt; 12345678# stripplot()# 设置调色盘sns.stripplot(x="sex", y="total_bill", hue="day", data=tips, jitter=True, palette="Set2", # 设置调色盘 dodge=True, # 是否拆分 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fc11198&gt; 123456789# stripplot()# 筛选分类类别print(tips['day'].value_counts())# 查看day字段的唯一值sns.stripplot(x="day", y="total_bill", data=tips,jitter = True, order = ['Sat','Sun'])# order → 筛选类别 Sat 87 Sun 76 Thur 62 Fri 19 Name: day, dtype: int64 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fc8c748&gt; 4.2 分簇散点图1234567# swarmplot()# 分簇散点图sns.swarmplot(x="total_bill", y="day", data=tips, size = 5, edgecolor = 'w',linewidth=1,marker = 'o', palette = 'Reds')# 用法和stripplot类似 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fcdef28&gt; 4.3 箱型图123456789101112131415# boxplot()sns.boxplot(x="day", y="total_bill", data=tips, linewidth = 2, # 线宽 width = 0.8, # 箱之间的间隔比例 fliersize = 3, # 异常点大小 palette = 'hls', # 设置调色板 whis = 1.5, # 设置IQR notch = True, # 设置是否以中值做凹槽 order = ['Thur','Fri','Sat','Sun'], # 筛选类别 )# 绘制箱型图#sns.swarmplot(x="day", y="total_bill", data=tips,color ='k',size = 3,alpha = 0.8)# 可以添加散点图 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fd32710&gt; 123# 通过hue参数再分类sns.boxplot(x="day", y="total_bill", data=tips, hue = 'smoker', palette = 'Reds') &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fdce5c0&gt; 4.4 小提琴图12345678910111213# violinplot()sns.violinplot(x="day", y="total_bill", data=tips, linewidth = 2, # 线宽 width = 0.8, # 箱之间的间隔比例 palette = 'hls', # 设置调色板 order = ['Thur','Fri','Sat','Sun'], # 筛选类别 scale = 'area', # 测度小提琴图的宽度：area-面积相同，count-按照样本数量决定宽度，width-宽度一样 gridsize = 50, # 设置小提琴图边线的平滑度，越高越平滑 inner = 'box', # 设置内部显示类型 → “box”, “quartile”, “point”, “stick”, None #bw = 0.8 # 控制拟合程度，一般可以不设置 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21feb0d68&gt; 123456# 通过hue参数再分类sns.violinplot(x="day", y="total_bill", data=tips, hue = 'smoker', palette="muted", split=True, # 设置是否拆分小提琴图 inner="quartile") &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21ff37940&gt; 12345# 结合散点图sns.violinplot(x="day", y="total_bill", data=tips, palette = 'hls', inner = None)sns.swarmplot(x="day", y="total_bill", data=tips, color="w", alpha=.5)# 插入散点图 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21fff0e80&gt; 4.5 LV图123456789101112# lvplot()sns.lvplot(x="day", y="total_bill", data=tips, palette="mako", #hue = 'smoker', width = 0.8, # 箱之间间隔比例 linewidth = 12, scale = 'area', # 设置框的大小 → “linear”、“exonential”、“area” k_depth = 'proportion', # 设置框的数量 → “proportion”、“tukey”、“trustworthy” )# 绘制LV图sns.swarmplot(x="day", y="total_bill", data=tips,color ='k',size = 3,alpha = 0.8)# 可以添加散点图 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b22101c400&gt; 4.6分类统计图1234567891011121314151617181920# barplot()# 柱状图 - 置信区间估计# 置信区间：样本均值 + 抽样误差titanic = sns.load_dataset("titanic")#print(titanic.head())#print('-----')# 加载数据sns.barplot(x="sex", y="survived", hue="class", data=titanic, palette = 'hls', order = ['male','female'], # 筛选类别 capsize = 0.05, # 误差线横向延伸宽度 saturation=.8, # 颜色饱和度 errcolor = 'gray',errwidth = 2, # 误差线颜色，宽度 ci = 'sd' # 置信区间误差 → 0-100内值、'sd'、None )#print(titanic.groupby(['sex','class']).mean()['survived'])#print(titanic.groupby(['sex','class']).std()['survived'])# 计算数据 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b2210a1048&gt; 1234567# barplot()# 柱状图 - 置信区间估计sns.barplot(x="day", y="total_bill", hue="sex", data=tips, palette = 'Blues',edgecolor = 'w')tips.groupby(['day','sex']).mean()# 计算数据 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } total_bill tip size day sex Thur Male 18.714667 2.980333 2.433333 Female 16.715312 2.575625 2.468750 Fri Male 19.857000 2.693000 2.100000 Female 14.145556 2.781111 2.111111 Sat Male 20.802542 3.083898 2.644068 Female 19.680357 2.801786 2.250000 Sun Male 21.887241 3.220345 2.810345 Female 19.872222 3.367222 2.944444 12345678910111213141516171819202122# 1、barplot()# 柱状图 - 置信区间估计crashes = sns.load_dataset("car_crashes").sort_values("total", ascending=False)print(crashes.head())# 加载数据f, ax = plt.subplots(figsize=(6, 15))# 创建图表sns.set_color_codes("pastel")sns.barplot(x="total", y="abbrev", data=crashes, label="Total", color="b",edgecolor = 'w')# 设置第一个柱状图sns.set_color_codes("muted")sns.barplot(x="alcohol", y="abbrev", data=crashes, label="Alcohol-involved", color="b",edgecolor = 'w')# 设置第二个柱状图ax.legend(ncol=2, loc="lower right")sns.despine(left=True, bottom=True) total speeding alcohol not_distracted no_previous ins_premium \ 40 23.9 9.082 9.799 22.944 19.359 858.97 34 23.9 5.497 10.038 23.661 20.554 688.75 48 23.8 8.092 6.664 23.086 20.706 992.61 3 22.4 4.032 5.824 21.056 21.280 827.34 17 21.4 4.066 4.922 16.692 16.264 872.51 ins_losses abbrev 40 116.29 SC 34 109.72 ND 48 152.56 WV 3 142.39 AR 17 137.13 KY 1234567# countplot()# 计数柱状图sns.countplot(x="class", hue="who", data=titanic,palette = 'magma')#sns.countplot(y="class", hue="who", data=titanic,palette = 'magma') # x/y → 以x或者y轴绘图（横向，竖向）# 用法和barplot相似 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b22117aac8&gt; 123456789101112# pointplot()# 折线图 - 置信区间估计sns.pointplot(x="time", y="total_bill", hue = 'smoker',data=tips, palette = 'hls', dodge = True, # 设置点是否分开 join = True, # 是否连线 markers=["o", "x"], linestyles=["-", "--"], # 设置点样式、线型 )tips.groupby(['time','smoker']).mean()['total_bill']# 计算数据# # 用法和barplot相似 time smoker Lunch Yes 17.399130 No 17.050889 Dinner Yes 21.859429 No 20.095660 Name: total_bill, dtype: float64 5.线性数据可视化5.1基本使用1234567891011# 基本用法tips = sns.load_dataset("tips")print(tips.head())# 加载数据sns.lmplot(x="total_bill", y="tip", hue = 'smoker',data=tips,palette="Set1", ci = 70, # 误差值 size = 5, # 图表大小 markers = ['+','o'], # 点样式 ) total_bill tip sex smoker day time size 0 16.99 1.01 Female No Sun Dinner 2 1 10.34 1.66 Male No Sun Dinner 3 2 21.01 3.50 Male No Sun Dinner 3 3 23.68 3.31 Male No Sun Dinner 2 4 24.59 3.61 Female No Sun Dinner 4 &lt;seaborn.axisgrid.FacetGrid at 0x1b21c57d7b8&gt; 5.2 多表格1sns.lmplot(x="total_bill", y="tip", col="smoker", data=tips) &lt;seaborn.axisgrid.FacetGrid at 0x1b2215774e0&gt; 1234567# 多图表1sns.lmplot(x="size", y="total_bill", hue="day", col="day",data=tips, aspect=0.6, # 长宽比 x_jitter=.30, # 给x或者y轴随机增加噪音点 col_wrap=4, # 每行的列数 ) &lt;seaborn.axisgrid.FacetGrid at 0x1b2216276a0&gt; 12345# 多图表2sns.lmplot(x="total_bill", y="tip", row="sex", col="time",data=tips, size=4)# 行为sex字段，列为time字段# x轴total_bill, y轴tip &lt;seaborn.axisgrid.FacetGrid at 0x1b22160a400&gt; 5.3 非线性回归1234# 非线性回归sns.lmplot(x="total_bill", y="tip",data=tips, order = 2) &lt;seaborn.axisgrid.FacetGrid at 0x1b2214d7b00&gt; 6. 其他图表可视化6.1 时间线图123456789101112131415# tsplot()x = np.linspace(0, 15, 31)data = np.sin(x) + np.random.rand(10, 31) + np.random.randn(10, 1)#print(data.shape)#print(pd.DataFrame(data).head())# 创建数据sns.tsplot(data=data, err_style="ci_band", # 误差数据风格，可选：ci_band, ci_bars, boot_traces, boot_kde, unit_traces, unit_points interpolate=True, # 是否连线 ci = [40,70,90], # 设置误差区间 color = 'r' # 设置颜色 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b21668c860&gt; 123sns.tsplot(data=data, err_style="boot_traces", n_boot=300 # 迭代次数 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b216533048&gt; 12345678910111213gammas = sns.load_dataset("gammas")print(gammas.head())print('数据量为：%i条' % len(gammas))print('timepoint为0.0时的数据量为：%i条' % len(gammas[gammas['timepoint'] == 0]))print('timepoint共有%i个唯一值' % len(gammas['timepoint'].value_counts()))#print(gammas['timepoint'].value_counts()) # 查看唯一值具体信息# 导入数据sns.tsplot(time="timepoint", # 时间数据，x轴 value="BOLD signal", # y轴value unit="subject", # condition="ROI", # 分类 data=gammas) timepoint ROI subject BOLD signal 0 0.0 IPS 0 0.513433 1 0.0 IPS 1 -0.414368 2 0.0 IPS 2 0.214695 3 0.0 IPS 3 0.814809 4 0.0 IPS 4 -0.894992 数据量为：6000条 timepoint为0.0时的数据量为：60条 timepoint共有100个唯一值 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b221f95a58&gt; 6.2 热图123456789# 热图 - heatmap()# 简单示例df = pd.DataFrame(np.random.rand(10,15))# 创建数据 - 10*12图表sns.heatmap(df, # 加载数据 vmin=0, vmax=1 # 设置图例最大最小值 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b221faac88&gt; 123456789101112131415161718# heatmap()# 参数设置flights = sns.load_dataset("flights")flights = flights.pivot("month", "year", "passengers") #print(flights.head())# 加载数据 sns.heatmap(flights, annot = True, # 是否显示数值 fmt = 'd', # 格式化字符串 linewidths = 0.2, # 格子边线宽度 #center = 100, # 调色盘的色彩中心值，若没有指定，则以cmap为主 #cmap = 'Reds', # 设置调色盘 cbar = True, # 是否显示图例色带 #cbar_kws=&#123;"orientation": "horizontal"&#125;, # 是否横向显示图例色带 #square = True, # 是否正方形显示图表 ) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b223040588&gt; 123456789101112131415161718192021# heatmap()# 绘制半边热图sns.set(style="white")# 设置风格rs = np.random.RandomState(33)d = pd.DataFrame(rs.normal(size=(100, 26)))corr = d.corr() # 求解相关性矩阵表格# 创建数据mask = np.zeros_like(corr, dtype=np.bool)mask[np.triu_indices_from(mask)] = True# 设置一个“上三角形”蒙版cmap = sns.diverging_palette(220, 10, as_cmap=True)# 设置调色盘sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0, square=True, linewidths=0.2)# 生成半边热图 &lt;matplotlib.axes._subplots.AxesSubplot at 0x1b2231f3128&gt; 6.3 图标矩阵12345678910111213141516attend = sns.load_dataset("attention")print(attend.head())# 加载数据g = sns.FacetGrid(attend, col="subject", col_wrap=5, # 设置每行的图表数量 size=1.5)g.map(plt.plot, "solutions", "score", marker="o",color = 'gray',linewidth = 2)# 绘制图表矩阵g.set(xlim = (0,4), ylim = (0,10), xticks = [0,1,2,3,4], yticks = [0,2,4,6,8,10] )# 设置x，y轴刻度 Unnamed: 0 subject attention solutions score 0 0 1 divided 1 2.0 1 1 2 divided 1 3.0 2 2 3 divided 1 3.0 3 3 4 divided 1 5.0 4 4 5 divided 1 4.0 &lt;seaborn.axisgrid.FacetGrid at 0x1b22328cb00&gt; 12]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F02%2Fpandas%E5%AE%9E%E8%B7%B5%2Fpandas%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1234%matplotlib inlineimport numpy as npimport pandas as pdimport matplotlib.pyplot as plt1234# 加载数据data_01 = pd.read_csv('data/data_01.csv')data_02 = pd.read_csv('data/data_02.csv')data_03 = pd.read_csv('data/data_03.csv') 将三个数据合并concat(objs, axis,join) objs: series，dataframe或者pannel构成的list序列 axis: 需要合并链接的轴，0表示的是行，1表示的是列,默认为0 join: 表示连接方式，inner或者outer 12data = pd.concat([data_01, data_02, data_03])data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm contbr_nm contbr_st contbr_employer contbr_occupation contb_receipt_amt contb_receipt_dt 0 Bachmann, Michelle HARVEY, WILLIAM AL RETIRED RETIRED 250.0 20-Jun-11 1 Bachmann, Michelle HARVEY, WILLIAM AL RETIRED RETIRED 50.0 23-Jun-11 2 Bachmann, Michelle SMITH, LANIER AL INFORMATION REQUESTED INFORMATION REQUESTED 250.0 5-Jul-11 3 Bachmann, Michelle BLEVINS, DARONDA AR NONE RETIRED 250.0 1-Aug-11 4 Bachmann, Michelle WARDENBURG, HAROLD AR NONE RETIRED 300.0 20-Jun-11 1data.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 1001732 entries, 0 to 1730 Data columns (total 7 columns): cand_nm 1001732 non-null object contbr_nm 1001732 non-null object contbr_st 1001728 non-null object contbr_employer 988003 non-null object contbr_occupation 993302 non-null object contb_receipt_amt 1001732 non-null float64 contb_receipt_dt 1001732 non-null object dtypes: float64(1), object(6) memory usage: 61.1+ MB 各字段含义 cand_nm — 接受捐赠的候选人姓名 contbr_nm — 捐赠人姓名 contbr_st — 捐赠人所在州 contbr_employer — 捐赠人所在公司 contbr_occupation — 捐赠人职业 contb_receipt_amt — 捐赠数额（美元） contb_receipt_dt — 收到捐款的日期 1data.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } contb_receipt_amt count 1.001732e+06 mean 2.982358e+02 std 3.749665e+03 min -3.080000e+04 25% 3.500000e+01 50% 1.000000e+02 75% 2.500000e+02 max 2.014491e+06 2.数据清洗2.1缺失值处理dataframe.fillna()函数，对缺失值进行处理共有5个参数，功能是用指定的方法填充NA/NaN value: 变量，字典，Series or Dataframe method: {‘backfill’,’bfill’,’pad’,’ffill’,None}，默认值为None，pad/ffill表示用前一个非缺失值去填充缺失值backfill/bfill表示用下一个非缺失值填充该缺失值，None指定一个值去代替缺失值 inplace: True or False，True表示在原始数据上修改，False表示创建一个副本在副本上修改 limit: int，表示连续填充最大值，默认为None 123# 将两个字段用NOT PROVIDED填充data['contbr_employer'].fillna('NOT PROVIDED', inplace=True)data['contbr_occupation'].fillna('NOT PROVIDED', inplace=True) 1print('一共有&#123;&#125;位候选人'.format(len(data['cand_nm'].unique()))) 一共有13位候选人 12# 类似SQL中的distinct操作data['cand_nm'].unique() array([&#39;Bachmann, Michelle&#39;, &#39;Romney, Mitt&#39;, &#39;Obama, Barack&#39;, &quot;Roemer, Charles E. &#39;Buddy&#39; III&quot;, &#39;Pawlenty, Timothy&#39;, &#39;Johnson, Gary Earl&#39;, &#39;Paul, Ron&#39;, &#39;Santorum, Rick&#39;, &#39;Cain, Herman&#39;, &#39;Gingrich, Newt&#39;, &#39;McCotter, Thaddeus G&#39;, &#39;Huntsman, Jon&#39;, &#39;Perry, Rick&#39;], dtype=object) 1234567891011121314parties = &#123;'Bachmann, Michelle': 'Republican', 'Cain, Herman': 'Republican', 'Gingrich, Newt': 'Republican', 'Huntsman, Jon': 'Republican', 'Johnson, Gary Earl': 'Republican', 'McCotter, Thaddeus G': 'Republican', 'Obama, Barack': 'Democrat', 'Paul, Ron': 'Republican', 'Pawlenty, Timothy': 'Republican', 'Perry, Rick': 'Republican', "Roemer, Charles E. 'Buddy' III": 'Republican', 'Romney, Mitt': 'Republican', 'Santorum, Rick': 'Republican'&#125;data['party'] = data['cand_nm'].map(parties) 1data['party'].value_counts() Democrat 593747 Republican 407985 Name: party, dtype: int64 排序，按照职业汇总对赞助金额进行排序按照各个职位进行汇总，计算赞助总金额展示前20项，发现不少职业是相同的，只不过表达方式不一样，如C.E.O和CEO DataFrame.sort_value(by,ascengding=True,inplace=False) by表示根据那一项排序，可以传入多列值 ascending=True表示升序，False表示降序，inplace=True表示修复原dataframe，默认为False 1data.groupby('contbr_occupation')['contb_receipt_amt'].sum().sort_values(ascending=False)[:20] contbr_occupation RETIRED 48176397.00 ATTORNEY 18470473.30 HOMEMAKER 17484807.65 INFORMATION REQUESTED PER BEST EFFORTS 15859514.55 INFORMATION REQUESTED 8742357.59 PHYSICIAN 7224044.40 PRESIDENT 6347843.59 EXECUTIVE 5273717.90 CONSULTANT 4932627.98 NOT PROVIDED 4224760.39 CEO 3570942.20 LAWYER 3537982.19 OWNER 3278488.16 INVESTOR 3204481.92 ENGINEER 2730527.43 PROFESSOR 2458033.81 C.E.O. 2433218.11 SELF-EMPLOYED 2259150.94 MANAGER 2167571.47 REAL ESTATE 2110499.34 Name: contb_receipt_amt, dtype: float64 利用函数进行数据转换:职业和雇主信息分析许多职业都涉及基本相同的工作类型，下面我们来清理下这样的数据(利用了dict.get) dict.get(key, default=None) 参数类型 key: 字典中要查找的键 defult：如何字典中键不存在，默认返回default 下面例子中get(x, x)，意思是如果不存在x，如果没有找到对应的映射，就返回原来的值，如果找到了对应的映射，就返回键指定的值。 map(function, iterable) map函数是根据提供的函数对指定的序列做映射。 第一个参数function是函数，后面的每一个元素都会调用function函数，返回包含每次function函数返回的新列表 返回值: python 2.x 返回列表 python 3.x 返回迭代器 像列表、元组、字符串、字典等都是可迭代对象，每次从中取出一个数的过程便叫做迭代 next函数表示访问迭代器的下一条数据 迭代器生成方式,，data可以表示为数据也可以表示为 iterator=iter(data) 迭代器用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。 for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item 12345678def square(x): return x*xy = map(square, [1, 2, 3, 4, 5])print(next(y))print(next(y))for i in y: print(i) 1 4 9 16 25 12 12345678910111213#建立一个职业对应字典，把相同职业的不同表达映射为对应的职业，比如把C.E.O.映射为CEOoccupation_map = &#123; 'INFORMATION REQUESTED PER BEST EFFORTS':'NOT PROVIDED', 'INFORMATION REQUESTED':'NOT PROVIDED', 'SELF' : 'SELF-EMPLOYED', 'SELF EMPLOYED' : 'SELF-EMPLOYED', 'C.E.O.':'CEO', 'LAWYER':'ATTORNEY',&#125;# 如果不在字典中，返回xf = lambda x: occupation_map.get(x, x)data.contbr_occupation = data.contbr_occupation.map(f) 1map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) &lt;map at 0x1fb229bc4a8&gt; 2.3 数据筛选赞助商金额筛选 赞助包括退款(负的出资额) 1data = data[data['contb_receipt_amt']&gt;0] 候选人筛选 1data.groupby('cand_nm')['contb_receipt_amt'].sum().sort_values(ascending=False) cand_nm Obama, Barack 1.358776e+08 Romney, Mitt 8.833591e+07 Paul, Ron 2.100962e+07 Perry, Rick 2.030675e+07 Gingrich, Newt 1.283277e+07 Santorum, Rick 1.104316e+07 Cain, Herman 7.101082e+06 Pawlenty, Timothy 6.004819e+06 Huntsman, Jon 3.330373e+06 Bachmann, Michelle 2.711189e+06 Johnson, Gary Earl 5.669616e+05 Roemer, Charles E. &#39;Buddy&#39; III 3.730099e+05 McCotter, Thaddeus G 3.903000e+04 Name: contb_receipt_amt, dtype: float64 12# 选取候选人为Obama、Romneyd的子数据集data_vs = data[data['cand_nm'].isin(['Romney, Mitt','Obama, Barack'])].copy() 1data_vs.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 694283 entries, 410 to 201385 Data columns (total 8 columns): cand_nm 694283 non-null object contbr_nm 694283 non-null object contbr_st 694279 non-null object contbr_employer 694283 non-null object contbr_occupation 694283 non-null object contb_receipt_amt 694283 non-null float64 contb_receipt_dt 694283 non-null object party 694283 non-null object dtypes: float64(1), object(7) memory usage: 47.7+ MB 2.4 面元化数据利用cut函数根据出资额大小将数据离散化到多个面源当中 pandas.cut函数作用 将数据离散化统计区间段 123bins = np.array([0,1,10,100,1000,10000,100000,1000000,10000000])labels = pd.cut(data_vs['contb_receipt_amt'],bins)labels 410 (10, 100] 411 (100, 1000] 412 (100, 1000] 413 (10, 100] 414 (10, 100] 415 (10, 100] 416 (100, 1000] 417 (10, 100] 418 (100, 1000] 419 (10, 100] 420 (10, 100] 421 (100, 1000] 422 (100, 1000] 423 (100, 1000] 424 (100, 1000] 425 (100, 1000] 426 (1000, 10000] 427 (100, 1000] 428 (100, 1000] 429 (10, 100] 430 (1000, 10000] 431 (100, 1000] 432 (100, 1000] 433 (100, 1000] 434 (100, 1000] 435 (100, 1000] 436 (10, 100] 437 (100, 1000] 438 (100, 1000] 439 (10, 100] ... 201356 (10, 100] 201357 (1, 10] 201358 (10, 100] 201359 (10, 100] 201360 (10, 100] 201361 (10, 100] 201362 (100, 1000] 201363 (10, 100] 201364 (10, 100] 201365 (10, 100] 201366 (10, 100] 201367 (10, 100] 201368 (100, 1000] 201369 (10, 100] 201370 (10, 100] 201371 (10, 100] 201372 (10, 100] 201373 (10, 100] 201374 (10, 100] 201375 (10, 100] 201376 (1000, 10000] 201377 (10, 100] 201378 (10, 100] 201379 (100, 1000] 201380 (1000, 10000] 201381 (10, 100] 201382 (100, 1000] 201383 (1, 10] 201384 (10, 100] 201385 (100, 1000] Name: contb_receipt_amt, Length: 694283, dtype: category Categories (8, interval[int64]): [(0, 1] &lt; (1, 10] &lt; (10, 100] &lt; (100, 1000] &lt; (1000, 10000] &lt; (10000, 100000] &lt; (100000, 1000000] &lt; (1000000, 10000000]] 3. 数据聚合和分组运算分组计算Grouping，分组运算是一个“split-apply-combine”的过程： 拆分，pandas对象中的数据会根据你所提供的一个或多个键被拆分为多组 应用，将一个函数应用到各个分组并产生一个新值 合并，所有这些函数的执行结果会合并到最终的结果对象中 3.1 透视表利用pivot_table对数据进行分析 12345# 按照党派、职业对赞助金额进行汇总，类似excel中的透视表操作，聚合函数为sumby_occupation = data.pivot_table('contb_receipt_amt', index='contbr_occupation', columns='party', aggfunc='sum')# 过滤掉赞助数小于200w的数据over_2mm = by_occupation[by_occupation.sum(1)&gt;2000000]over_2mm &lt;/style&gt; party Democrat Republican contbr_occupation ATTORNEY 14302461.84 7.868419e+06 CEO 2074974.79 4.211041e+06 CONSULTANT 2459912.71 2.544725e+06 ENGINEER 951525.55 1.818374e+06 EXECUTIVE 1355161.05 4.138850e+06 HOMEMAKER 4248875.80 1.363428e+07 INVESTOR 884133.00 2.431769e+06 MANAGER 762883.22 1.444532e+06 NOT PROVIDED 13725187.32 2.097161e+07 OWNER 1001567.36 2.408287e+06 PHYSICIAN 3735124.94 3.594320e+06 PRESIDENT 1878509.95 4.720924e+06 PROFESSOR 2165071.08 2.967027e+05 REAL ESTATE 528902.09 1.625902e+06 RETIRED 25305316.38 2.356099e+07 SELF-EMPLOYED 741746.40 2.245273e+06 &lt;/div&gt; 1over_2mm.plot(kind='bar') &lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb229e5080&gt; 3.2分组级运算和转换根据职业和雇主信息分组运算 了解Obama和Romney总出资最高的职业和雇主 1234567def get_top_amounts(group, key, n=5): # 传入group by分组的对象，返回key字段排序的前n个数据 totals = group.groupby(key)['contb_receipt_amt'].sum() return totals.sort_values(ascending=False)[:n]grouped = data_vs.groupby('cand_nm')grouped.apply(get_top_amounts, 'contbr_occupation', 7) cand_nm contbr_occupation Obama, Barack RETIRED 25305316.38 ATTORNEY 14302461.84 NOT PROVIDED 13725187.32 HOMEMAKER 4248875.80 PHYSICIAN 3735124.94 CONSULTANT 2459912.71 PROFESSOR 2165071.08 Romney, Mitt NOT PROVIDED 11638509.84 RETIRED 11508473.59 HOMEMAKER 8147446.22 ATTORNEY 5372424.02 PRESIDENT 2491244.89 CEO 2324297.03 EXECUTIVE 2300947.03 Name: contb_receipt_amt, dtype: float64 从数据看出Obama更受精英群体(律师、医生、咨询顾问)的欢迎，Romney更受企业家欢迎 1grouped.apply(get_top_amounts, 'contbr_employer', 10) cand_nm contbr_employer Obama, Barack RETIRED 22694558.85 SELF-EMPLOYED 17080985.96 NOT PROVIDED 8830013.66 NOT EMPLOYED 8586308.70 INFORMATION REQUESTED 5053480.37 HOMEMAKER 2605408.54 SELF 1076531.20 SELF EMPLOYED 469290.00 STUDENT 318831.45 VOLUNTEER 257104.00 Romney, Mitt INFORMATION REQUESTED PER BEST EFFORTS 12059527.24 RETIRED 11506225.71 HOMEMAKER 8147196.22 SELF-EMPLOYED 7409860.98 STUDENT 496490.94 CREDIT SUISSE 281150.00 MORGAN STANLEY 267266.00 NOT PROVIDED 262204.00 GOLDMAN SACH &amp; CO. 238250.00 BARCLAYS CAPITAL 162750.00 Name: contb_receipt_amt, dtype: float64 123# 对赞助金额进行分组分析grouped_bins = data_vs.groupby(['cand_nm', labels])grouped_bins.size().unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm Obama, Barack Romney, Mitt contb_receipt_amt (0, 1] 493.0 77.0 (1, 10] 40070.0 3681.0 (10, 100] 372280.0 31853.0 (100, 1000] 153992.0 43357.0 (1000, 10000] 22284.0 26186.0 (10000, 100000] 2.0 1.0 (100000, 1000000] 3.0 NaN (1000000, 10000000] 4.0 NaN 1grouped_bins.size() cand_nm contb_receipt_amt Obama, Barack (0, 1] 493 (1, 10] 40070 (10, 100] 372280 (100, 1000] 153992 (1000, 10000] 22284 (10000, 100000] 2 (100000, 1000000] 3 (1000000, 10000000] 4 Romney, Mitt (0, 1] 77 (1, 10] 3681 (10, 100] 31853 (100, 1000] 43357 (1000, 10000] 26186 (10000, 100000] 1 dtype: int64 统计各个区间的赞助金额 12bucket_sums = grouped_bins['contb_receipt_amt'].sum().unstack(0)bucket_sums .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm Obama, Barack Romney, Mitt contb_receipt_amt (0, 1] 318.24 77.00 (1, 10] 337267.62 29819.66 (10, 100] 20288981.41 1987783.76 (100, 1000] 54798731.46 22363381.69 (1000, 10000] 51753705.67 63942145.42 (10000, 100000] 59100.00 12700.00 (100000, 1000000] 1490683.08 NaN (1000000, 10000000] 7148839.76 NaN 1bucket_sums.plot(kind='bar') &lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb22976fd0&gt; 123# 百分比堆积图，计算两位候选人收到赞助总金额的占比normed_sums = bucket_sums.div(bucket_sums.sum(axis=1),axis=0)normed_sums .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm Obama, Barack Romney, Mitt contb_receipt_amt (0, 1] 0.805182 0.194818 (1, 10] 0.918767 0.081233 (10, 100] 0.910769 0.089231 (100, 1000] 0.710177 0.289823 (1000, 10000] 0.447326 0.552674 (10000, 100000] 0.823120 0.176880 (100000, 1000000] 1.000000 NaN (1000000, 10000000] 1.000000 NaN 12# 是用柱状图，指定stack=True进行队列normed_sums[:-2].plot(kind='bar',stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1fb22138e48&gt; 在小额赞助方面，Obama获取的数量和金额比Romney多得多 按照赞助人姓名分组，计算重复赞助次数最多的前20人1data.groupby('contbr_nm')['contbr_nm'].count().sort_values(ascending=False)[:20] contbr_nm WILLIAMS, DEBBY 205 BERKE, DAVID MICHAEL 171 SEBAG, DAVID 161 SMITH, ERIK 145 FALLSGRAFF, TOBY 138 SKINNER, DONNA 136 CASPERSON, CAROLINA 132 HARRIS, CLAUDIA W. 132 ROSBERG, MARILYN 115 POTTS, LILLIE 114 DUDLEY, DEBBIE 111 HAUGHEY, NOEL ANTHONY 107 DFHDFH, DFHDFH 96 SHERWIN, GLEN R. 94 MITCHELL, CAITLIN 90 SMITH, CHARLES 88 NURU, ISAAC 87 KARIMIAN, AFSANEH 87 BIRMINGHAM, TOM 85 MASTERS, MARGERY 85 Name: contbr_nm, dtype: int64 4. 事件处理4.1 str转datetime我们可以使用to_datetime方法解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快。我们也可以指定特定的日期解析格式，如pd.to_datetime(series,format=’%Y%m%d’) 1data_vs['time'] = pd.to_datetime(data_vs['contb_receipt_dt']) 4.2以时间作为索引12data_vs.set_index('time',inplace=True)data_vs.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm contbr_nm contbr_st contbr_employer contbr_occupation contb_receipt_amt contb_receipt_dt party time 2012-02-01 Romney, Mitt ELDERBAUM, WILLIAM AA US GOVERNMENT FOREIGN SERVICE OFFICER 25.0 1-Feb-12 Republican 2012-02-01 Romney, Mitt ELDERBAUM, WILLIAM AA US GOVERNMENT FOREIGN SERVICE OFFICER 110.0 1-Feb-12 Republican 2012-04-13 Romney, Mitt CARLSEN, RICHARD AE DEFENSE INTELLIGENCE AGENCY INTELLIGENCE ANALYST 250.0 13-Apr-12 Republican 2011-08-21 Romney, Mitt DELUCA, PIERRE AE CISCO ENGINEER 30.0 21-Aug-11 Republican 2012-03-07 Romney, Mitt SARGENT, MICHAEL AE RAYTHEON TECHNICAL SERVICES CORP COMPUTER SYSTEMS ENGINEER 100.0 7-Mar-12 Republican 4.3 重采样和频率转换重采样(Resampling) 指的是将时间序列的频度变成另一个频度的过程。把高频度的数据变为低频度叫做降采样(downsampling),resample会对数据进行分组，然后在调用聚合函数。这里我们把频率从每日变成每月，属于高频转低频的降采样 12vs_time = data_vs.groupby('cand_nm').resample('M')['cand_nm'].count()vs_time.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm Obama, Barack Romney, Mitt time 2011-04-30 13830 1096 2011-05-31 12182 4163 2011-06-30 25626 5757 2011-07-31 12372 2454 2011-08-31 19860 3226 2011-09-30 46927 7968 2011-10-31 25941 5349 2011-11-30 32629 7737 2011-12-31 63562 10289 2012-01-31 40055 9431 2012-02-29 66416 13396 2012-03-31 123564 17807 2012-04-30 106164 16482 plt.subpolots((nrows=1, ncols=1，figsize=(32,8)) 表示在画布上面创建一个一行一列的的画布，大小为(32,8) 两个返回值一个是fig图像,另一个是子图ax的array列表。 vs_time可以理解为对该子图进行数据填充 unstack 表示将花括号结构变成表结构 123fig1,ax1 = plt.subplots(figsize=(32,8))vs_time.unstack(0).plot(kind='area',ax=ax1,alpha=0.6)plt.show() 1234567891011import numpy as npimport pandas as pdfrom pandas import Series,DataFramedata=DataFrame(np.arange(6).reshape((2,3)),index=pd.Index(['street1','street2']),columns=pd.Index(['one','two','three']))print(data)print('-----------------------------------------\n')data2=data.stack()data3=data2.unstack()print(data2)print('-----------------------------------------\n')print(data3) one two three street1 0 1 2 street2 3 4 5 ----------------------------------------- street1 one 0 two 1 three 2 street2 one 3 two 4 three 5 dtype: int32 ----------------------------------------- one two three street1 0 1 2 street2 3 4 5 12]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F24%2Fpandas%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1234%matplotlib inlineimport numpy as npimport pandas as pdimport matplotlib.pyplot as plt1234# 加载数据data_01 = pd.read_csv('data/data_01.csv')data_02 = pd.read_csv('data/data_02.csv')data_03 = pd.read_csv('data/data_03.csv') 将三个数据合并concat(objs, axis,join) objs: series，dataframe或者pannel构成的list序列 axis: 需要合并链接的轴，0表示的是行，1表示的是列,默认为0 join: 表示连接方式，inner或者outer 123data = pd.concat([data_01, data_02, data_03])data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } cand_nm contbr_nm contbr_st contbr_employer contbr_occupation contb_receipt_amt contb_receipt_dt 0 Bachmann, Michelle HARVEY, WILLIAM AL RETIRED RETIRED 250.0 20-Jun-11 1 Bachmann, Michelle HARVEY, WILLIAM AL RETIRED RETIRED 50.0 23-Jun-11 2 Bachmann, Michelle SMITH, LANIER AL INFORMATION REQUESTED INFORMATION REQUESTED 250.0 5-Jul-11 3 Bachmann, Michelle BLEVINS, DARONDA AR NONE RETIRED 250.0 1-Aug-11 4 Bachmann, Michelle WARDENBURG, HAROLD AR NONE RETIRED 300.0 20-Jun-11 1data.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 1001732 entries, 0 to 1730 Data columns (total 7 columns): cand_nm 1001732 non-null object contbr_nm 1001732 non-null object contbr_st 1001728 non-null object contbr_employer 988003 non-null object contbr_occupation 993302 non-null object contb_receipt_amt 1001732 non-null float64 contb_receipt_dt 1001732 non-null object dtypes: float64(1), object(6) memory usage: 61.1+ MB 各字段含义 cand_nm — 接受捐赠的候选人姓名 contbr_nm — 捐赠人姓名 contbr_st — 捐赠人所在州 contbr_employer — 捐赠人所在公司 contbr_occupation — 捐赠人职业 contb_receipt_amt — 捐赠数额（美元） contb_receipt_dt — 收到捐款的日期 1data.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } contb_receipt_amt count 1.001732e+06 mean 2.982358e+02 std 3.749665e+03 min -3.080000e+04 25% 3.500000e+01 50% 1.000000e+02 75% 2.500000e+02 max 2.014491e+06 2.数据清洗2.1缺失值处理dataframe.fillna()函数，对缺失值进行处理共有5个参数，功能是用指定的方法填充NA/NaN value: 变量，字典，Series or Dataframe method: {‘backfill’,’bfill’,’pad’,’ffill’,None}，默认值为None，pad/ffill表示用前一个非缺失值去填充缺失值backfill/bfill表示用下一个非缺失值填充该缺失值，None指定一个值去代替缺失值 inplace: True or False，True表示在原始数据上修改，False表示创建一个副本在副本上修改 limit: int，表示连续填充最大值，默认为None 123# 将两个字段用NOT PROVIDED填充data['contbr_employer'].fillna('NOT PROVIDED', inplace=True)data['contbr_occupation'].fillna('NOT PROVIDED', inplace=True) 1print('一共有&#123;&#125;位候选人'.format(len(data['cand_nm'].unique()))) 一共有13位候选人 12# 类似SQL中的distinct操作data['cand_nm'].unique() array([&#39;Bachmann, Michelle&#39;, &#39;Romney, Mitt&#39;, &#39;Obama, Barack&#39;, &quot;Roemer, Charles E. &#39;Buddy&#39; III&quot;, &#39;Pawlenty, Timothy&#39;, &#39;Johnson, Gary Earl&#39;, &#39;Paul, Ron&#39;, &#39;Santorum, Rick&#39;, &#39;Cain, Herman&#39;, &#39;Gingrich, Newt&#39;, &#39;McCotter, Thaddeus G&#39;, &#39;Huntsman, Jon&#39;, &#39;Perry, Rick&#39;], dtype=object) 1234567891011121314parties = &#123;'Bachmann, Michelle': 'Republican', 'Cain, Herman': 'Republican', 'Gingrich, Newt': 'Republican', 'Huntsman, Jon': 'Republican', 'Johnson, Gary Earl': 'Republican', 'McCotter, Thaddeus G': 'Republican', 'Obama, Barack': 'Democrat', 'Paul, Ron': 'Republican', 'Pawlenty, Timothy': 'Republican', 'Perry, Rick': 'Republican', "Roemer, Charles E. 'Buddy' III": 'Republican', 'Romney, Mitt': 'Republican', 'Santorum, Rick': 'Republican'&#125;data['party'] = data['cand_nm'].map(parties) 1data['party'].value_counts() Democrat 593747 Republican 407985 Name: party, dtype: int64 排序，按照职业汇总对赞助金额进行排序按照各个职位进行汇总，计算赞助总金额展示前20项，发现不少职业是相同的，只不过表达方式不一样，如C.E.O和CEO DataFrame.sort_value(by,ascengding=True,inplace=False) by表示根据那一项排序，可以传入多列值 ascending=True表示升序，False表示降序，inplace=True表示修复原dataframe，默认为False 1data.groupby('contbr_occupation')['contb_receipt_amt'].sum().sort_values(ascending=False)[:20] contbr_occupation RETIRED 48176397.00 ATTORNEY 18470473.30 HOMEMAKER 17484807.65 INFORMATION REQUESTED PER BEST EFFORTS 15859514.55 INFORMATION REQUESTED 8742357.59 PHYSICIAN 7224044.40 PRESIDENT 6347843.59 EXECUTIVE 5273717.90 CONSULTANT 4932627.98 NOT PROVIDED 4224760.39 CEO 3570942.20 LAWYER 3537982.19 OWNER 3278488.16 INVESTOR 3204481.92 ENGINEER 2730527.43 PROFESSOR 2458033.81 C.E.O. 2433218.11 SELF-EMPLOYED 2259150.94 MANAGER 2167571.47 REAL ESTATE 2110499.34 Name: contb_receipt_amt, dtype: float64 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[特征工程(一)]]></title>
    <url>%2F2019%2F09%2F21%2F%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[fit,fit_transform,transform的区别 fit在训练模型的时候使用 fit_transform的作用是先拟合数据，然后将其转换成标准形式，一般是用在训练集上，例如StandardScaler计算出标准差 transfrom：指的是直接对数据进行标准化，直接用·训练集拟合的结果进行标准化或者归一化]]></content>
      <categories>
        <category>机器学习</category>
        <category>特征工程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据降维</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive的基本操作]]></title>
    <url>%2F2019%2F09%2F17%2Fhive%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[表的增删改查操作创建表使用if not exists 如果存在则跳过，comment为注释。123456789create table if not exists mydb.employees( name string comment 'Employee name', salary float comment 'Employee salary', subordinates array&lt;string&gt; comment 'Names of subordinates', deduction map&lt;string, float&gt;, address struct&lt;street:string, city:string, state:string, zip:int&gt; comment 'Home address')comment 'descriptions of table'location '/user/hive/warehouse/mydb.db/employees'; 描述表显示表的字段和结构，使用desc/describe 1234--显示表的字段和数据类型desc table_name;--显示对应字段的数据类型desc table_name.columns 管理表和外部表管理表是hive创建的表，由hive控制其生命周期，hive默认情况下会将数据存在在配置文件指定的目录当中，由hive.metastore.warehouse.dir指定。当使用hive删除表的时候，对应的数据也会被删除，即hdfs文件系统中的数据也会被删除。管理表的缺点在于无法共享数据，比如利用pig等工具创建的数据，hive对其没有权限。当使用hive查询这些数据的时候就可以使用一个外部表指向这份数据，而不需要对其的权限。外部表需要使用external修饰。 123456789101112create external table if not exists stocks( exchange string, symbol string, ymd string, price__open string, price__high string, price__low string, price__close float, volume int, price_adj_close float)row format delimited fields terminated by ',' '分隔符为,'location 'data/stocks'; 加上external字段值后，删除表并不会删除这份数据，不过描述标的元数据信息会被删除。元数据可以理解为对该表的描述信息，而不是表内数据。 需要注意的是如果语句省略了external关键字同事源表是外部表，那么新表也是外部表，如果源表是管理表，新表也是管理表。在加上external之后，无论源表是管理表还是外部表，新表都是外部表。 分区表在建表过程中，会根据分区字段创建对应目录，优点在于分层存储，可以加快查询速度，而缺点在于一些数据存在于文件目录下，但是hive只能从表中读取数据，因此会造成资源浪费。分区表创建： 12345678create table employees( name string, salary float, subordinates array&lt;string&gt;, deduction map&lt;string,float&gt;, address struct&lt;street:string, city:string, city:string, state:string&gt;)partitioned by (country string, state string); 在建表的时候hive在hdfs上的目录为…/employees/country/state 查看表中存在所有分区 1show partitions employees; 查询指定分区 1show partitions employees partition(country='CHINA') 删除表1drop table if exists table_name; 对于管理表，表的元数据和表内数据都会被删除。 修改表 表的重命名将表从ａ重命名为ｂ 1alter table a rename to b; 增加表分区1234567alter table add partiion--在一个查询语句中增加多个分区alter table table_name if not exists partition(...) location '/user/hive/warehouse/a'partition(...) location '/user/hive/warehouse/b'partition(...) location '/user/hive/warehouse/c' 修改列的信息将列名从a改到b，并且将其移到serverity字段后面。 1234alter table table_name change column a b type_name '修改列的数据类型'comment 'xxx'after serverity 增加新的列1234alter table table_name add column( app_name string comment 'Application name', session_id long comment 'the current session id';) 删除或替换列1234alter table table_name replace columns（ hour_mins_secs INT comment 'xxx' severity string comment 'xxx';) 将之前的列都删除，只留下replace的列 修改表的属性1alter table table_name set tblproperties('notes'='xxx'); 修改表的存储属性1alter table table_name partition(a=xxx,b=xxx,c=xxx) set fileformat sequencefile; 指定对应的分区中的表，并且重新设置其格式。 加载和导出数据从本地加载数据123load data local inpath '/home/hadopp/data.txt'overwrite into table employeespartition(country='US',state='CA'); 需要注意的是创建分区表的时候使用的是partition by。如果目录不存在，hive会先创建分区目录。 通过查询语句加载数据123insert overwrite table employeespartition(country='US',state='CA')select * from table_name where xxx=xxx; 通过查询语句建表12create table if not exists table_name as select * from table_name_b; 导出数据12345--方法一，谁用hadoop提供的工具hadoop fs -cp source_path target_path--方法二insert overwrite local directory '/home/hadoop/employees'select * from employees; hive的连接操作table stu 12341 chenli 212 xuzeng 223 xiaodan 234 hua 24 table sub 12341 chinese2 english3 science5 nature 内连接inner join，关键字 join on。仅列出两个表中符合连接条件的数据。 12345select a.*,b.* from stu a join sub b on a.id=b.id--结果1 chenli 21 1 chinese2 xuzeng 22 2 english3 xiaodan 23 3 science join后面连接表，而on指定连接条件。 左连接和右连接左连接，显示左边表的所有数据，如果右边表有与之对应的数据则显示，否则显示为NULL。 123456select a.* from stu a left outer join sub b on a.id=b.id;--结果1 chenli 21 1 chinese2 xuzeng 22 2 english3 xiaodan 23 3 science4 hua 24 NULL NULL 右连接与左连接相反，使用的关键字为 right outer join xxx on xxx。 标准查询关键字执行顺序为 from-&gt;where-&gt;group by-&gt;having-&gt;order by。 全连接左表和右表都显示，如果没有对应数据，则都显示为NULL 1234567select a.* from stu a full outer join sub b on a.id=b.id;--结果1 chenli 21 1 chinese2 xuzeng 22 2 english3 xiaodan 23 3 science4 hua 24 NULL NULLNULL NULL NULL 5 nature 左半开连接左半开连接。left semi join，语法与左连接不一样，只能选择出左边表的数据，此数据符合on后面的条件。 1234567select a.* from stu a left semi join sub b on a.id=b.id;--结果1 chenli 212 xuzeng 223 xiaodan 23--下列语句会报错select a.*,b.* from stu a left semi join sub b on a.id=b.id; 笛卡尔连接123456789101112131415161718select a.*,b.* from cl_student a join cl_stu_sub b;--结果1 chenli 21 1 chinese1 chenli 21 2 english1 chenli 21 3 science1 chenli 21 5 nature2 xuzeng 22 1 chinese2 xuzeng 22 2 english2 xuzeng 22 3 science2 xuzeng 22 5 nature3 xiaodan 23 1 chinese3 xiaodan 23 2 english3 xiaodan 23 3 science3 xiaodan 23 5 nature4 hua 24 1 chinese4 hua 24 2 english4 hua 24 3 science4 hua 24 5 nature 花了几天的时间整理了hive的用法，终于不用在对着SQL摸瞎了，加油吧进击的SQL boy！ 日常福利(●´∀｀●)]]></content>
      <categories>
        <category>大数据</category>
        <category>hive编程</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive数据类型]]></title>
    <url>%2F2019%2F09%2F08%2Fhive%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[文本文件数据编码 TSV：tab separated values；即“制表符分隔值”，用制表符分隔数据 CSV： comma separated values；即“逗号分隔值”，用逗号分隔数据 两种文件存在的缺点在于文件中可能存在不需要作为分隔符的逗号或者制表符存在，所有hive有专门的分隔符。hive记录中默认的分隔符 分隔符 描述 \n 对于文本文件来说每一行都是记录，可以使用换行符作为分隔符 ^A(ctrl+A) 用于分隔字段(列)，在CREATE TABLE 语句中可以使用八进制编码\001表示，键盘上打不出来。 ^B 用于分隔array或者struct中的元素，或于用map钟键值对的分隔，在CREATE TABLE中使用\002表示 ^C 用于MAP钟键与值的分隔，用\003表示 读时模式传统数据库是写时模式，即在写入文件的时候会，会对数据的格式进行校验，如果不符合，将无法写入数据库。 hive是读时模式，在往数据库里写入不会对数据进行校验，但是在读取数据的时候会对数据进行校验，对于不合格的数据，会设置为null。 hive的优点在于加载(写)数据的时候速度较快，因为不需要对数据进行解析，而传统写时模式则有利于数据的查询。 好久没有更新博客了，这篇虽然水了点，写得像个笔记，算是开篇吧，福利就上亚丝娜吧!!!]]></content>
      <categories>
        <category>大数据</category>
        <category>hive编程</category>
      </categories>
      <tags>
        <tag>Hive</tag>
        <tag>编码类型</tag>
      </tags>
  </entry>
</search>
