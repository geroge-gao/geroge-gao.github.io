<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心如止水</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-05T15:01:41.470Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>gerogegao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode题型归纳总结</title>
    <link href="http://yoursite.com/2021/03/13/leetcode%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/13/leetcode题型归纳总结/</id>
    <published>2021-03-13T14:07:48.000Z</published>
    <updated>2021-04-05T15:01:41.470Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode常见题型及对应解法</p><h2 id="技巧类"><a href="#技巧类" class="headerlink" title="技巧类"></a>技巧类</h2><p>矩阵数据旋转</p><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><a id="more"></a><p>思路：对于正方形，最外圈是规律变化的，因此只需要将最外圈进行进行顺时针置换就行了。需要注意深拷贝和浅拷贝的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        mid = int(n/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line">            left = [a[i] <span class="keyword">for</span> a <span class="keyword">in</span> matrix]</span><br><span class="line">            right = [b[n-i<span class="number">-1</span>] <span class="keyword">for</span> b <span class="keyword">in</span> matrix]</span><br><span class="line">            upper = matrix[i].copy()</span><br><span class="line">            bottom = matrix[n-i<span class="number">-1</span>].copy()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n-i):</span><br><span class="line">                matrix[i][j] = left[n-j<span class="number">-1</span>]</span><br><span class="line">                matrix[j][n-i<span class="number">-1</span>] = upper[j]</span><br><span class="line">                matrix[n-i<span class="number">-1</span>][j] = right[n-j<span class="number">-1</span>]</span><br><span class="line">                matrix[j][i] = bottom[j]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></p><p>给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p>思路：采用左右双数组，L和R</p><script type="math/tex; mode=display">L[i] = \prod_{j=0}^{i-1}nums[j]</script><script type="math/tex; mode=display">R[i] = \prod_{j=i+1}^{n-1}nums[j]</script><script type="math/tex; mode=display">output[i]=L[i]*R[i]</script><p>所以有L = [1,1,2,6], R=[24,12,4,1]。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>1、两数之和<br>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数    组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</code></pre><p>解析：利用哈希，对于每一个元素x，利用哈希表保存x的值及其对应的索引，然后当target-y在hash表中时，则说明前面有值x+y = target。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - nums[index] <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - nums[index]], index]</span><br><span class="line">            hashtable[nums[index]] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></p><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>思路：排序+哈希</p><p> [“ate”,”eat”,”tea”]排序之后，都是aet，可以将ate全都存到hash表中，key值为ate，每个key值保存的都是对应的字母异位词组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路：将字符串转换成列表排序后合并，然后进行映射，将结果相同的合并</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line"></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            word_label = <span class="string">''</span>.join(sorted(list(s)))</span><br><span class="line">            <span class="keyword">if</span> word_label <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res[word_label] = []</span><br><span class="line"></span><br><span class="line">            res[word_label].append(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res.values())</span><br></pre></td></tr></table></figure><p>169.多数元素</p><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>思路：</p><p>思路一：哈希，找到每个元素出现的次数，然后挑选出出现次数大于n/2的</p><p>思路二：排序，利用快排对数组进行排序，然后找到中间位置的数，即为n/2的数据。</p><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></p><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>思路： 哈希，同上一题相同思路。</p><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><p>思路：利用哈希记录当前位置的前缀值prefix，此时prefix表示每个位置的前缀和，以实例1为例prefix=[1,2,3]。此时要判断当前位置的连续和是否为k只需要判断prefix[i] - k 是否在prefix中就行了，当存在前缀和的时候，有prefix[j] + k = prefix[i]，</p><p>此时[i,j]之间的数组和为k。因此只需要求前缀和，然后每次判断prefix[i]-k是否在其中，当同一个前缀和出现多次，表示有不同长度的数组到当前位置i的结果为k。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：暴力枚举，不解释连招，超时</span></span><br><span class="line"><span class="string">    思路二：利用哈希记录前缀值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化结果</span></span><br><span class="line">        pre = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            cur += nums[i]</span><br><span class="line">            <span class="keyword">if</span> cur - k <span class="keyword">in</span> pre:</span><br><span class="line">                count += pre[cur - k]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> pre:</span><br><span class="line">                pre[cur] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre[cur] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></p><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure><p>思路：前缀和+dfs。</p><p>由于路径只能从上到下，所以都是单路径，可以求每条路径上的前缀和，在判断结果是否符合。需要注意，如果两个路径都有节点的前缀和为n，那么在统计另外一个前缀和是否为n的时候，不应该考虑当前路径的情况。    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    前缀和+递归，与560题思路类似，注意</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        prefix = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, total, prefix)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> count, sum</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total += root.val</span><br><span class="line">                <span class="keyword">if</span> total - sum <span class="keyword">in</span> prefix:</span><br><span class="line">                    count += prefix[total - sum]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total <span class="keyword">in</span> prefix:</span><br><span class="line">                    prefix[total] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prefix[total] = <span class="number">1</span></span><br><span class="line">                dfs(root.left, total, prefix)</span><br><span class="line">                dfs(root.right, total, prefix)</span><br><span class="line">                <span class="comment"># 保持前缀都是在一条路径下面</span></span><br><span class="line">                prefix[total] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="number">0</span>, prefix)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></p><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><p>思路：哈希+滑窗</p><p>将p用哈希表保存，记录下每个字母出现的次数p_count，然后采用滑窗，记录s在滑窗中的字符s_count，如果p_count=s_count，说明当前滑窗中的字符和p为异位词。然后向右移动，左边移出字符次数-1，右边移入字符次数+1，然后一次对比p_count是否等于s_count。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路：参考49，滑窗+哈希+排序。超时，还需要优化</span></span><br><span class="line"><span class="string">    思路二：滑窗+哈希表，采用哈希将结果保存</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> :</span></span><br><span class="line">        p_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        s_count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line"></span><br><span class="line">        m = len(p)</span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">            p_count[ord(c)<span class="number">-97</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> right &lt; m - <span class="number">1</span>:</span><br><span class="line">                s_count[ord(s[right]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_count[ord(s[right]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> s_count == p_count:</span><br><span class="line">                    res.append(left)</span><br><span class="line"></span><br><span class="line">                s_count[ord(s[left]) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></p><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>思路一：哈希，构建一个1-n的哈希表，找到出现次数为0的数。时间复杂度O(n)，空间复杂度O(n)</p><p>思路二：原地修改。</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure><p>思路：排序+贪心</p><p>由于个子矮的对个子高的没有影响，因此优先将个子矮的放到前面(对于拍在他前面的人数相同时)。</p><p>以下写法是考虑到插入排序的特性，优先把高的放到一个位置，然后将低的放到同样的位置，高的向后移动一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    贪心+排序: 首先将身高按照降序排序，身高高的优先放到前面</span></span><br><span class="line"><span class="string">    个子矮的对于个子高的没有影响，因此个子矮的一般要放到前面</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people)</span>:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            output.insert(p[<span class="number">1</span>], p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621. 任务调度器</a></p><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</span><br></pre></td></tr></table></figure><p>思路：贪心+分桶</p><p>对于不同的任务，根据任务重复数对其进行分桶，然后计算按照任务次数多少，依次往桶里面填充。</p><p>总排队时间=（桶个数 - 1）* 桶的容量 + 最后一桶的任务数</p><p><img src="https://pic.leetcode-cn.com/893c01db5923889a865d7a4fe71de22b9519fc5a673473196ab58f26c1073ed2-image.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    分桶的思想：</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks, n)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        freq = collections.Counter(tasks)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最多的执行次数</span></span><br><span class="line">        max_exec = max(freq.values())</span><br><span class="line">        <span class="comment"># 具有最多执行次数的任务数量</span></span><br><span class="line">        max_count = sum(<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> freq.values() <span class="keyword">if</span> v == max_exec)</span><br><span class="line">        <span class="comment"># 总排队时间 = (桶个数 - 1) * (n + 1) + 最后一桶的任务数</span></span><br><span class="line">        <span class="keyword">return</span> max((max_exec - <span class="number">1</span>) * (n + <span class="number">1</span>) + max_count, len(tasks))</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>算法解释：</p><p>动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h3 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h3><p>5.最长回文子串</p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>思路：动态规划，关键思想，以当前位数s[i]为回文字符串尾部，每次只考虑max_len+1或者max_len+2的长度。也就是说，每一次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="comment"># 如果字符串长度为或者s本身是字符串，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span> <span class="keyword">or</span> s == s[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        max_len, start = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历每一个字符，假设为回文字符的尾字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            <span class="comment"># [i-max_len, i]，一共max_len+1个元素</span></span><br><span class="line">            even = s[i - max_len:i + <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># [i-max_len-1, i] 一共max_len+2个元素</span></span><br><span class="line">            odd = s[i - max_len - <span class="number">1</span>:i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> i - max_len - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> odd == odd[::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_len - <span class="number">1</span></span><br><span class="line">                max_len += <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> i - max_len &gt;= <span class="number">0</span> <span class="keyword">and</span> even == even[::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_len</span><br><span class="line">                max_len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start + max_len]</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>根据分析其实可以得出p的第一个字符只能为’.’或者string字符，不能是’*’</p><p>正则匹配的遍历条件是两者同时匹配到终点。</p><p>​    如果两者同时到达结尾，则能匹配上，如果其中一个p已经遍历结束，但是s还没有遍历完则匹配不上</p><p>​    由于模式里面第一个不可能是’*’。判断的时候我们只需要从左往右判断就行。</p><p>​    如果p的第二字字符是*，则需要判断第一个字符是否能匹配上，如果能匹配上。则，模式有三种：</p><ul><li><p>字符串向下移动，但是p不变。</p></li><li><p>p移动两位，即*的中间匹配位数为0，s不动</p></li><li><p>p不变，s向后移动。</p><p>如果p的第二个字符不是*，判断就很简单，只需要一个一个往后面移动。</p></li></ul><p>状态方程有：</p><p>1、当p的第j个时小写字母时，s中必须为相同的小写字母有</p><script type="math/tex; mode=display">f[i][j]=\begin{cases}f[i-1][j-1]& \text{p[j]=s[i]}\\false& \text{p[j]!=s[i]}\end{cases}</script><p>2、当第p个为’.’的时候，可以匹配s中任意小写字母，此时</p><script type="math/tex; mode=display">f[i][j]=f[i-1][j-1]</script><p>3、当p的第j个字符为’*’，可以匹配前面一个字符0次或者无数次。</p><p>当s[i] = p[j-1]的时候，有</p><script type="math/tex; mode=display">f[i][j]=\begin{cases}f[i][j-1]& \text{s[i]=p[j-1], 匹配一个}\\f[i][j-2]& \text{s[i]!=p[j-1]，不匹配}\end{cases}</script><script type="math/tex; mode=display">f[i][j]=\begin{cases}f[i-1][j] or f[i][j-2]& \text{p[j]='*', s[i]=p[j-1]}\\f[i][j-2]& \text{s[i]!=p[j-1]}\end{cases}</script><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/basis_52_1.png" alt></p><p>直接对照代码更容易理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matches</span><span class="params">(i: int, j: int)</span> -&gt; bool:</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        f = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果p][j]='*'</span></span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="comment"># 匹配0个的情况</span></span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">2</span>]</span><br><span class="line">                    <span class="comment"># 匹配一个的情况</span></span><br><span class="line">                    <span class="keyword">if</span> matches(i, j - <span class="number">1</span>):</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> matches(i, j):</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[m][n]</span><br></pre></td></tr></table></figure><h3 id="子序列系列"><a href="#子序列系列" class="headerlink" title="子序列系列"></a>子序列系列</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>思路：动态规划，关键点在于当和小于0时，需要重新选择序列头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        sum_all = -float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="number">0</span>:</span><br><span class="line">                cur += nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = nums[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur &gt; sum_all:</span><br><span class="line">                sum_all = cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum_all</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p><strong>进阶：</strong>你可以设计并实现时间复杂度为 <code>O(n)</code> 的解决方案吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p>思路：</p><p>一：排序+双指针</p><p>思路二：哈希</p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：排序 + 双指针</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        length = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur &lt; length:</span><br><span class="line">            <span class="keyword">if</span> nums[end] + <span class="number">1</span> == nums[cur] <span class="keyword">or</span> nums[end] == nums[cur]:</span><br><span class="line">                end = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = cur</span><br><span class="line">                start = end</span><br><span class="line"></span><br><span class="line">            l = len(set(nums[start:end+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l &gt; max_len:</span><br><span class="line">                max_len = l</span><br><span class="line"></span><br><span class="line">            cur += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        longest_streak = <span class="number">0</span></span><br><span class="line">        num_set = set(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num = num</span><br><span class="line">                current_streak = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> current_num + <span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_streak += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                longest_streak = max(longest_streak, current_streak)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_streak</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>思路：定义$dp[i]$为前i个元素中，以i为数字结尾的最长上升序列的长度。因此我们可以从小到大计算dp的值。在计算$dp[i]$之前，已经算出了$dp[0, …, i-1]$的值，则状态转移方程为</p><script type="math/tex; mode=display">dp[i]=max(dp[j]) + 1</script><p>其中 $0\leq j &lt; i$并且$nums[j] &lt; nums[i]$。最后整个上身子序列的最大值为:</p><script type="math/tex; mode=display">LIS_{length}=max(dp[i])，其中0\leq i < n</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：比较简单，动态规划， O(n^2),从后往前遍历</span></span><br><span class="line"><span class="string">    思路二：</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        length = len(nums)</span><br><span class="line"></span><br><span class="line">        dis = [<span class="number">1</span>] * length</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dis[i] = max(dis[j]+<span class="number">1</span>, dis[i])</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dis[i] &gt; max_len:</span><br><span class="line">                max_len = dis[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 <em>子序列</em> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span> </span><br><span class="line">输出：<span class="number">3</span>  </span><br><span class="line">解释：最长公共子序列是 <span class="string">"ace"</span>，它的长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>思路：建立一个二维数组$dp[m][n]$。</p><p>边界条件</p><p>1、两个都是空串， $dp[0][0]=0$</p><p>2、其中一个是空串，$dp[i][0]=0$ or $dp[[0][j]=0$。</p><p>如果不是空串，有两种情况</p><p>一种是$text[i]!=text[j]$，此时状态转移方程为$dp[i][j]=max(dp[i-1][j], dp[i][j-1])$</p><p>当$text[i]=text[j]$时，状态方程为$dp[i][j]=dp[i-1][j-1]+1$。</p><p>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        m, n = len(text1), len(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h3 id="路径类问题"><a href="#路径类问题" class="headerlink" title="路径类问题"></a>路径类问题</h3><p>路径类的问题，通常有个很明显的特点，就是从左上往右下慢慢异动，通常考虑最短路径或者路径数。思路基本是一样的。需要注意初始化边界。</p><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p>思路：动态规划，这类路径类的问题，有个最大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line"></span><br><span class="line">        res = [(n * [<span class="number">0</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            res[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                res[i][j] = res[i][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p>思路：动态规划</p><script type="math/tex; mode=display">min\_dist[i][j] = min(min\_dist[i-1][j], min\_dist[i][j-1]) + dis[i][j]</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这种写法存在浅拷贝的坑</span></span><br><span class="line">        <span class="comment"># min_path = [[0] * n] * m</span></span><br><span class="line"></span><br><span class="line">        min_path = [([<span class="number">0</span>] * n) <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="comment"># 初始化第一行与第一列</span></span><br><span class="line">        init_dis = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            init_dis += grid[i][<span class="number">0</span>]</span><br><span class="line">            min_path[i][<span class="number">0</span>] = init_dis</span><br><span class="line"></span><br><span class="line">        init_dis = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            init_dis += grid[<span class="number">0</span>][i]</span><br><span class="line">            min_path[<span class="number">0</span>][i] += init_dis</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                min_path[i][j] = min(min_path[i<span class="number">-1</span>][j], min_path[i][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_path[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="斐波那契类"><a href="#斐波那契类" class="headerlink" title="斐波那契类"></a>斐波那契类</h3><script type="math/tex; mode=display">f[0] = f[1]=1</script><script type="math/tex; mode=display">f[n] = f[n-1] + f[n-2], n\geq2</script><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><p>进阶：剑指offer超级爬楼梯</p><script type="math/tex; mode=display">f[0]=1\\f[1]=1\\f[2]=2\\f(n) = \sum_{i=1}^n f(i)</script><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 <span class="number">1</span> 步，从下标 <span class="number">0</span> 到达下标 <span class="number">1</span>, 然后再从下标 <span class="number">1</span> 跳 <span class="number">3</span> 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p>思路：动态规划，关键点，计算每个位置能够跳到的最远位置</p><script type="math/tex; mode=display">right = max(right, i+nums[i])</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    关键点，index+ value</span></span><br><span class="line"><span class="string">    计算每个位置能够到达的最远位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        count = len(nums)</span><br><span class="line">        flag = [<span class="literal">False</span>] * count</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        right_most = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; count:</span><br><span class="line">            <span class="keyword">if</span> i &lt;= right_most:</span><br><span class="line">                right_most = max(right_most, i+nums[i])</span><br><span class="line">                <span class="keyword">if</span> right_most &gt;= count - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></p><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p>思路：动态规划，和前面哈希的题目优点类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    动态规划</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        square_nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>)]</span><br><span class="line">        dp = [sys.maxsize] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 从前到后遍历完全平方数</span></span><br><span class="line">            <span class="keyword">for</span> square <span class="keyword">in</span> square_nums:</span><br><span class="line">                <span class="comment"># 完全平方数大于目标和，直接跳过</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; square:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 更新当前所需要完全平方数最小值。</span></span><br><span class="line">                dp[i] = min(dp[i], dp[i-square]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins, amount)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [sys.maxsize] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, amount+<span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j-i]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != sys.maxsize <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><ol><li>编辑距离](<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a>)</li></ol><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符 </li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p>思路：动态规划，关键点，空字符串是能够匹配的。</p><p>1、定义二维数组，dp，$dp[i][j]$表示word1中前i个字符换到word2中前j个字符需要的最短路径。</p><p>2、初始化，当word1 或者word2位空串的时候，需要插入对应的元素数。</p><p>3、状态转移方程</p><p>其实对于编辑距离问题，可以将其中一个字符固定，只对另一个进行操作。因为在word1中增加一个字符和在word2中删除一个字符其实是等价的。</p><ul><li>增，相当于word1不动，word2删除一个。 $dp[i][j]=dp[i][j-1] + 1$</li><li>删，word1删除一个，word2不动。$dp[i][j] =dp[i-1][j]+1$</li><li>改，word1和word2都不动。$dp[i][j]=dp[i-1][j-1]+1$</li></ul><p>所以最短编辑距离为</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1</script><p><img src="https://pic.leetcode-cn.com/7bf05e42bb31e224d06701cf72a96cfa4ac0c4cd5fdc927ec0b6fa5198449b66-%E5%9B%BE%E7%89%87.png" alt="图片.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span>:</span></span><br><span class="line">        m = len(word1)</span><br><span class="line">        n = len(word2)</span><br><span class="line"></span><br><span class="line">        distance = [([<span class="number">0</span>] * (n+<span class="number">1</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            distance[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            distance[<span class="number">0</span>][i] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    distance[i][j] = distance[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    distance[i][j] = min(distance[i<span class="number">-1</span>][j], distance[i][j<span class="number">-1</span>], distance[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> distance[m][n]</span><br></pre></td></tr></table></figure><h3 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>思路：只买一次，然后卖出。所以选择最低点min_price买入，然后在低点之后的搞点卖出就行了。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; min_price:</span><br><span class="line">                min_price = prices[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> prices[i] - min_price &gt; max_profit:</span><br><span class="line">                max_profit = prices[i] - min_price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 </p><p>示例 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p>思路一：贪心，找到上升的趋势，计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            max_profit += max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><p>难度中等698收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>思路：由于存在冷冻期，所以有三种状态</p><ul><li>$f[i][0]$表示当前拥有一支股票，对应的最大累计收益</li><li>$f[i][1]$表示当前不持有任何股票且处在冷冻期对应的最大收益</li><li>$f[i][2]$表示当前不持有任何股票且没有处在冷冻期对应的最大收益</li></ul><p>注意f表示是当天收盘结果。</p><p>对于一个当天结束持有股票，其持有的股票可以是前一天持有的没有卖出，也可以是当天买入的(前一天为非冷冻期)，因此最大收益$f[i][0]$为</p><script type="math/tex; mode=display">f[i][0]=max(f[i-1][0], f[i-1][2] - prices[i])</script><p>前一天有股票，今天卖出了，因此最大收益$f[i][1]$为</p><script type="math/tex; mode=display">f[i][1] = f[i][0] + prices[i]</script><p>i-1天卖出股票或者i-2天股票为空，都能使当天不持有任何股票，其最大收益$f[i][2]$为：</p><script type="math/tex; mode=display">f[i][2] = max(f[i-1][1], f[i-2][2])</script><p>最后求三种状态的最大值，由于空仓收益更高，其实看两种状态就行了。</p><script type="math/tex; mode=display">max\_profit=max(f[n-1][1], f[n-1][2])</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    动态规划：一共三种状态</span></span><br><span class="line"><span class="string">    1、当前持有一直股票 ， 有股票且没有卖</span></span><br><span class="line"><span class="string">    2、当前不持有股票且处在冷冻期</span></span><br><span class="line"><span class="string">    3、当前不持有股票且不处在冷冻期，即没有股票或者有股票卖了</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(prices)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 关键点i表示今天结束的状态，也就是买入卖出操作执行结束</span></span><br><span class="line">            <span class="comment"># 前一天有股票, 今天不属于冷冻期</span></span><br><span class="line">            <span class="comment"># 当前最大收益的状态时卖出或者保持不变</span></span><br><span class="line">            f[i][<span class="number">0</span>] = max(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">2</span>] - prices[i])</span><br><span class="line">            <span class="comment"># 当前一天不持有股票且处在冷冻期</span></span><br><span class="line">            f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]</span><br><span class="line">            <span class="comment"># 注意冷冻期是指</span></span><br><span class="line">            <span class="comment"># 当前不持有股票且不再冷冻期，有以下几种情况</span></span><br><span class="line">            <span class="comment"># 前一天有股票，且没有卖</span></span><br><span class="line">            <span class="comment"># 股票已经卖完了</span></span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i<span class="number">-1</span>][<span class="number">1</span>], f[i<span class="number">-1</span>][<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(f[n<span class="number">-1</span>][<span class="number">1</span>], f[n<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>相似题目：</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><h3 id="小偷问题"><a href="#小偷问题" class="headerlink" title="小偷问题"></a>小偷问题</h3><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""和309一个类型的题目</span></span><br><span class="line"><span class="string">    判断每个状态偷还是不偷</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums)</span><br><span class="line">        f = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 不偷</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>]  <span class="comment"># 偷</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = max(f[i<span class="number">-1</span>][<span class="number">1</span>], f[i<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(f[n<span class="number">-1</span>][<span class="number">0</span>], f[n<span class="number">-1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：dfs+深度优先计算</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 投、不偷</span></span><br><span class="line"></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            rob_value = left[<span class="number">1</span>] + right[<span class="number">1</span>] + root.val</span><br><span class="line">            skip_value = max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + max(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> [rob_value, skip_value]</span><br><span class="line"></span><br><span class="line">        value = dfs(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(value[<span class="number">0</span>], value[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="矩阵问题"><a href="#矩阵问题" class="headerlink" title="矩阵问题"></a>矩阵问题</h3><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></p><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>思路：和剑指offer二维数组查找差不多。选择右上或者左下遍历。以右上角为例，对于矩阵中的点$matrix[i][j]$，其左上角的点的值都小于$matrix[i][j]$，选择左下角和右上角的目的是可以沿着边走，找到最后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    剑指offer原题：二维数组查找</span></span><br><span class="line"><span class="string">    选择右上角往左下角移动，右上角和左下角的特点为</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        matrix = np.array(matrix)</span><br><span class="line">        m = matrix.shape[<span class="number">0</span>]</span><br><span class="line">        n = matrix.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        i, j = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221. 最大正方形</a></p><p>难度中等701收藏分享切换为英文接收动态反馈</p><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>思路：构建状态矩阵，$dp[i][j]$表示以$(i,j)$为右下角且只包含1的正方形边长最大值。</p><p>对于每个位置$(i,j)$，如果该位置的值为0，则$dp[i][j]=0$，因为当前位置不可能出现在1组成的正方形中</p><p>如果当前位置是1，状态方程为</p><script type="math/tex; mode=display">dp[i][j]=min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</script><p><img src="https://assets.leetcode-cn.com/solution-static/221/221_fig1.png" alt="fig1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        row, col = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * col <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = min(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + <span class="number">1</span></span><br><span class="line">                    max_len = max(dp[i][j], max_len)</span><br><span class="line"></span><br><span class="line">        max_square = max_len * max_len</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_square</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></p><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><p>思路：</p><p>1、创建一个dp，初始化dp[0] = True，表示串空且合法</p><p>2、对于字符串$s[0…i-1]$，我们只需要判断前面的单词和最后一个单词是否合法，假设分割点为$j$，因此只需要判断$s[0:j]$和$s[j+1:i-1]$是否合法就行了，因此状态转移方程为</p><script type="math/tex; mode=display">dp[i]=dp[j] \quad \& \quad s[j:i]\quad in \quad word</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict)</span>:</span></span><br><span class="line">        word_set = set(wordDict)</span><br><span class="line">        length = len(s)</span><br><span class="line">        flag = [<span class="literal">False</span>] * (length+<span class="number">1</span>)</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 空串为合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> s[j: i] <span class="keyword">in</span> word_set <span class="keyword">and</span> flag[j]:</span><br><span class="line">                    flag[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag[length]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    两个数组，最大值和最小值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        max_res = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        min_res = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            max_res[i] = max(max_res[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>], min_res[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line">            min_res[i] = min(max_res[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>], min_res[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>], nums[i<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(max_res[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></p><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><p>思路：对于这个问题，如果数组长度小于2，无法分成两个数组，如果数组和sum为奇数，那么一定无法分成两个，如果最大元素max_num &gt; sum//2，也无法分成两个相等的数组。</p><p>创建二维数组dp，包含n行，target+1列，其中$dp[i][j]$表示从数组$[0, i]$下标范围内选择若干个正整数，是否存在一种方案使得被选的正整数等于j。初始化时$dp$元素全部为false。</p><p>边界条件</p><ul><li>$dp[i][0]=true$，不选择任何正整数或者选择的正整数等于0</li><li>$dp[0][nums[i]]=true$，当只有一个正整数可以选择时。</li></ul><p>在确定$dp[i][j]$的时候，需要确认下面两种情况。</p><p>1、$j\geq nums[i]$时，对于当前的数字$nums[i]$，有两种情况，可以取，可以不取，两种情况只要有一种为$true$，就有$dp[i][j]=true$。</p><ul><li>不选$nums[i]$，$dp[i][j]=dp[i-1][j]$</li><li>选择$nums[i]$, $dp[i][j]=dp[i-1][j-nums[i]]$</li></ul><p>2、对于$j &lt; nums[i]$，$dp[i][j]=dp[i-1][j]$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        maxNum = max(nums)</span><br><span class="line">        <span class="keyword">if</span> total &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> maxNum &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 如果不选择任何整数，则被选择的正整数等于0</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            num = nums[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= num:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] | dp[i - <span class="number">1</span>][j - num]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][target]</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p><p>一般采用dfs</p><h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = <span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>,<span class="string">"ae"</span>,<span class="string">"af"</span>,<span class="string">"bd"</span>,<span class="string">"be"</span>,<span class="string">"bf"</span>,<span class="string">"cd"</span>,<span class="string">"ce"</span>,<span class="string">"cf"</span>]</span><br></pre></td></tr></table></figure><p>思路：回溯，dfs</p><p>关键在于终止条件，以及如何继续想下遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    常规题，采用dfs</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span>:</span></span><br><span class="line"></span><br><span class="line">        num_dict = &#123;<span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">                    <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">                    <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">                    <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">                    <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">                    <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">                    <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">                    <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        n = len(digits)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        str_list = [num_dict[i] <span class="keyword">for</span> i <span class="keyword">in</span> digits]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(str_list, s, cur)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> cur == n:</span><br><span class="line">                res.append(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> str_list[cur]:</span><br><span class="line">                    s += c</span><br><span class="line">                    dfs(str_list, s, cur+<span class="number">1</span>)</span><br><span class="line">                    s = s[:cur]</span><br><span class="line"></span><br><span class="line">        dfs(str_list, <span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(str, left, right)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">                res.append(str)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(str+<span class="string">'('</span>, left<span class="number">-1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(str+<span class="string">')'</span>, left, right<span class="number">-1</span>)</span><br><span class="line">        dfs(<span class="string">""</span>, n, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>思路：dfs，不断遍历不同的情况。</p><p>关键点：</p><ul><li>终止条件</li><li>遍历是是否能够重复选取</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res_all = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candiates, res, target)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum(res) == target:</span><br><span class="line">            self.res_all.append(res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> sum(res) &gt; target:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candiates)):</span><br><span class="line">            self.dfs(candiates[i:], res + [candiates[i]], target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.dfs(candidates,[], target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res_all</span><br></pre></td></tr></table></figure><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        m = len(nums)</span><br><span class="line">        visited = [<span class="literal">False</span>] * (m+<span class="number">1</span>)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(linklist, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                res.append(linklist)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                    visited[i] = <span class="literal">True</span></span><br><span class="line">                    dfs(linklist + [nums[i<span class="number">-1</span>]], n - <span class="number">1</span>)</span><br><span class="line">                    visited[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dfs([], m)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>思路：回溯</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    第一反应是回溯</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        count = len(nums)</span><br><span class="line">        res_all = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(data, target, res)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res_all.append(res.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">                res.append(data[i])</span><br><span class="line">                dfs(data[i+<span class="number">1</span>:], target<span class="number">-1</span>, res)</span><br><span class="line">                res.pop()</span><br><span class="line"></span><br><span class="line">        res_all.append([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count+<span class="number">1</span>):</span><br><span class="line">            dfs(nums, i, [])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_all</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路：dfs+剪枝，Java版通过，python版超时</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums, start, target, S)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> count, n</span><br><span class="line">            <span class="keyword">if</span> start == n:</span><br><span class="line">                <span class="keyword">if</span> target == S:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> start &lt; len(nums):</span><br><span class="line">                    dfs(nums, start+<span class="number">1</span>, target+nums[start], S)</span><br><span class="line">                    dfs(nums, start+<span class="number">1</span>, target-nums[start], S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> S &gt; sum(nums) <span class="keyword">or</span> S &lt; -sum(nums):</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dfs(nums, <span class="number">0</span>, <span class="number">0</span>, S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>11.盛水最多的容器</p><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，a``n</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br><span class="line">https://leetcode-cn.com/problems/container-with-most-water/</span><br></pre></td></tr></table></figure><p>思路：这是一道典型的双指针题目，题目意思是利用从数组中选择两个位置，当做挡板，看中间能够容纳多少水。所以思路很简单，建立一个双指针，从左右往中间移动，每次移动左右指针中值较小的那个，每次更新的时候判断面积是否大于最大面积，如果大于，就更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        n = len(height)</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            area = min(height[l], height[r]) * (r-l)</span><br><span class="line">            max_area = max(area, max_area)</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt;= height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p>思路：排序+双指针变体</p><p>设置三个指针，首先将数组从小到大进行排序，然后从前往后一次选择一个数作为三元组的第一个数，然后设置两个左右指针，判断节点是否小于0，如果小于0，左指针往右移动，如果大于0，右指针往左移动。每一次保存上一次满足条件的结果，然后下一次满足条件时与上一次结果对比，如果不一样，保存结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br><span class="line">        count = len(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 保留上一次结果，做去重使用</span></span><br><span class="line">        first = <span class="number">-1</span> </span><br><span class="line">        second = <span class="number">-1</span> </span><br><span class="line">        third = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count<span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span> <span class="comment"># 左指针</span></span><br><span class="line">            k = count - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                target = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> target &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 判断是否已经存在改结果</span></span><br><span class="line">                    <span class="keyword">if</span> third == <span class="number">-1</span> <span class="keyword">or</span> (nums[j] &gt; nums[second] <span class="keyword">or</span> nums[k] &lt; nums[third] </span><br><span class="line">                                       <span class="keyword">or</span> nums[i] &gt; nums[first]):</span><br><span class="line">                        <span class="comment"># 第一次满足条件</span></span><br><span class="line">                        result.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                        first = i</span><br><span class="line">                        second = j</span><br><span class="line">                        third = k</span><br><span class="line"></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p>思路：双指针，一个先向后移动n步，然后两个指针一起移动。当前面一个移动到第n个时，后面的指针则指向第k个结点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="comment"># 获取链表长度</span></span><br><span class="line">    p = head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        p = p.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        m = get_length(head)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回头结点</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        k = m - n - <span class="number">1</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            p = p.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除第n个结点</span></span><br><span class="line">        q = p.next</span><br><span class="line">        <span class="keyword">if</span> q <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p.next = q.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></p><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p>思路：双指针</p><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p><p>从有往左遍历。找到第一个nums[i] &lt; nums[i+1]的数，此时可以将数组分成两个部分，nums[0, i], nums[i+1, n-1]。</p><p>可以知道此时nums[i+1, n-1]此时是降序。交换nums[i]和nums[j]，然后将nums[i+1,n-1]进行升序排序就能得到结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        i = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; i:</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                    nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></p><p>难度中等802收藏分享切换为英文接收动态反馈</p><p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>思路：双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：sort函数</span></span><br><span class="line"><span class="string">    思路二：单指针，第一次遍历，放0的位置，第二次遍历，放一的位置</span></span><br><span class="line"><span class="string">    思路二：双指针，如果是0异动到前面，2移动到后面</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        p, q = <span class="number">0</span>, length - <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= q:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[p], nums[i] = nums[i], nums[p]</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">                nums[q], nums[i] = nums[i], nums[q]</span><br><span class="line">                q -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></p><p>难度中等493收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,6,4,8,10,9,15]</span><br><span class="line">输出：5</span><br><span class="line">解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><p>思路：排序+双指针</p><p>首先使用快排对结果进行排序，然后设置头指针，和尾指针</p><ul><li>头指针，找到第一个和target位置不一样的元素。</li><li>尾指针，找到最后一个和target位置不一样的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        target = sorted(nums)</span><br><span class="line"></span><br><span class="line">        start = len(nums)</span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[i] != target[i]:</span><br><span class="line">                start = min(i, start)</span><br><span class="line">                end = max(i, end)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                max_len = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_len = end - start + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><h3 id="移动数组"><a href="#移动数组" class="headerlink" title="移动数组"></a>移动数组</h3><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：将</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        count = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; count:</span><br><span class="line">            nums[index] = <span class="number">0</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>思路：双指针，以每个字符作为中心节点，从左右往两边扩展，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""从每一个中间往两边遍历"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>*n):</span><br><span class="line">            l = int(i/<span class="number">2</span>)</span><br><span class="line">            r = l + i %<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>主要可以用来判断链表是否存在环，设置两个指针，快指针fast和慢指针slow。fast指针每次移动两步，slow指针每次移动一步。如果存在换，那么他们一定会相遇。</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>思路：设置快慢指针，相交则说明有环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 基础题，以前做过，快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        low = head</span><br><span class="line">        high = head.next</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low <span class="keyword">and</span> high:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> low == high:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            low = low.next</span><br><span class="line">            high = high.next</span><br><span class="line">            <span class="keyword">if</span> high:</span><br><span class="line">                high = high.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>142.<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul><li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        point_slow = head</span><br><span class="line">        point_fast = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> point_slow <span class="keyword">and</span> point_fast:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> point_slow == point_fast <span class="keyword">and</span> count != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            point_slow = point_slow.next</span><br><span class="line"></span><br><span class="line">            point_fast = point_fast.next</span><br><span class="line">            <span class="keyword">if</span> point_fast:</span><br><span class="line">                point_fast = point_fast.next</span><br><span class="line"></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果不存在环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> point_slow <span class="keyword">or</span> <span class="keyword">not</span> point_fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        point_fast = head</span><br><span class="line">        <span class="keyword">while</span> point_fast != point_slow:</span><br><span class="line">            point_fast = point_fast.next</span><br><span class="line">            point_slow = point_slow.next</span><br><span class="line">        <span class="keyword">return</span> point_fast</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>​    滑动窗口问题算是双指针的一种变形</p><ol><li>无重复字符的最长子串</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</span><br><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>思路：设置首尾指针，都从0开始，然后尾指针end_index每向后移动一位，判断当前的字符是否在滑窗里面，如果不在</p><p>将尾指针字符加入滑窗，如果在，头指针向后移动一位，加入尾指针，然后更新滑窗的长度。如果当前长度大于最大长</p><p>，则更新最长子串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        start_index = <span class="number">0</span></span><br><span class="line">        end_index = start_index</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start_index &lt; n <span class="keyword">and</span> end_index &lt; n:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> end_index == <span class="number">0</span>:</span><br><span class="line">                max_len = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[end_index] <span class="keyword">not</span> <span class="keyword">in</span> s[start_index: end_index]:</span><br><span class="line">                end_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end_index-start_index &gt; max_len:</span><br><span class="line">                max_len = end_index - start_index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p>239.滑动窗口最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line"></span><br><span class="line">返回滑动窗口中的最大值。</span><br><span class="line"></span><br><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line"></span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p>思路：</p><p>一、暴力求解，直接遍历每个元素组成的不同滑动窗口。超时</p><p>二、双端队列+滑动窗口欧</p><p>​    利用双端队列实现单调队列，每次里面保存最大的结果的索引，这样做的好处是即能取到对应的值，也可以通过index来判断当前元素距离队列头部保存index的距离，从而得到当前滑窗滑窗的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：暴力求解，直接找出方框里面最大的值，基本超时</span></span><br><span class="line"><span class="string">    思路二：双端队列，其实就是利用双端队列实现最大堆，每次在结果里面保存可能最大的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        q = deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> nums[i] &lt;= nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                q.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                    q.pop()</span><br><span class="line">                q.append(i)</span><br><span class="line"></span><br><span class="line">        res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">if</span> i - q[<span class="number">0</span>] == k:</span><br><span class="line">                q.popleft()</span><br><span class="line"></span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p><p>难度困难987收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p>思路：滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        hash_table = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            hash_table[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        min_len = float(<span class="string">'inf'</span>)  <span class="comment"># 包含子串的最小长度</span></span><br><span class="line">        count = <span class="number">0</span>  <span class="comment"># 用于记录当前滑动窗口包含目标字符的个数，当count = len(t)，t为子串</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(s):</span><br><span class="line">            <span class="comment"># 当前元素在子串中，包含子串字符长度+1</span></span><br><span class="line">            <span class="comment"># 同时对应子串个数应该-1，目的是为了防止同一个字符重复使用</span></span><br><span class="line">            <span class="keyword">if</span> hash_table[s[end]] &gt; <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            hash_table[s[end]] -= <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> count == len(t):</span><br><span class="line">                <span class="keyword">if</span> min_len &gt; end - start:</span><br><span class="line">                    min_len = end - start</span><br><span class="line">                    res = s[start: end]</span><br><span class="line">                <span class="comment"># 如果头部不在子串中，则包含子串长度-1</span></span><br><span class="line">                <span class="keyword">if</span> hash_table[s[start]] == <span class="number">0</span>:</span><br><span class="line">                    count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                hash_table[s[start]] += <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：暴力求解，直接找出方框里面最大的值，基本超时</span></span><br><span class="line"><span class="string">    思路二：双端队列，其实就是利用双端队列实现最大堆，每次在结果里面保存可能最大的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        q = deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 保存前k个最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> nums[i] &lt;= nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                q.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                    q.pop()</span><br><span class="line">                q.append(i)</span><br><span class="line"><span class="comment"># 弹出第一个最大值</span></span><br><span class="line">        res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, n):</span><br><span class="line">            <span class="comment"># 如果当前元素大于队列顶部元素，弹出，然后加入新的新的元素</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt; nums[q[<span class="number">-1</span>]]:</span><br><span class="line">                q.pop() </span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="comment"># 如果队列已经满了，弹出</span></span><br><span class="line">            <span class="keyword">if</span> i - q[<span class="number">0</span>] == k: </span><br><span class="line">                q.popleft()</span><br><span class="line"><span class="comment"># 每次遍历时加入最大结果</span></span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>类似题目：</p><ol><li><p>无重复字符的最长子串</p></li><li><p>串联所有单词的子串</p></li><li><p>最小覆盖子串</p></li><li><p>至多包含两个不同字符的最长子串</p></li><li><p>长度最小的子数组</p></li><li><p>滑动窗口最大值</p></li><li><p>字符串的排列</p></li><li><p>最小区间</p></li><li><p>最小窗口子序列</p></li></ol><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="括号问题"><a href="#括号问题" class="headerlink" title="括号问题"></a>括号问题</h3><p>借助栈的特性，来判断括号是否合法</p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p>思路：借助辅助栈，如果当前字符是左括号，入栈。如果当前字符是右括号，出栈。如果栈空，则表明都是合法的，如果非空，表示不合法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = list()</span><br><span class="line">        lens = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lens):</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                stack.append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">')'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'('</span>) <span class="keyword">or</span> (s[i] == <span class="string">'&#125;'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'&#123;'</span>) <span class="keyword">or</span> \</span><br><span class="line">                        (s[i] == <span class="string">']'</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] == <span class="string">'['</span>):</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(s[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></p><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><p>思路：借助栈，由于字符串只包含两种字符，因此对于左括号进展，对于右括号，出栈时，当前元素和栈顶元素的差则为有效括号的长度，不断更新有效括号，就能得到最后结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> s[i] == <span class="string">'('</span> <span class="keyword">or</span> s[stack[<span class="number">-1</span>]] == <span class="string">')'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                length = i - (stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line">            </span><br><span class="line">            max_len = max(max_len, length)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p>思路：排序+栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    借助栈</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line"></span><br><span class="line">        intervals = sorted(intervals, key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &gt;= i[<span class="number">0</span>]:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                union = [min(i[<span class="number">0</span>], cur[<span class="number">0</span>]), max(i[<span class="number">1</span>], cur[<span class="number">1</span>])]</span><br><span class="line">                stack.append(union)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></p><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3[a]2[bc]"</span></span><br><span class="line">输出：<span class="string">"aaabcbc"</span></span><br></pre></td></tr></table></figure><p>思路：采用两个栈数字占和字符栈，算法计算步骤</p><ul><li>将数字和字母分别保存</li><li>遇到‘【’，入栈</li><li>遇到‘】’，出栈，计算当前结果</li><li>然后将结果拼接到字符串后面。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    采用栈： 输入栈和输出栈</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        num_stack = []</span><br><span class="line">        str_stack = []</span><br><span class="line">        multi = <span class="number">0</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'0'</span> &lt;= c &lt;= <span class="string">'9'</span>:</span><br><span class="line">                multi = multi * <span class="number">10</span> + int(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">'a'</span> &lt;= c &lt;= <span class="string">'z'</span>:</span><br><span class="line">                res += c</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'['</span>:</span><br><span class="line">                num_stack.append(multi)</span><br><span class="line">                str_stack.append(res)</span><br><span class="line">                res = <span class="string">""</span></span><br><span class="line">                multi = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_multi = num_stack.pop()</span><br><span class="line">                current_char = str_stack.pop()</span><br><span class="line">                res = current_char + current_multi * res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><ol><li>最长有效括号](<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses/</a>)</li></ol><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>判断入栈条件</p><ul><li>如果栈空，入栈</li><li>当前字符为’(‘，入栈</li><li>当前栈为’)’</li></ul><p>上述三种情况无法进行匹配出栈，所以直接消除</p><p>出栈：</p><p>通过出栈时’)’的下标与队列中下标进行对比。</p><p>其实有两种情况</p><ul><li>当栈为空的时候，表示前面的括号都是合法的，所以合法长度为i+1</li><li>当栈不为空的时候，表示前面存在不合法括号，所以直接用$i- index_{not\;legal}$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> s[i] == <span class="string">'('</span> <span class="keyword">or</span> s[stack[<span class="number">-1</span>]] == <span class="string">')'</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                length = i - (stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            max_len = max(max_len, length)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/trapping-rain-water</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>思路：单调栈</p><p>根据下面的图，我们知道接雨水的时候，其实是由两个边界决定的。因此我们构建一个单调递减的栈stack用于保存当前数组元素的边界。</p><p>遍历数组：</p><ul><li>当栈非空且当前元素大于栈顶元素，弹出栈顶元素left</li><li>计算当前元素到栈顶元素的距离$distance= current - stack[-1] -1$</li><li><p>找到界定高度$max_height = min(height[stack[-1]], height[current]) - height[left]$</p></li><li><p>计算结果$res=max_height * distance$</p></li></ul><p>其实上述过程简单来讲，就是每次弹出站时，按层计算结果。</p><p><img src="https://pic.leetcode-cn.com/37fccd915f959c2046ffc1ab2b0a1e4d921869337d8d5d4aa218886ab0bf7c8a-image.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路：最小栈</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        n = len(height)</span><br><span class="line">        stack = []</span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> current &lt; n:</span><br><span class="line">            <span class="comment"># 如果栈为空或者当前位置高度小于栈顶元素，入栈</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[current] &gt;= height[stack[<span class="number">-1</span>]]:</span><br><span class="line">                <span class="comment"># 弹出栈顶元素</span></span><br><span class="line">                left = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                distance = current - stack[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">                max_height = min(height[stack[<span class="number">-1</span>]], height[current]) - height[left]</span><br><span class="line">                res += max_height * distance</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></p><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><p>思路：单调栈，和接雨水思路差不多。构建一个单调递增栈。</p><ul><li>如果栈为空或者当前元素小于栈顶元素，入栈</li><li>如果栈不为空，并且当前元素大于栈顶元素，出栈，$cur_height=nums[stack.pop()]$</li><li>当前宽度$cur_width=i - stack[-1] - 1$</li><li>更新面积</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：单调栈，当前元素大于栈顶元素，出栈，出栈时计算面积</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span>:</span></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        n = len(heights)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> heights[i] &gt;= heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 采用单调栈保存最后的结果</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                    cur_height = heights[stack.pop()]</span><br><span class="line">                    <span class="comment"># 关键点，前面加上一个0，使得首位形式一样</span></span><br><span class="line">                    cur_width = i - stack[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">                    max_area = max(max_area, cur_height * cur_width)</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p>思路：和前面两题一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        n = len(heights)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> heights[i] &gt;= heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 采用单调栈保存最后的结果</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                    cur_height = heights[stack.pop()]</span><br><span class="line">                    <span class="comment"># 关键点，前面加上一个0，使得首位形式一样</span></span><br><span class="line">                    cur_width = i - stack[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">                    max_area = max(max_area, cur_height * cur_width)</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span> -&gt; int:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span>] * n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">"0"</span>:</span><br><span class="line">                    heights[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j] += <span class="number">1</span></span><br><span class="line">            ans = max(ans, self.largestRectangleArea(heights))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></p><p>难度中等669收藏分享切换为英文接收动态反馈</p><p>请根据每日 <code>气温</code> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><p>思路：保存一个递减单调栈，当当前栈元素大于栈顶元素，弹出栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：暴力，超时</span></span><br><span class="line"><span class="string">    思路二：借助栈</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T)</span>:</span></span><br><span class="line"></span><br><span class="line">        n = len(T)</span><br><span class="line">        stack = []</span><br><span class="line">        ans = []</span><br><span class="line">        ans_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack:</span><br><span class="line">                    j = stack[<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">if</span> T[i] &gt; T[j]:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                        ans_dict[j] = i - j</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            i = stack.pop()</span><br><span class="line">            ans_dict[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans.append(ans_dict[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="迷宫求解"><a href="#迷宫求解" class="headerlink" title="迷宫求解"></a>迷宫求解</h3><p>采用dfs或者栈，得到迷宫最优解。</p><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。 </p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line"></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        visited = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        q = deque()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">and</span> grid[i][j] == <span class="string">'1'</span> <span class="keyword">and</span> visited[i][j] == <span class="number">0</span>:</span><br><span class="line">                    q.append((i, j))</span><br><span class="line">                    visited[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> q:</span><br><span class="line">                    pos = q[<span class="number">0</span>]</span><br><span class="line">                    x, y = pos[<span class="number">0</span>], pos[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 向左移动</span></span><br><span class="line">                    <span class="keyword">if</span> x - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> grid[x<span class="number">-1</span>][y] == <span class="string">'1'</span> <span class="keyword">and</span> visited[x<span class="number">-1</span>][y] == <span class="number">0</span>:</span><br><span class="line">                            q.append((x<span class="number">-1</span>, y))</span><br><span class="line">                            visited[x<span class="number">-1</span>][y] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 向上移动</span></span><br><span class="line">                    <span class="keyword">if</span> y - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> grid[x][y<span class="number">-1</span>] == <span class="string">'1'</span> <span class="keyword">and</span> visited[x][y<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">                            q.append((x, y<span class="number">-1</span>))</span><br><span class="line">                            visited[x][y<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 向下移动</span></span><br><span class="line">                    <span class="keyword">if</span> x + <span class="number">1</span> &lt; m:</span><br><span class="line">                        <span class="keyword">if</span> grid[x+<span class="number">1</span>][y] == <span class="string">'1'</span> <span class="keyword">and</span> visited[x+<span class="number">1</span>][y] == <span class="number">0</span>:</span><br><span class="line">                            q.append((x+<span class="number">1</span>, y))</span><br><span class="line">                            visited[x+<span class="number">1</span>][y] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 向右移动</span></span><br><span class="line">                    <span class="keyword">if</span> y + <span class="number">1</span> &lt; n:</span><br><span class="line">                        <span class="keyword">if</span> grid[x][y+<span class="number">1</span>] == <span class="string">'1'</span> <span class="keyword">and</span> visited[x][y+<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                            q.append((x, y+<span class="number">1</span>))</span><br><span class="line">                            visited[x][y+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    q.popleft()</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>1、先序遍历</p><p>非递归版先序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                ret.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                t = stack.pop()</span><br><span class="line">                root = t.right</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为</strong> NULL 的节点将直接作为新二叉树的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    二叉树构建：</span></span><br><span class="line"><span class="string">    先序遍历，创建二叉树</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(self, t1,t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> t1 <span class="keyword">and</span> t2:</span><br><span class="line">            root.val = t1.val + t2.val</span><br><span class="line">            root.left = self.create_tree(t1.left, t2.left)</span><br><span class="line">            root.right = self.create_tree(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">elif</span> t1:</span><br><span class="line">            root.val = t1.val</span><br><span class="line">            root.left = self.create_tree(t1.left, <span class="literal">None</span>)</span><br><span class="line">            root.right = self.create_tree(t1.right, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">elif</span> t2:</span><br><span class="line">            root.val = t2.val</span><br><span class="line">            root.left = self.create_tree(<span class="literal">None</span>, t2.left)</span><br><span class="line">            root.right = self.create_tree(<span class="literal">None</span>, t2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.create_tree(t1, t2)</span><br></pre></td></tr></table></figure><p>2、中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(root_node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root_node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node_stack = []</span><br><span class="line">    node = root_node</span><br><span class="line">    <span class="keyword">while</span> node_stack <span class="keyword">or</span> node:</span><br><span class="line">        <span class="comment"># 从跟节点开始，把它的左子树找出来</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            node_stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="comment"># 上面 while 的结束就是 node 为空的时候，也就是前一个节点没有左子树的了</span></span><br><span class="line">        node = node_stack.pop()</span><br><span class="line">        <span class="keyword">print</span> node.val</span><br><span class="line">        <span class="comment"># 这个时候就开始查看右子树了</span></span><br><span class="line">        node= = node.right</span><br></pre></td></tr></table></figure><p>3、后续遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(root_node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root_node:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack1 = [root_node]</span><br><span class="line">    stack2 = []</span><br><span class="line">    <span class="keyword">while</span> stack1:</span><br><span class="line">        <span class="comment"># 在这个 while 循环里面找到后序遍历的逆序，存在在 stack2 中</span></span><br><span class="line">        node = stack1.pop()</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack1.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack1.append(node.right)</span><br><span class="line">        stack2.append(node)</span><br><span class="line">    <span class="keyword">while</span> stack2:</span><br><span class="line">        <span class="keyword">print</span> stack2.pop().val</span><br></pre></td></tr></table></figure><p>4、层序遍历</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></p><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        q = Queue()</span><br><span class="line">        q.put(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q.qsize() != <span class="number">0</span>:</span><br><span class="line">            level = []</span><br><span class="line">            size = q.qsize()</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                root = q.get()</span><br><span class="line">                level.append(root.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    q.put(root.left)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    q.put(root.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(level)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>5、二叉树的深度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = self.maxDepth(root.left) + <span class="number">1</span></span><br><span class="line">            right = self.maxDepth(root.right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> max(left, right)</span><br></pre></td></tr></table></figure><p>6、二叉树的宽度</p><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 </p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.max_depth = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumTreeDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left = self.sumTreeDepth(root.left)</span><br><span class="line">        right = self.sumTreeDepth(root.right)</span><br><span class="line">        current = max(left, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left + right &gt; self.max_depth:</span><br><span class="line">            self.max_depth = left + right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> current + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.sumTreeDepth(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_depth</span><br></pre></td></tr></table></figure><p>7、树的子结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_contain</span><span class="params">(A, B)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> is_contain(A.left, B.left) <span class="keyword">and</span> is_contain(A.right, B.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> bool(A <span class="keyword">and</span> B) <span class="keyword">and</span> (is_contain(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure><h3 id="二叉树公共先祖"><a href="#二叉树公共先祖" class="headerlink" title="二叉树公共先祖"></a>二叉树公共先祖</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p>思路：后续遍历二叉树将二叉树转换成链表，然后将叶子结点的右节点指向父节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求最近公共祖先，将右节点指向父节点，就能转换成链表求父节点的问题</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            node = node.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node, parent)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                inorder(node.left, node)</span><br><span class="line">                inorder(node.right, node)</span><br><span class="line">                node.right = parent</span><br><span class="line"></span><br><span class="line">        inorder(root, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        l1 = self.length(p)</span><br><span class="line">        l2 = self.length(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1 &gt; l2:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; l1-l2:</span><br><span class="line">                p = p.right</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; l2 - l1:</span><br><span class="line">                q = q.right</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p == q:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.right</span><br><span class="line">            q = q.right</span><br></pre></td></tr></table></figure><h3 id="二叉树序列化"><a href="#二叉树序列化" class="headerlink" title="二叉树序列化"></a>二叉树序列化</h3><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(<span class="string">'null'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                q.append(node.left)</span><br><span class="line">                q.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> len(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.root = TreeNode(data[<span class="number">0</span>])</span><br><span class="line">        queue = deque([self.root])</span><br><span class="line">        leng = len(data)</span><br><span class="line">        nums = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nums &lt; leng:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                node.left = TreeNode(data[nums]) <span class="keyword">if</span> data[nums] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> nums + <span class="number">1</span> &lt; leng:</span><br><span class="line">                    node.right = TreeNode(data[nums + <span class="number">1</span>]) <span class="keyword">if</span> data[nums + <span class="number">1</span>] <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                    nums += <span class="number">1</span></span><br><span class="line">                nums += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.root</span><br></pre></td></tr></table></figure><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></p><p>实现一个 Trie (前缀树)，包含 <code>insert</code>, <code>search</code>, 和 <code>startsWith</code> 这三个操作。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=None, children=[], end=False)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.children = children</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 创建一个根节点</span></span><br><span class="line">        self.node = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.node</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                node[w] = &#123;&#125;</span><br><span class="line">            node = node[w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[w]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.node</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[p]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h3><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p>解析：二叉搜索数的定义是，所有对于所有节点都有</p><ul><li>根节点大于左节点的</li><li>根节点小于右节点</li><li>先序遍历二叉搜索树，得到有序单调递增序列</li></ul><p>定义两个函数</p><ul><li>$G(n)$: 长度为n的序列能构成不同的二叉搜索树的个数</li><li>$F(i,n)$：以$i$为根、序列长度为n的不同二叉搜索树的个数</li></ul><p>以不同的i作为节点，可得到</p><script type="math/tex; mode=display">G(n)=\sum_{i=1}^nF(i,n)</script><p>边界条件：G(0)=G(1)=1</p><p>$F(i, n)$的定点固定，所以能够组成的二叉搜索树个数是由两个子节点决定的。即</p><p>[1, i]和[i+1, n]决定。而[i+1, n]等价于[1, n-i-1]</p><p>所以有$F(i, n)=G(i)G(n-i)$</p><p>所以最后的递推公式可以转换成</p><script type="math/tex; mode=display">G(n)=\sum_{i=1}^nG(i)G(n-i)</script><p>该公式可以归纳为卡塔兰数</p><script type="math/tex; mode=display">C(n+1)=\frac{2(2n+1)}{n+2}C(n)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line"></span><br><span class="line">    G = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">            G[i] += G[j<span class="number">-1</span>] * G[i-j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure><p>类似题目：</p><p>小兔棋盘</p><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></p><p>难度中等487收藏分享切换为英文接收动态反馈</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></p><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>思路：位运算，当两个数相同时，异或运算结果为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line"></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s ^= i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></p><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure><p>思路：转换成二进制后，是形如这样的数字：aa…aa10…00，从右向左数有任意多个0，直到遇见第一个1，字母a用来占位，代表1左边的任意数字。</p><p>x-1转换成二进制后，是形如这样的数字：aa…aa01…11，从右向左数，原来的任意多个0都变成1，原来的第一个1，变成0，字母a部分不变。</p><p>对x 和 x-1 进行 按位与 计算，会得到：aa…aa00…00，从右向左数，原来的第一个1变成了0，字母a部分不变。</p><p>所以 x &amp; (x-1)相当于消除了 x 从右向左数遇到的第一个1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""位运算"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num: int)</span>:</span>        </span><br><span class="line">        int count_bit(x):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            x &amp;= x<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        res = [count_bit(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, num+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>进阶版:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""位运算"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num: int)</span>:</span></span><br><span class="line">        res = [<span class="number">0</span>] * (num + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">            res[i] = res[i &amp; i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></p><p>难度简单379收藏分享切换为英文接收动态反馈</p><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>示例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: x = <span class="number">1</span>, y = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure><p>思路：先异或运算，再为运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    汉明距离，数字中有多少个1的变形</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        nums = x ^ y</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nums != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums &amp; <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            nums &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>4.寻找两个正序数组的中位数</p><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p>思路一：将两个序列进行合并，类似链表的操作方式，然后找到中位数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        len1 = len(nums1)</span><br><span class="line">        len2 = len(nums2)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len1 <span class="keyword">and</span> j &lt; len2:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                nums.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums.append(nums2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt; len1:</span><br><span class="line">            nums += nums1[i: len1]</span><br><span class="line">        <span class="keyword">elif</span> j &lt; len2:</span><br><span class="line">            nums += nums2[j: len2]</span><br><span class="line"></span><br><span class="line">        nums_size = len(nums)</span><br><span class="line">        middle_index = int(nums_size/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> nums_size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">elif</span> nums_size % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums[middle_index - <span class="number">1</span>] + nums[middle_index]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[middle_index]</span><br></pre></td></tr></table></figure><p>思路二：二分查找。暂时没看懂</p><p>二分查找解法：</p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></p><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的索引，否则返回 <code>-1</code> 。</p><p>思路：二分查找，比较简单，直接贴代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[len(nums) - <span class="number">1</span>]:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>148.<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> </p><p>思路：归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, next=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    方法一：冒泡排序 时间复杂度O(n2)</span></span><br><span class="line"><span class="string">    方法二：归并排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># 用快慢指针分成两部分</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="comment"># 找到左右部分, 把左部分最后置空</span></span><br><span class="line">        mid = slow.next</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 递归下去</span></span><br><span class="line">        left = self.sortList(head)</span><br><span class="line">        right = self.sortList(mid)</span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        l = left</span><br><span class="line">        r = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">                p.next = l</span><br><span class="line">                l = l.next</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = r</span><br><span class="line">                r = r.next</span><br><span class="line">                p = p.next</span><br><span class="line">        <span class="keyword">if</span> l:</span><br><span class="line">            p.next = l</span><br><span class="line">        <span class="keyword">if</span> r:</span><br><span class="line">            p.next = r</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h3><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p>  思路：</p><p>本质是有向图是否存在环，拓扑排序问题</p><p>  1、首先找到度入度为0的的点</p><p>  2、然后以改点为起点，找到指向的点，度-1</p><p>  3、然后找到指向的度为0的点，重复1/2操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites)</span>:</span></span><br><span class="line">        <span class="comment"># 采用邻接链表</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建边与入度</span></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        zero_indeg = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> indeg[i] == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        q = collections.deque(zero_indeg)</span><br><span class="line"></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> edges[node]:</span><br><span class="line">                indeg[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">                    q.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses</span><br></pre></td></tr></table></figure><h2 id="复杂数据结构"><a href="#复杂数据结构" class="headerlink" title="复杂数据结构"></a>复杂数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">399. 除法求值</a></p><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>示例 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"c"</span>]], values = [<span class="number">2.0</span>,<span class="number">3.0</span>], queries = [[<span class="string">"a"</span>,<span class="string">"c"</span>],[<span class="string">"b"</span>,<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"e"</span>],[<span class="string">"a"</span>,<span class="string">"a"</span>],[<span class="string">"x"</span>,<span class="string">"x"</span>]]</span><br><span class="line">输出：[<span class="number">6.00000</span>,<span class="number">0.50000</span>,<span class="number">-1.00000</span>,<span class="number">1.00000</span>,<span class="number">-1.00000</span>]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = <span class="number">2.0</span>, b / c = <span class="number">3.0</span></span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[<span class="number">6.0</span>, <span class="number">0.5</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span> ]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个并查集类</span></span><br><span class="line">    <span class="comment"># 特点：一边查询，一边修改节点指向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parent = &#123;&#125;</span><br><span class="line">        self.weight = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 路径压缩</span></span><br><span class="line">        <span class="comment"># 找到根节点</span></span><br><span class="line"></span><br><span class="line">        root = x</span><br><span class="line">        multi = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if x in self.parent:</span></span><br><span class="line">        <span class="comment"># 判断查询语句是否有效</span></span><br><span class="line">        <span class="keyword">while</span> self.parent[root] != root:</span><br><span class="line">            <span class="comment"># 计算路径上的权值</span></span><br><span class="line">            multi *= self.weight[root]</span><br><span class="line">            root = self.parent[root]</span><br><span class="line">        <span class="keyword">while</span> x != root:</span><br><span class="line">            last_parent = self.parent[x]</span><br><span class="line">            cur_weight = self.weight[x]</span><br><span class="line">            self.weight[x] = multi</span><br><span class="line">            multi /= cur_weight</span><br><span class="line">            self.parent[x] = root</span><br><span class="line">            x = last_parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, x, y, val)</span>:</span></span><br><span class="line">        <span class="comment"># 合并并查集</span></span><br><span class="line">        parent_x = self.find(x)</span><br><span class="line">        parent_y = self.find(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> parent_x == parent_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> parent_x != parent_y:</span><br><span class="line">            self.parent[parent_x] = parent_y</span><br><span class="line">            <span class="comment"># 合并之后更新权值</span></span><br><span class="line">            self.weight[parent_x] = self.weight[y] * val/self.weight[x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="comment"># 判断两点是否相连</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.parent <span class="keyword">and</span> y <span class="keyword">in</span> self.parent <span class="keyword">and</span> self.find(x) == self.find(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> self.parent:</span><br><span class="line">            self.parent[x] = x</span><br><span class="line">            self.weight[x] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路：带权重并查集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calcEquation</span><span class="params">(self, equations, values, queries)</span>:</span></span><br><span class="line">        uf = UnionFind()</span><br><span class="line">        <span class="comment"># 构建并查集</span></span><br><span class="line">        <span class="keyword">for</span> (a, b), val <span class="keyword">in</span> zip(equations, values):</span><br><span class="line">            uf.add(a)</span><br><span class="line">            uf.add(b)</span><br><span class="line">            uf.merge(a, b, val)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (a, b) <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(a, b):</span><br><span class="line">                res.append(uf.weight[a]/uf.weight[b])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">-1.0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><p>难度中等1219收藏分享切换为英文接收动态反馈</p><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a> 。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><p>思路：哈希表+双向链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key=<span class="number">0</span>, value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(collections.OrderedDict)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路一：采用OrderedDict，面试一般需要自己实现</span></span><br><span class="line"><span class="string">    思路二：哈希表+双向链表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.head = DLinkedNode()</span><br><span class="line">        self.tail = DLinkedNode()</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="keyword">if</span> self.size &gt;= self.capacity:</span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">            self.addToHead(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果存在哈希冲突，修改结果并将其移动到链表头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">            print(<span class="string">"哈希冲突"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        node.prev = self.head</span><br><span class="line">        self.head.next.prev = node</span><br><span class="line">        self.head.next = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br></pre></td></tr></table></figure><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>在<a href="https://zh.wikipedia.org/wiki/計算機科學" target="_blank" rel="noopener">计算机科学</a>与<a href="https://zh.wikipedia.org/wiki/數學" target="_blank" rel="noopener">数学</a>中，一个<strong>排序算法</strong>（英语：Sorting algorithm）是一种能将一串资料依照特定排序方式进行排列的一种<a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a>。最常用到的排序方式是数值顺序以及<a href="https://zh.wikipedia.org/wiki/字典順序" target="_blank" rel="noopener">字典顺序</a>。有效的排序算法在一些算法（例如<a href="https://zh.wikipedia.org/wiki/搜尋算法" target="_blank" rel="noopener">搜索算法</a>与<a href="https://zh.wikipedia.org/w/index.php?title=合併算法&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">合并算法</a>）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字资料以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ol><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种<a href="https://zh.wikipedia.org/wiki/排列" target="_blank" rel="noopener">排列</a>、或是重组</li></ol><p><img src="https://pic.leetcode-cn.com/1615436114-fkGCEG-image.png" alt="image.png"></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void Merge(int *a,int s,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">int temp[<span class="number">20</span>];</span><br><span class="line">int i=s,q=s;</span><br><span class="line">int j=m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line">temp[q++]=a[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[q++]=a[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">temp[q++]=a[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">temp[q++]=a[j++];</span><br><span class="line"><span class="keyword">for</span>(int k=s;k&lt;=n;k++)</span><br><span class="line">a[k]=temp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MSort(int *a,int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    <span class="keyword">if</span>(s==t)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(s+t)/<span class="number">2</span>;</span><br><span class="line">        MSort(a,s,m);</span><br><span class="line">        MSort(a,m+<span class="number">1</span>,t);</span><br><span class="line">        Merge(a,s,m,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span><span class="comment">//最后返回的位置为枢轴的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RedType t;</span><br><span class="line">    L.r[<span class="number">0</span>]=L.r[low];<span class="comment">//设置枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(L.r[high].key&gt;=L.r[<span class="number">0</span>].key&amp;&amp;low&lt;high)</span><br><span class="line">            high--;</span><br><span class="line">        L.r[low]=L.r[high];</span><br><span class="line">        <span class="keyword">while</span>(L.r[low].key&lt;L.r[<span class="number">0</span>].key&amp;&amp;low&lt;high)</span><br><span class="line">            low++;</span><br><span class="line">        L.r[high]=L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsort</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        i=Partition(L,low,high);</span><br><span class="line">        Qsort(L,low,i<span class="number">-1</span>);</span><br><span class="line">        Qsort(L,i+<span class="number">1</span>,high);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d趟排序:"</span>,count);</span><br><span class="line">        Print(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></p><p>给定一个非空的整数数组，返回其中出现频率前 <strong><em>k\</em></strong> 高的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>大根堆：父节点的值大于子节点的值。</p><p>小根堆：父节点的值小于子节点值。</p><ol><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个升序链表</a></li></ol><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>思路一：利用堆排序</p><p>构建一个小根堆，将元素一次插入其中，然后将链表一次放入其中。</p><p>然后一次将链表弹出，最后得到的就是有序的链表。</p><p>思路二：将链表结果放到数组里面，然后利用快排。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> l:</span><br><span class="line">                heapq.heappush(heap, l.val)</span><br><span class="line">                l = l.next</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            val = heappop(heap)</span><br><span class="line">            point.next = ListNode(val)</span><br><span class="line">            point = point.next</span><br><span class="line">        point.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode常见题型及对应解法&lt;/p&gt;&lt;h2 id=&quot;技巧类&quot;&gt;&lt;a href=&quot;#技巧类&quot; class=&quot;headerlink&quot; title=&quot;技巧类&quot;&gt;&lt;/a&gt;技巧类&lt;/h2&gt;&lt;p&gt;矩阵数据旋转&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-image/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;48. 旋转图像&lt;/a&gt;&lt;/p&gt;&lt;p&gt;给定一个 &lt;em&gt;n&lt;/em&gt; × &lt;em&gt;n&lt;/em&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。&lt;/p&gt;&lt;p&gt;你必须在&lt;strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/原地算法&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 原地&lt;/a&gt;&lt;/strong&gt; 旋转图像，这意味着你需要直接修改输入的二维矩阵。&lt;strong&gt;请不要&lt;/strong&gt; 使用另一个矩阵来旋转图像。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[[7,4,1],[8,5,2],[9,6,3]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="题型归纳" scheme="http://yoursite.com/tags/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3/"/>
    
  </entry>
  
  <entry>
    <title>deep cross network原理及实现</title>
    <link href="http://yoursite.com/2020/12/26/deep-cross-network%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/12/26/deep-cross-network原理及实现/</id>
    <published>2020-12-26T08:57:27.000Z</published>
    <updated>2021-03-21T16:11:11.787Z</updated>
    
    <content type="html"><![CDATA[<p>本文提出贡献：</p><ul><li>提出了一个交叉网络，能够在每一层直接进行特征交叉，不需要手工特征</li><li>交叉网络简单并且有效，可以通过增加交叉网络层数来提升特征的交叉阶数。</li><li>交叉网络比较省内存并且易于扩展</li></ul><p>交叉网络计算公式</p><script type="math/tex; mode=display">x_{l+1}=x_0x_l^tw_l+b_l+x_l</script><p>优点像残差网络</p><p>其中$x_0$为cross net第一层的输入，其维度为(k, 1)，$x_l^t$的维度为(1,k)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文提出贡献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提出了一个交叉网络，能够在每一层直接进行特征交叉，不需要手工特征&lt;/li&gt;
&lt;li&gt;交叉网络简单并且有效，可以通过增加交叉网络层数来提升特征的交叉阶数。&lt;/li&gt;
&lt;li&gt;交叉网络比较省内存并且易于扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="CTR" scheme="http://yoursite.com/tags/CTR/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>deepFM的原理及实现</title>
    <link href="http://yoursite.com/2020/11/29/deepFM%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/11/29/deepFM的原理及实现/</id>
    <published>2020-11-29T09:25:12.000Z</published>
    <updated>2020-11-29T09:25:24.882Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从FM、FM到deepFM</title>
    <link href="http://yoursite.com/2020/11/18/%E4%BB%8EFM-FM%E5%88%B0deepFM/"/>
    <id>http://yoursite.com/2020/11/18/从FM-FM到deepFM/</id>
    <published>2020-11-18T14:57:48.000Z</published>
    <updated>2020-12-21T14:27:11.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h1><ul><li><p>在传统任务中LR存在的缺点：</p></li></ul><p>1、模型一般为$y=w_0+\sum_{i=1}^nw_ix_i$，为考虑特征之间的关系。实际上交叉特征对于模型有很好地提升效果</p><p>2、对于categorical特征进行one-hot编码，具有高度稀疏性，带来维度灾难</p><p>二阶FM的定义</p><script type="math/tex; mode=display">y=w_0+\sum_{i=1}^nw_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^nW_{i,j}x_ix_j</script><a id="more"></a><p>$W$为实对称矩阵</p><p>所以FM的定义可以改写为</p><script type="math/tex; mode=display">y=w_0+\sum_{i=1}^nw_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^n<V_i,V_j>x_ix_j</script><p>FM两个特点</p><ul><li>解决特征交叉问题</li><li>利用矩阵分解解决数据量过大的问题</li></ul><h1 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h1><p>FFM定义</p><script type="math/tex; mode=display">y(x) = w_0+\sum_{i=1}^nw_ix_i + \sum_{i=1}^n\sum_{j=i+1}^n<V_{i,f_j}, V_{j,f_i}>x_ix_j</script><ul><li>考虑了特征的类别，认为类别之间也存在相关性，所以增加了一个维度。</li></ul><h1 id="deepFM"><a href="#deepFM" class="headerlink" title="deepFM"></a>deepFM</h1><ul><li>分成了DNN+FM模型的组合，DNN学习高阶交叉特征，FM学习低阶交叉特征</li><li>利用FM代替wide&amp;deep中wide部分，无需输入人工特征</li></ul><h2 id="第一步：数据预处理"><a href="#第一步：数据预处理" class="headerlink" title="第一步：数据预处理"></a>第一步：数据预处理</h2><p>主要数据类型：</p><ul><li>数值型，数值型需要归一化到[0,1]</li><li>离散单值型</li><li>离散多值型</li></ul><p>张量</p><p>keras input shape的层，最后一层规定最后一层</p><p>keras outputlayer</p><p>one-hot 其实是指这里的embedding，并没有one-hot</p><p>关于Embedding进行的操作，以keras embedding为例子</p><p>keras.layers.Embedding(input_dim, output_dim, embeddings_initializer=’uniform’, embeddings_regularizer=None, activity_regularizer=None, embeddings_constraint=None, mask_zero=False, input_length=None)</p><p>keras 主要进行了一下几个操作：</p><ul><li>将Embedding进行了one-shot操作，将类别特征变成batch_size * k的向量</li><li>将得到的向量分别乘以一个k <em> m的矩阵，得到embedding后的向量矩阵batch_size </em> k *m</li><li>将矩阵按照一维reduce_sum，得到最后结果</li></ul><p>一般来说，input_dim是类别特征的nunique值，output可以设置为定值或者 x**0.25</p><p>embedding数据的输入类型</p><p>(batch_size, filed_dim, embedding_dim)</p><p>关于FM的交叉项理解</p><p>1、在embedding的时候，对应的输出其实已经包含了$w_ix_i$</p><p>2、embedding输出维度为[batch_size, filed_dim, embedding_dim]</p><p>3、利用tf.reduce_sum() 对embedding_input进行汇总，其实已经得到FM的一次项</p><p>离散特征与连续特征的处理</p><ul><li>离散特征：先label_encode， 然后进行embedding操作</li><li>连续特征：直接作为输入</li></ul><p>deepFM一共三个输入模块</p><p>1、线性模块</p><p>在类别特征后面接了Embedding(input_dim= k,output_dim=1)​，需要注意的是</p><p>如果是 </p><p>然后与Dense特征合并</p><p>2、FM模块</p><p>Embedding(4,a)</p><p>3、DNN模块</p><p>与Embedding木块共享</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://cloud.tencent.com/developer/article/1450677" target="_blank" rel="noopener">【通俗易懂】手把手带你实现DeepFM！</a></p><p>2.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FM&quot;&gt;&lt;a href=&quot;#FM&quot; class=&quot;headerlink&quot; title=&quot;FM&quot;&gt;&lt;/a&gt;FM&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在传统任务中LR存在的缺点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1、模型一般为$y=w_0+\sum_{i=1}^nw_ix_i$，为考虑特征之间的关系。实际上交叉特征对于模型有很好地提升效果&lt;/p&gt;&lt;p&gt;2、对于categorical特征进行one-hot编码，具有高度稀疏性，带来维度灾难&lt;/p&gt;&lt;p&gt;二阶FM的定义&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
y=w_0+\sum_{i=1}^nw_ix_i+\sum_{i=1}^{n-1}\sum_{j=i+1}^nW_{i,j}x_ix_j&lt;/script&gt;
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="CTR" scheme="http://yoursite.com/tags/CTR/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>deep&amp;wide 论文笔记</title>
    <link href="http://yoursite.com/2020/11/12/deep-wide%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/11/12/deep-wide论文笔记/</id>
    <published>2020-11-12T02:44:12.000Z</published>
    <updated>2020-11-16T14:37:55.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wide-模型"><a href="#wide-模型" class="headerlink" title="wide 模型"></a>wide 模型</h1><p>基本特征+交叉特征，年龄特征分桶</p><h1 id="Deep模型"><a href="#Deep模型" class="headerlink" title="Deep模型"></a>Deep模型</h1><p>基本特征+embedding特征</p><h1 id="Wide-Deep模型"><a href="#Wide-Deep模型" class="headerlink" title="Wide Deep模型"></a>Wide Deep模型</h1><p>get_layer. output和get_layer的区别</p><p>需要自己记一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wide-模型&quot;&gt;&lt;a href=&quot;#wide-模型&quot; class=&quot;headerlink&quot; title=&quot;wide 模型&quot;&gt;&lt;/a&gt;wide 模型&lt;/h1&gt;&lt;p&gt;基本特征+交叉特征，年龄特征分桶&lt;/p&gt;
&lt;h1 id=&quot;Deep模型&quot;&gt;&lt;a href=&quot;#Dee
      
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="deep wide" scheme="http://yoursite.com/tags/deep-wide/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统之评价指标</title>
    <link href="http://yoursite.com/2020/11/08/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>http://yoursite.com/2020/11/08/推荐系统之评价指标/</id>
    <published>2020-11-08T06:41:35.000Z</published>
    <updated>2020-11-10T08:16:59.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NDCG-K"><a href="#NDCG-K" class="headerlink" title="NDCG@K"></a>NDCG@K</h2><p>CG只能判断推荐结果整体质量的高低，无法判断算法的排序好坏。</p><script type="math/tex; mode=display">CG=\sum_{i=1}^Prel_i</script><p>第一步计算DCG</p><p>思想是等级较高的结果排在后面，就应该对结果得分打折。</p><script type="math/tex; mode=display">DCG_p=rel_1 + \sum_{i=2}^P\frac{rel_i}{\log_2(i+1)}</script><p>$DCG_p$还有另外一个中写法</p><a id="more"></a><script type="math/tex; mode=display">DCG_p = \sum_{i=1}^P\frac{rel_i}{\log_2(i+1)}</script><p>其实就是$rel_i$的值为{0,1}时候的变形。</p><p>第二步计算IDCG</p><p>IDCG为理想情况下最大的DCG</p><script type="math/tex; mode=display">IDCG_p=\sum_{i=1}^{|REL|}\frac{2^{rel_i}-1}{\log_2(i+1)}</script><p>IDCG其实就是将结果根据相关性进行排序之后再计算前$p$个DCG结果。</p><p>ndcg计算公式</p><script type="math/tex; mode=display">nDCG_p = \frac{DCG_p}{IDCG_p}</script><p>NCGC其实就是将DGC进行了归一化，因为DCG的值和返回结果数量有关，所以如果结果不同，两个页面的结果是无法比较，因此归一化之后，就能将其放到同一维度下。</p><p>在实际计算的时候一般计算公式为</p><script type="math/tex; mode=display">\frac{\log(2)}{\log(x+1)}</script><h2 id="hit-k"><a href="#hit-k" class="headerlink" title="hit@k"></a>hit@k</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NDCG-K&quot;&gt;&lt;a href=&quot;#NDCG-K&quot; class=&quot;headerlink&quot; title=&quot;NDCG@K&quot;&gt;&lt;/a&gt;NDCG@K&lt;/h2&gt;&lt;p&gt;CG只能判断推荐结果整体质量的高低，无法判断算法的排序好坏。&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
CG=\sum_{i=1}^Prel_i&lt;/script&gt;&lt;p&gt;第一步计算DCG&lt;/p&gt;&lt;p&gt;思想是等级较高的结果排在后面，就应该对结果得分打折。&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
DCG_p=rel_1 + \sum_{i=2}^P\frac{rel_i}{\log_2(i+1)}&lt;/script&gt;&lt;p&gt;$DCG_p$还有另外一个中写法&lt;/p&gt;
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="评价指标" scheme="http://yoursite.com/tags/%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>召回之协同过滤算法</title>
    <link href="http://yoursite.com/2020/10/25/%E5%8F%AC%E5%9B%9E%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/10/25/召回之协同过滤算法/</id>
    <published>2020-10-25T06:04:31.000Z</published>
    <updated>2020-11-08T06:41:02.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UserCF"><a href="#UserCF" class="headerlink" title="UserCF"></a>UserCF</h2><h2 id="ItemCF"><a href="#ItemCF" class="headerlink" title="ItemCF"></a>ItemCF</h2><h2 id="矩阵分解MF"><a href="#矩阵分解MF" class="headerlink" title="矩阵分解MF"></a>矩阵分解MF</h2><p>矩阵分解其实和《推荐系统实战》那本书里面说的隐语意模型差不多多的意思，都是将用户-物品矩阵分解为用户矩阵和物品矩阵。分解的方法采用梯度下降。</p><script type="math/tex; mode=display">T=P * Q</script><script type="math/tex; mode=display">preference(u, i)=r_{ui}=p_{u}^Tq_{i}</script><h2 id="NCF"><a href="#NCF" class="headerlink" title="NCF"></a>NCF</h2><p>损失函数：</p><ul><li>pointwise，用于回归模型，最小化$\hat y_{ui}$和他的目标值$y_{ui}$之间的平方损失函数。</li><li>pairwise，思想史观测实例应该被排到为观测实例前面。观测到的entry $\hat y_{ui}$和为观测到的entry $y_{ui}$之间的差</li></ul><a id="more"></a><p><a href="https://blog.csdn.net/stalbo/article/details/79431662" target="_blank" rel="noopener">https://blog.csdn.net/stalbo/article/details/79431662</a></p><p>参考资料</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UserCF&quot;&gt;&lt;a href=&quot;#UserCF&quot; class=&quot;headerlink&quot; title=&quot;UserCF&quot;&gt;&lt;/a&gt;UserCF&lt;/h2&gt;&lt;h2 id=&quot;ItemCF&quot;&gt;&lt;a href=&quot;#ItemCF&quot; class=&quot;headerlink&quot; title=&quot;ItemCF&quot;&gt;&lt;/a&gt;ItemCF&lt;/h2&gt;&lt;h2 id=&quot;矩阵分解MF&quot;&gt;&lt;a href=&quot;#矩阵分解MF&quot; class=&quot;headerlink&quot; title=&quot;矩阵分解MF&quot;&gt;&lt;/a&gt;矩阵分解MF&lt;/h2&gt;&lt;p&gt;矩阵分解其实和《推荐系统实战》那本书里面说的隐语意模型差不多多的意思，都是将用户-物品矩阵分解为用户矩阵和物品矩阵。分解的方法采用梯度下降。&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
T=P * Q&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
preference(u, i)=r_{ui}=p_{u}^Tq_{i}&lt;/script&gt;&lt;h2 id=&quot;NCF&quot;&gt;&lt;a href=&quot;#NCF&quot; class=&quot;headerlink&quot; title=&quot;NCF&quot;&gt;&lt;/a&gt;NCF&lt;/h2&gt;&lt;p&gt;损失函数：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;pointwise，用于回归模型，最小化$\hat y_{ui}$和他的目标值$y_{ui}$之间的平方损失函数。&lt;/li&gt;
&lt;li&gt;pairwise，思想史观测实例应该被排到为观测实例前面。观测到的entry $\hat y_{ui}$和为观测到的entry $y_{ui}$之间的差&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="协同过滤" scheme="http://yoursite.com/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
      <category term="矩阵分解" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>spark内存管理机制及spark-submit参数调优</title>
    <link href="http://yoursite.com/2020/09/27/spark%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8Aspark-submit%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2020/09/27/spark内存管理机制及spark-submit参数调优/</id>
    <published>2020-09-27T05:48:36.000Z</published>
    <updated>2020-09-27T06:19:16.328Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="内存调优" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习推荐系统》阅读笔记(二)</title>
    <link href="http://yoursite.com/2020/08/26/%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-2/"/>
    <id>http://yoursite.com/2020/08/26/《深度学习推荐系统》阅读笔记-2/</id>
    <published>2020-08-25T16:59:36.000Z</published>
    <updated>2020-12-07T14:22:27.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Embedding作用及应用"><a href="#Embedding作用及应用" class="headerlink" title="Embedding作用及应用"></a>Embedding作用及应用</h1><p>Embedding也是编码方式的一种，主要作用是将稀疏向量转换成稠密向量。</p><p>Embedding是深度学习的基础核心操作，主要有一下三个原因</p><p>1、推荐场景下会使用one-hot对类别和id进行编码，造成大量稀疏数据，神经网络无法很好地处理这种稀疏数据</p><p>2、Embedding本身是极强的特征向量，可以引入任何信息进行编码。</p><a id="more"></a><p>3、Embedding对物品、用户的相似度计算是常用的推荐系统召回技术。</p><p>所以Embedding对应的应用方向主要有一下三个：</p><ul><li>作为Embedding层，完成高维稀疏特征向量到低维稠密特征向量的转换</li><li>作为预训练的特征向量，在与其他特征向量连接之后，一同输入深度学习网络进行训练</li><li>计算物品和用户的相似度做Embedding</li></ul><h1 id="Word2Vec和Item2Vec"><a href="#Word2Vec和Item2Vec" class="headerlink" title="Word2Vec和Item2Vec"></a>Word2Vec和Item2Vec</h1><p>Word2vec主要用于计算词向量相似度，Item2Vec是Word2Vec在推荐上面的应用，只是两者优化目标不同。并且Item2Vec使用的物品序列是由用户历史行为产生的物品序列。</p><p>假设Word2Vec中有一个长为$T$的句子为$w_1,w_2,…,w_T$,其优化的目标为</p><script type="math/tex; mode=display">\frac{1}{T}\sum_{t=1}^T\sum_{-c\le j\le c,j\ne0}\log p(w_{t+j}|w_t)</script><p>而对于Item2Vec，w表示历史记录，其优化目标为:</p><script type="math/tex; mode=display">\frac{1}{K}\sum_{i=1}^K\sum_{j\ne i}^K\log p(w_j|w_i)</script><p>Item2Vec摒弃了时间窗口，认为任意两个物品都是相关的，而不仅仅是时间窗口之类的物品对数和。</p><p>缺点：只能利用序列型数据，对网络化数据捉襟见肘</p><h1 id="Graph-Embedding"><a href="#Graph-Embedding" class="headerlink" title="Graph Embedding"></a>Graph Embedding</h1><p>Graph Embedding是一种对图结构中的结点进行Embedding编码的方法。</p><h2 id="DeepWalk"><a href="#DeepWalk" class="headerlink" title="DeepWalk"></a>DeepWalk</h2><p>主要思想是在由物品组成的图上随机游走，产生大量物品序列，然后将这些序列利用Word2Vec进行训练，得到物品的Embedding向量。</p><p>DeepWalk算法流程</p><p>1、基于用户行为构建关系图，例如用户先买A再买B，就会产生A到B的有向边，一次类推，将用户行为构建成物品关系图。</p><p>2、采用随机游走算法选择起始点，重新产生物品序列。</p><p>3、将产生序列输入到Word2Vec模型中</p><p>在DeepWalk算法流程中，唯一需要形式化定义的就是随机游走的跳转概率。假设遍历到节点$v_i$，那么跳转到其邻节点的概率是$v_j$的概率为：</p><script type="math/tex; mode=display">P(v_j|v_i)=\begin{cases} \frac{M_{ij}}{\sum_{j\in N_+(v_i) M_{ij}}},  & v_j\in N_+(v_i) \\0, & e_{ij}\notin \varepsilon\end{cases}</script><p>其中$M_{ij}$是节点$v_i$到$v_j$的边的权重。</p><p>优点：简单</p><p>缺点：随机游走抽样性不强</p><h2 id="Node2vec"><a href="#Node2vec" class="headerlink" title="Node2vec"></a>Node2vec</h2><p>通过调整随机游走权重的方法使Graph Embedding的结果更加趋向于体现网络的同质性或结构。网络的同质性指距离相近的节点的Embedding应尽量相似。结构性是指结构上相似的节点Embedding应尽量相似。</p><p>为了表达网络的结构性，游走更加倾向于BFS。对于BFS，不同的节点例如局部中心节点、边缘节点、连接性节点，其生成的序列节点数量和顺序必然不同。</p><p>为了表达同质性，游走通常采用DFS。DFS通常在一个大的集团内部游走，这就使得社区内部节点Embedding更加相似。</p><p>Node2vec主要是<font color="red">通过节点间的跳转概率空值游走时DFS和BFS的倾向</font></p><p>如图所示(图先欠着)，Node2Vec算法从节点$t$跳到节点$v$，再从$v$跳节点$x$的概率为$\pi_{vx}=a_{pq}(t,x)\cdot w_{vx}$</p><script type="math/tex; mode=display">a_{pq}=\begin{cases} \frac{1}{p},&   如果d_{tx}=0 \\1,  &如果d_{tx}=1             \\\frac{1}{q}, &如果 d_{tx}=2\end{cases}</script><p>其中$d_{tx}$表示节点$t$到节点$x$的距离，参数$p$和$q$共同控制这随机游走的倾向性，当$p$月小的时候，随机游走返回$t$的可能性越高，当$q$越小的时候，随机游走返回远方的可能性越大。</p><p>直观理解：同质性的物品很有可能是相似的物品或者经常被一同购买的物品，结构性可能是各类爆款、各品类的最佳凑单商品等拥有类趋势或结构性的商品。</p><p>优点：可以有效的挖掘不同的网络特征</p><p>缺点：需要较多的人工调参工作</p><h2 id="EGES"><a href="#EGES" class="headerlink" title="EGES"></a>EGES</h2><p>Enhanced Graph Embedding with Side information基本思想是在DeepWalk生成Graph Embedding的基础上引入补充信息，以解决冷启动问题。</p><p>可以利用物品相同属性、相同类别等信息建立物品之间的边，生成基于内容的知识图谱，基于知识图谱生成的物品Embedding向量作为补充信息，并且采用平均池化将不同物品的Embedding平均起来，为了防止平均池化导致有效信息丢失，对每个Embedding向量进行加权(Enhance 的体现)。在实际加权的过程中，采用了$e^{a_j}$而不是$a_j$进行加权，主要原因有两点：一：避免权重为0，二：指数函数在梯度下降的过程中有良好的数学性。因此EGES更多的是工程上的尝试，缺乏学术上的创新。</p><h1 id="局部敏感哈希"><a href="#局部敏感哈希" class="headerlink" title="局部敏感哈希"></a>局部敏感哈希</h1><p>传统Embedding在做召回的时候，以为着要对所有物品进行Embedding进行遍历，效率比较低。在推荐系统中，通常物品总数动达几百万，因此会导致线上模型过程的巨大延迟。</p><p>局部敏感哈希则是为了解决这个问题，其基本思想是然相邻的点落入到同一个桶里面。</p><p>优点：解决利用Embedding作为推荐系统召回层的快速计算方法</p><p>缺点：存在小概率的最近邻遗漏的可能，需要进行较多的人工调参</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Embedding作用及应用&quot;&gt;&lt;a href=&quot;#Embedding作用及应用&quot; class=&quot;headerlink&quot; title=&quot;Embedding作用及应用&quot;&gt;&lt;/a&gt;Embedding作用及应用&lt;/h1&gt;&lt;p&gt;Embedding也是编码方式的一种，主要作用是将稀疏向量转换成稠密向量。&lt;/p&gt;&lt;p&gt;Embedding是深度学习的基础核心操作，主要有一下三个原因&lt;/p&gt;&lt;p&gt;1、推荐场景下会使用one-hot对类别和id进行编码，造成大量稀疏数据，神经网络无法很好地处理这种稀疏数据&lt;/p&gt;&lt;p&gt;2、Embedding本身是极强的特征向量，可以引入任何信息进行编码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Embedding" scheme="http://yoursite.com/tags/Embedding/"/>
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《深度学习推荐系统》阅读笔记(一)</title>
    <link href="http://yoursite.com/2020/08/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://yoursite.com/2020/08/24/深度学习推荐系统阅读笔记-一/</id>
    <published>2020-08-24T15:33:22.000Z</published>
    <updated>2020-10-22T09:27:13.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h1><h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p>1、User-CF的缺点</p><ul><li>一般用户数量远大于物品数，用户相似度矩阵较大，不便于存储。同时用户数增长会造成在线存储系统难以承载扩张速度</li><li>用户历史数据向量往往比较稀疏，User-CF不适用于正反馈获取比较困难的场景，例如大件商品购买等低频应用</li></ul><p>2、User-CF和Item-CF的使用场景</p><ul><li>User-CF适用于新闻推荐场景，具有较强的社交性、更容易发现热点</li><li>Item-CF适用于兴趣变化比较稳定的应用，比如电商和视频推荐场景</li></ul><a id="more"></a><p>协同过滤存在天然缺陷，头部效应明显，处理稀疏向量的能力较弱。并且协同过滤仅仅利用了用户年龄、性别、商品描述、商品分类等信息，会造成有效信息遗漏。</p><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h2><p>矩阵分解，针对协同过滤算法头部效应明显，泛化能力弱，加入了隐向量。</p><p>矩阵分解的三种方法：</p><ul><li>奇异值分解SVD</li><li>特征值分解</li><li>梯度下降法</li></ul><p>特征值分解只适合方阵，不适用于分解用户-物品矩阵。</p><p>奇异值分解要求共现矩阵稠密，且时间复杂度过高。所以一般采用梯度下降来进行矩阵分解。</p><p>矩阵分解优点：</p><ul><li>泛化能力强</li><li>空间复杂度低，只需要存储用户和物品隐向量</li><li>更好的扩张性和灵活性，可以和其他特征拼接</li></ul><p>缺点：</p><p>和协同过滤一样，无法利用用户年龄性别等信息</p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>将推荐问题转换成CTR问题</p><p>优点：</p><ul><li>数学上的支撑</li><li>可解释性强</li><li>符合人类对预估过程的直觉认识</li></ul><p>缺点：</p><ul><li>表达能力不强，无法进行特征交叉，导致信息丢失</li></ul><h2 id="FM与FFM"><a href="#FM与FFM" class="headerlink" title="FM与FFM"></a>FM与FFM</h2><p>辛普森悖论：在分组中占优势的一方在总评中不占优势。</p><h3 id="POLY2"><a href="#POLY2" class="headerlink" title="POLY2"></a>POLY2</h3><p>暴力交叉特征，对所有特征进行两两组合，数学形式：</p><script type="math/tex; mode=display">\Phi POLY2(w,x)=\sum_{j_1=1}^n\sum_{j_2=j_1+1}^nw_h(j_1,j_2)x_{j_1}x_{j_2}</script><p>$x_i$和$x_j$表示特征$i,j$，$w_h(i,j)$表示特征的权重赋值，本质任是线性模型。</p><p>有点：</p><p>本质任然是线性模型，便于工程兼容</p><p>缺点：</p><ul><li>采用one-shot编码，处理类别特征是会导致特征极度稀疏，并且无法选择特征交叉，导致部分稀疏特征更加稀疏，无法收敛</li><li>参数上升了，量级从$n$上升至$n^2$。</li></ul><h3 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h3><p>数学形式：</p><script type="math/tex; mode=display">FM(w,x)=\sum_{j_1=1}^n\sum_{j_2=j_1+1}^n(w_{j_1}\cdot w_{j_2})x_{j_1}x_{j_2}</script><p>$w$为$(1,k)$维向量。</p><p>优点：</p><ul><li>引入隐向量使FM有效解决数据稀疏性问题，将权重模型减少到了$n*k$</li><li>可以使用梯度下降学习，不失灵活性和</li></ul><h2 id="FFM"><a href="#FFM" class="headerlink" title="FFM"></a>FFM</h2><p>相对于FM，引入了特征感知域的概念，使得模型的表达能力更强</p><script type="math/tex; mode=display">FFM(w,x)=\sum_{j_1=1}^n\sum_{j_2=j_1+1}^n(w_{j_1,f_2}\cdot w_{j_2,f_1})x_{j_1}x_{j_2}</script><p>FFM和FM的区别在于隐向量由原来的$w_{j_1}$变成了$w_{j_1,f_2}$，意味着每个特征对应着不是唯一的隐向量，而是一个隐向量组。吧</p><h2 id="GBDT-LR"><a href="#GBDT-LR" class="headerlink" title="GBDT+LR"></a>GBDT+LR</h2><p>自动化特征的开端</p><p>1、GBDT进行特征转换</p><ul><li>将样本输入一个子树之后，回落到一个叶子结点中，将该节点置为1，其他结点置为0，然后将所有结点进行拼接，就得到一个特征向量</li><li>决策树的深度决定交叉特征的的阶数，决策树深度为4，经过3次分裂，交叉特征为3阶</li></ul><p>传统特征工程：</p><ul><li>进行人工或者半人工的特征组合和筛选</li><li>改造目标函数，改进模型结构，提升特征交叉的方式增强特征组合</li></ul><p>弊端：</p><ul><li>对算法工程师经验和经历投入要求太高了</li><li>从根本上改变模型结构，对模型设计能力要求太高</li></ul><p>GBDT+LR的优点：<br>特征工程由独立模型完成，实现端到端的训练。</p><h1 id="深度学习模型"><a href="#深度学习模型" class="headerlink" title="深度学习模型"></a>深度学习模型</h1><p>深度学习模型优点：</p><p>1、表达能力更强，能够挖掘出更多的数据中潜藏的模式。</p><p>2、模型结构灵活，能够根据业务场景和数据特点灵活调整模型结构。</p><p>深度学习模型的几个发展方向</p><ul><li>改变神经网络复杂度</li><li>改变特征交叉的方式</li><li>组合模型</li><li>FM模型的学习演化版本</li><li>注意力机制和推荐模型的结合</li><li>序列模型与推荐系统的结合</li><li>强化模型与推荐系统的结合</li></ul><h2 id="AutoRec"><a href="#AutoRec" class="headerlink" title="AutoRec"></a>AutoRec</h2><p>  浅层神经网络，对于协同过滤，存在$m\times n$的共现矩阵，相当于神经网络中的权重$w$，使用单层神经网络具有一定的泛化能力，但是结构较简单，泛化能力存在不足。</p><h2 id="Deep-Crossing"><a href="#Deep-Crossing" class="headerlink" title="Deep Crossing"></a>Deep Crossing</h2><p>微软搜索引擎中的搜索广告推荐场景。</p><p> Deep Crossing需要解决的三个问题</p><p>1、离散类特征过于稀疏，不利于直接输入神经网络进行训练，如何解决稀疏特征稠密化？</p><p>引入embedding层，将稀疏特征稠密化</p><p>2、如何解决特征自动交叉问题？</p><p>引入残差网络结构，<font color="red">通过多层残差对各个维度进行交叉</font>&gt;。</p><p>3、如何在输出层达成问题设定的优化目标？</p><p>引入Scoring层，对于CTR二分类问题，采用逻辑回归模型，对于图像类多分类问题，采用softmax模型。</p><p>优点：</p><p>没有采用任何人工特征的参与。</p><h2 id="NeuralCF"><a href="#NeuralCF" class="headerlink" title="NeuralCF"></a>NeuralCF</h2><p>NeuralCF采用多元神经网络+输出层结构代替了矩阵分解模型中简单內积操作，目的是：</p><ul><li>让用户向量和物品向量充分交叉，得到价值更多的特征组合信息</li><li>引入更多非线性特征，让模型表达能力更强</li></ul><p>优势：</p><p>利用神经网络的优势，可灵活组合不同的特征，按需增加或减少模型复杂度</p><p>缺点：</p><p>由于基于协同过滤的思想，没有引入其他类别特征。</p><h2 id="PNN"><a href="#PNN" class="headerlink" title="PNN"></a>PNN</h2><p>相对于Deep Cross，将stacking层换成了Product Layer，乘积层，里面既有内集，也有外集。</p><p>优点：</p><p>对于Embedding向量多样化交叉，定义了內积和外积操作</p><p>缺点：</p><p>特征进行了无差别交叉，一定程度的忽略了原始特征向量中包含的价值信息。</p><h2 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide&amp;Deep"></a>Wide&amp;Deep</h2><p>Wide&amp;Deep设计的初衷和最大价值在于同时具有较强的记忆能力和泛化能力</p><p>记忆能力：模型直接学习并且利用历史数据中的物品和特征共现能力，例如协同过滤，可以通过历史数据计算物品和用户共现矩阵，进而通过历史数据进行推荐。</p><p>泛化能力：模型的传递特征的相关性，发觉稀疏甚至从未出现过的稀有特征和最终标签相关性能力。</p><p>Deep部分输入的是全量的特征，数值型和类别特征的embedding向量通过全连接层连接在一起。</p><p>Wide部分仅输入已安装应用和曝光应用两类特征，已安装应用表示用户历史行为，曝光应用代表当前待推荐的应用，选择这两类特征的原因是充分发挥wide的记忆能力强的有点。</p><p>Wide&amp;Deep模型的优点：</p><p>（1）抓住业务本质特点，融合传统模型的记忆能力和深度模型的泛化能力</p><p>（2）模型结构不复杂，容易工程化实现</p><p>缺点：</p><p>Wide部分任需要人工筛选特征</p><h2 id="Wide-amp-Cross"><a href="#Wide-amp-Cross" class="headerlink" title="Wide&amp;Cross"></a>Wide&amp;Cross</h2><p>使用Cross网络替代原来的wide部分。设计Cross网络的目的是为了增加特征之间的交互力度，使用多层交叉层对输入向量进行特征交叉。减少人工特征。</p><p>假设$l$层交叉层的输出向量为$x_l$，那么$l+1$层的向量输出为:</p><script type="math/tex; mode=display">x_{l+1}=x_0x_l^TW_l+b_l+x_l</script><p>每层均保留了输入向量，因此在输入向量和输出向量之间的差别不是特别大。</p><p>优点：可以自动进行交叉特征，避免了很多基于业务理解的人工特征。</p><p>缺点：Cross部分网络复杂度较高。</p><h2 id="FM系列"><a href="#FM系列" class="headerlink" title="FM系列"></a>FM系列</h2><h3 id="FNN"><a href="#FNN" class="headerlink" title="FNN"></a>FNN</h3><p>为了解决Embedding训练速度慢的问题，FNN采用的思路是用FM模型训练好的个特征隐向量初始化Embedding层参数，有点类似预训练。FM的计算公式：</p><script type="math/tex; mode=display">y_{FM}=sigmod(w_0+\sum_{i=1}^Nw_ix_i+\sum_{i=1}^N\sum_{j=i+1}^N<v_i,v_j>x_ix_j</script><p>优点：利用FM初始化Embedding层参数，加快训练</p><p>缺点：结构比较简单，没有针对性的特征交叉层</p><h3 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h3><p>采用FM优化Wide&amp;Deep模型中Wide模块，主要针对Wide部分不具备自动组合特征的能力的缺陷进行改善的。利用FM替换了原来的Wide部分，加强了浅层网络部分特征组合的能力。左边FM与右边神经网络共享相同的embedding层。FM对不同特征域两两交叉。也就是将embedding层当做原FM中隐向量。</p><h3 id="NFM"><a href="#NFM" class="headerlink" title="NFM"></a>NFM</h3><p>NFM的思想，利用神经网络改进FM，主要思路是利用一个表达能力更强的函数替代原FM</p><script type="math/tex; mode=display">\hat y_{FM}(x)=w_0+\sum_{i=1}^Nw_ix_i+\sum_{i=1}^N\sum_{j=i+1}^Nv_i^Tv_j\cdot x_ix_j</script><script type="math/tex; mode=display">\hat y_{MFM}(x)=w_0+\sum_{i=1}^Nw_ix_i+f(x)</script><p>主要有5各模块</p><ul><li>原始稀疏特征向量</li><li>Embedding层</li><li>特征交叉池化层</li><li>隐层</li><li>预测层</li></ul><p>其实就是在Embedding层和多层神经网络之间增加了特征交叉池化层，具体操作如下：</p><script type="math/tex; mode=display">f_{BI}(V_x)=\sum_{i=1}^n\sum_{j=i+1}^n(x_iv_i)\odot (x_jv_j)</script><p>$\odot$表示两个向量的元素积操作</p><script type="math/tex; mode=display">(v_i\odot v_j)_k=v_{ik}v_{j_k}</script><p>基于FM的深度学习模型的有点和局限性</p><p>优点：</p><ul><li>让模型具备非常强的非线性表达能力</li></ul><p>局限：</p><ul><li>进行了大量基于不同特征交互操作思路的尝试，特征工程的思路已经穷尽了。</li></ul><h2 id="AFM"><a href="#AFM" class="headerlink" title="AFM"></a>AFM</h2><p>在NFM模型中，对于不同的特征一视同仁，但是实际上不同的特征对于业务的影响是不一致的，因此AFM通过在NFM的特征交叉层和最终输出层加上注意力机制实现，AFM的特征交叉过程同样采用元素积操作</p><script type="math/tex; mode=display">f_{PI}(\delta) =\{(v\odot v_j)x_ix_j\}_{(i,j)\in R_{x}}</script><p>AMF加入注意力得分之后的池化过程</p><script type="math/tex; mode=display">f_{Att}(f_{PI}(\delta))=\sum_{(i,j)\R_x}a_{i,j}(v_i\odot v_j)x_ix_j</script><p>为了防止交叉特征数据稀疏问题带来的权重难以收敛，AFM在交叉层和池化层之间的注意力网络来生成注意力得分</p><h2 id="DIN"><a href="#DIN" class="headerlink" title="DIN"></a>DIN</h2><p>应用场景： 阿里巴巴电商广告推荐</p><p>DIN模型是在深度学习网络中加入了注意力机制，利用候选商品和历史行为相关性计算出一个权重，这个权重代表注意力的强弱。例如，广告中的商品是键盘，用户点击商品序列有几个不同的商品id，分别为鼠标、T恤和洗面奶。因此鼠标这个历史行为的商品id对于预测键盘广告的点击率重要程度大于后两者。</p><p>注意力形式化表达：</p><script type="math/tex; mode=display">V_u=f(V_a)=\sum_{i=1}^Nw_i\cdot V_i = \sum_{i=1}^Ng(V_i,V_a)\cdot V_i</script><p>$V_u$是用户Embedding向量，$V_a$是候选广告商品Embedding向量，$V_i$是用户$u$第$i$次行为Embedding向量。用户行为指的是游览的商品和店铺。$w_i$由$V_i$和$V_a$的关系决定，即$w_i=g(V_i,V_a)$, g函数采用的是注意力激活单元。</p><p>优点：</p><ul><li>在传统深度学习推荐系统模型基础上，引入了注意力机制，并利用用户历史行为和目标广告商品的相关性计算注意力得分</li></ul><p>缺点：</p><ul><li>没有充分利用历史行为以外的其他特征。</li></ul><h2 id="DIEN"><a href="#DIEN" class="headerlink" title="DIEN"></a>DIEN</h2><p>相比DIN，考虑到了时序信息，用户的兴趣也是随着时间变化的，因此时序信息能够</p><p>1、加强最近行为对下一次购买的预测影响</p><p>2、序列模型能够学习到购买趋势</p><p>网络结构还是输入层+Embedding层+连接层+多层全连接层+输出层</p><p>DIEN的创新点在于构建了一个兴趣进化网络。</p><p>兴趣进化网络分三层：</p><p>1、行为序列层：将原始的ID行为序列转换成Embedding行为序列</p><p>2、兴趣抽取层：通过模拟用户兴趣迁移过程，抽取用户兴趣。采用GRU，相对于LSTM参数更少</p><p>3、兴趣进化层：通过在兴趣层基础上加上注意力机制，模拟兴趣的进化过程。结构为AUGRU，在院GRU的更新门的结构上加上了注意力得分。</p><p>优点：</p><ul><li>考虑到了时序信息</li></ul><p>缺点：</p><ul><li>序列模型训练起来比较复杂</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;传统模型&quot;&gt;&lt;a href=&quot;#传统模型&quot; class=&quot;headerlink&quot; title=&quot;传统模型&quot;&gt;&lt;/a&gt;传统模型&lt;/h1&gt;&lt;h2 id=&quot;协同过滤&quot;&gt;&lt;a href=&quot;#协同过滤&quot; class=&quot;headerlink&quot; title=&quot;协同过滤&quot;&gt;&lt;/a&gt;协同过滤&lt;/h2&gt;&lt;p&gt;1、User-CF的缺点&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;一般用户数量远大于物品数，用户相似度矩阵较大，不便于存储。同时用户数增长会造成在线存储系统难以承载扩张速度&lt;/li&gt;
&lt;li&gt;用户历史数据向量往往比较稀疏，User-CF不适用于正反馈获取比较困难的场景，例如大件商品购买等低频应用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、User-CF和Item-CF的使用场景&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;User-CF适用于新闻推荐场景，具有较强的社交性、更容易发现热点&lt;/li&gt;
&lt;li&gt;Item-CF适用于兴趣变化比较稳定的应用，比如电商和视频推荐场景&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="阅读笔记" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程之特征选择</title>
    <link href="http://yoursite.com/2020/08/05/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/"/>
    <id>http://yoursite.com/2020/08/05/特征工程之特征选择/</id>
    <published>2020-08-05T07:43:10.000Z</published>
    <updated>2020-11-08T07:17:26.367Z</updated>
    
    <content type="html"><![CDATA[<p>​    </p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/特征选择/捕获.PNG" alt></p><p>特征选择，即对于生成的特征集合进行筛选，得到一个子集，主要有一下三个目的</p><ul><li>简化模型，增加可解释性</li><li>改善性能，并且节省存储空间和计算开销</li><li>改善通用性，降低过拟合风险。</li></ul><p>特征选择主要分为三种方法，过滤方法、封账方法和嵌入方法</p><h1 id="过滤方法Filter"><a href="#过滤方法Filter" class="headerlink" title="过滤方法Filter"></a>过滤方法Filter</h1><p>过滤方法主要特点：</p><ul><li>不依赖与机器学习算法</li><li>一般分为单变量和多变量</li><li>单变量一般基于特征变量与目标变量之间的相关性或互信息，根据相关性排序，过滤掉最不相关特征</li><li>多变量有基于相关性和一致性的特征选择</li></ul><a id="more"></a><h2 id="单变量"><a href="#单变量" class="headerlink" title="单变量"></a>单变量</h2><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p>一般来说，会把缺失率15%-20%左右的特征丢弃掉，不过不是绝对的，也可以通过其他特征的关系或者利用模型预测对缺失值进行补齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cols = data.columns.values.tolist()</span><br><span class="line">missing_rate = pd.DataFrame(&#123;<span class="string">'column_name'</span>:cols&#125;)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cols:</span><br><span class="line">    missing_rate.loc[missing_rate[<span class="string">'column_name'</span>]==c,<span class="string">'missing_rate'</span>] = data[data[c].isna()==<span class="literal">True</span>].shape[<span class="number">0</span>]/data.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><p>皮尔逊相关性系数用于度量两个变量$X$和$Y$的线性相关性，计算公式为</p><script type="math/tex; mode=display">\rho_{X,Y}=\frac{cov(X,Y)}{\sigma_X\sigma_Y}</script><p>样本上的相关性系数为</p><script type="math/tex; mode=display">r=\frac{\sum_{i=1}^n(X_i-\bar X_i)(Y_i-\bar Y_i)}{\sqrt{(\sum_{i=1}^n(X_i-\bar X_i)^2)}\sqrt{(\sum_{i=1}^n(Y_i-\bar Y_i)^2)}}</script><p>在数据标准化（ <img src="https://www.zhihu.com/equation?tex=%5Cmu%3D0%2C%5Csigma%3D1" alt="[公式]"> ）后，Pearson相关性系数、Cosine相似度、欧式距离的平方可认为是等价的。</p><p>如何理解皮尔逊相关系数（Pearson Correlation Coefficient）？ - 微调的回答 - 知乎 <a href="https://www.zhihu.com/question/19734616/answer/349132554" target="_blank" rel="noopener">https://www.zhihu.com/question/19734616/answer/349132554</a></p><p>使用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"></span><br><span class="line">r,p = pearsonr(X,Y)</span><br></pre></td></tr></table></figure><p>r表示相关性系数</p><ul><li>r&gt;0表示正相关</li><li>r=1表示正线性相关</li><li>r&lt;0表示负相关</li><li>r=0表示非线性相关。</li><li>r=-1表示负线性相关</li></ul><p>p-value越低表示越低，可靠性越高。<a href="https://www.cnblogs.com/lijingblog/p/11043513.html" target="_blank" rel="noopener">https://www.cnblogs.com/lijingblog/p/11043513.html</a></p><h3 id="Fisher得分"><a href="#Fisher得分" class="headerlink" title="Fisher得分"></a>Fisher得分</h3><p>在分类问题中，对于好的特征，在同一类别中取值比较相似，在不同类别中取值差异较大。因此特征i的重要性可以用Fisher得分$S_i$表示：</p><script type="math/tex; mode=display">S_i=\frac{\sum_{j=1}^Kn_j(u_{ij}-u_i)^2}{\sum_{j=1}^Kn_j\rho^2_{ij}}</script><p>$u_{ij}$和$\rho_{ij}$分别表示特征$i$在类别$j$中的中的均值和方差，$n_j$表示类别$j$的样本数，Fisher特征越高，特征在不同类别的差异性越大，在同一类别的差异性越小。</p><h3 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h3><p>目的：检验特征变量和目的变量之间的相关性</p><p>公式为：</p><script type="math/tex; mode=display">\chi^2=\sum_{i=1}^r\sum_{j=1}^c\frac{(O_{i,j}-E_{i,j})^2}{E_{i,j}^2}</script><p>其中$O_{i,j}$表示观测值，$E_{i,j}$表示期望值，$i$表示类别$i$，$j$表示对应的目标变量$j$。如何假设正确，$\chi$越小，相关性越小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">model1 = SelectKBest(chi2, k=<span class="number">2</span>)<span class="comment">#选择k个最佳特征</span></span><br><span class="line">model1.fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure><h3 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h3><p>用于度量两个变量之间的相关性，互信息越大，表示两个变量的相关性越高，互信息为0，表示两个变量相互独立。</p><p>互信息计算公式：</p><script type="math/tex; mode=display">I(X,Y)=\sum_{x\in X}\sum_{y\in Y}p(x,y)log\frac{p(x,y)}{p(x)p(y)}</script><p>其中$X、Y$的联合分布为$p(x,y)$，边缘分布为$p(x),p(y)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics <span class="keyword">as</span> mr</span><br><span class="line">mr.mutual_info_score(Y,X)</span><br></pre></td></tr></table></figure><h2 id="多变量"><a href="#多变量" class="headerlink" title="多变量"></a>多变量</h2><h3 id="最小冗余最大相关性mRmR"><a href="#最小冗余最大相关性mRmR" class="headerlink" title="最小冗余最大相关性mRmR"></a>最小冗余最大相关性mRmR</h3><h3 id="相关特征选择-CFS"><a href="#相关特征选择-CFS" class="headerlink" title="相关特征选择(CFS)"></a>相关特征选择(CFS)</h3><p>相关特征选择(Correlation Feature Selection，CFS)基于以下假设来评估集合的重要性：好的特征集合包含于目标变量非常相关的特征，但这些特征彼此不想关。</p><p>公式如下：</p><script type="math/tex; mode=display">CFS=\max_{S_k}[\frac{r_{cf_1}+r_{cf_2}+...+r_{cf_k}}{\sqrt{k+2(r_{f_1f_2}+r_{f_if_j}+...+r_{f_kf_1})}}</script><p>其中$r_{cf_i}$和$r_{f_if_j}$分别表示特征变量和目标变量之间的相关性以及特征变量与特征变量之间的相关性。</p><p>这部分代码暂时没有搞懂，后续在研究。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skfeature.function.statistical_based <span class="keyword">import</span> CFS</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  <span class="comment"># 利用iris数据作为演示数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line">train_set = X[<span class="number">0</span>:<span class="number">100</span>,:]</span><br><span class="line">test_set = X[<span class="number">100</span>:,]</span><br><span class="line">train_y = y[<span class="number">0</span>:<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">num_feature = <span class="number">2</span> <span class="comment"># 从原数据集中选择两个变量</span></span><br><span class="line"></span><br><span class="line">feature_index = CFS.cfs(train_set, train_y)</span><br></pre></td></tr></table></figure><h3 id="FCBF"><a href="#FCBF" class="headerlink" title="FCBF"></a>FCBF</h3><p>FCBF算法： 全称 Fast Correlation-Basd Filter Solution, 是一种快速过滤的特征选择算法，一种基于symmetrical uncertainty（SU）的方法。其计算步骤如下：</p><p>1、计算每个特征与目标C之间的相关性$SU_{F_i,c}$</p><script type="math/tex; mode=display">SU(X,Y)=2\frac{IG(X,Y)}{E(X)+E(Y)}\\E(x)=-\sum_{i=1}^cPx_i()*\log_2(P_{X_i})\\E(X|Y)=-\sum_{i=1}^{C_Y}P(y_i)\sum_{j=1}^cP(x_j|y_i)\log_2(P(x_j|y_i))</script><p>其中$IG(X,Y)$代表信息增益，$E(X)$代表信息熵，$P(X_i)$表示$X$取到$i$的概率，$c$为类别数目</p><p>2、将最大相关性的特征预先使用$\delta$选择出来</p><p>3、将$SU_{F_i,c}$按照大小排序，并且计算每个特征$F_i$与排序中SU小于$SU_{}$的特征$F_j$之间的相关性$SU_{F_i,F_j}$，如果$SU_{F_i,c}&gt;SU_{F_j,c}$,计算$SU_{F_i,F_j}$</p><p>4、如果$SU_{F_i,F_j}&gt;SU_{F_j,c}$，删除特征$F_j$</p><h1 id="封装方法Wrapper"><a href="#封装方法Wrapper" class="headerlink" title="封装方法Wrapper"></a>封装方法Wrapper</h1><p>封装方法直接利用机器学习算法评价特征子集的效果，它可以检测两个或者多个特征之间的相互关系，而且选择的特征子集让模型效果运行达到最优</p><h2 id="确定性算法"><a href="#确定性算法" class="headerlink" title="确定性算法"></a>确定性算法</h2><h3 id="序列前向特征选择-SFS-和序列后向特征选择-SBE"><a href="#序列前向特征选择-SFS-和序列后向特征选择-SBE" class="headerlink" title="序列前向特征选择(SFS)和序列后向特征选择(SBE)"></a>序列前向特征选择(SFS)和序列后向特征选择(SBE)</h3><p>序列向前算法，特征子集从空集开始，每次只加入一个特征，</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="退火算法"><a href="#退火算法" class="headerlink" title="退火算法"></a>退火算法</h3><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>遗传算法步骤：</p><p>1、初始化种群</p><p>一个种群有好几条染色体，假设有m个初始特征，那么染色体为一个m*1的一维向量[0,1,0,1,….1]，全部由0或者1组成，初始化时，0和1随机选择。</p><p>2、评估种群中个体适合度</p><p>用交叉检验cross_val_score(个体，y)的结果作为适应度。适应度计算类似LDA</p><p>3、选择</p><p>每条染色体的适应度不同，被选择的概率也不同，用轮盘赌选择，先生成与染色体个数相同的随机数个数，先生成与染色体个数（种群大小）相同的随机数然后再一个个看这些随机数落在哪个染色体的范围内<br>例：<br>染色体的选择概率：①[0,0.3), ②[0.3,0.6), ③[0.6,0.7), ④[0.7,0.9), ⑤[0.9,1]<br>生成的随机数：0.2, 0.4, 0.5, 0.78, 0.8<br>被选中的染色体：①, ②, ②, ④, ④</p><p>5、交叉</p><p>若第i条与第i+1条染色体发生交叉，随机选择交叉点，然后交叉。</p><p>例如</p><p>父染色体 </p><p>a:<font color="red">[0,1,0,0,1]</font></p><p>b:[1,0,1,1,1]</p><p>交叉之后的染色体为[<font color="red">0,1,0</font>,1,1]</p><p>6、变异</p><p>染色体的某个点取反。目的是防止局部最优</p><h3 id="蚁群算法"><a href="#蚁群算法" class="headerlink" title="蚁群算法"></a>蚁群算法</h3><p>蚁群算法的基本思想：</p><p>1、蚂蚁在路径上释放信息素。</p><p>2、碰到还没走过的路口，就随机挑选一条路走。同时，释放与路径长度有关的信息素。</p><p>3、信息素浓度与路径长度成反比。后来的蚂蚁再次碰到该路口时，就选择信息素浓度较高路径。</p><p>4、最优路径上的信息素浓度越来越大。</p><p>5、最终蚁群找到最优寻食路径。</p><h1 id="嵌入方法Embedded"><a href="#嵌入方法Embedded" class="headerlink" title="嵌入方法Embedded"></a>嵌入方法Embedded</h1><p>嵌入方法将特征选择嵌入到模型的构建过程当中，具有封装方法与机器学习方法相结合的有点，而且具有过滤方法计算效率高的有点，避免了前面两种方法的不足。</p><h2 id="LASSO方法"><a href="#LASSO方法" class="headerlink" title="LASSO方法"></a>LASSO方法</h2><p>及线性回归+L1范数，具体原理就不细讲了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"></span><br><span class="line">boston = load_boston()</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X = scaler.fit_transform(boston[<span class="string">"data"</span>])</span><br><span class="line">Y = boston[<span class="string">"target"</span>]</span><br><span class="line">names = boston[<span class="string">"feature_names"</span>]</span><br><span class="line"></span><br><span class="line">lasso = Lasso(alpha=<span class="number">.3</span>)</span><br><span class="line">lasso.fit(X, Y)</span><br></pre></td></tr></table></figure><h2 id="基于树模型的特征选择"><a href="#基于树模型的特征选择" class="headerlink" title="基于树模型的特征选择"></a>基于树模型的特征选择</h2><p>树模型本身可以进行特征选择，配合sklearn中的SelectFromModel可以进行特征选择。</p><p>1、结合SelectFromModel</p><p>SelectFromModel的作用是训练基础模型，得到系数较高的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">gbdt = GradientBoostingClassifier()</span><br><span class="line">SelectFromModel(gbdt).fit_transform(iris.data,iris.target)</span><br></pre></td></tr></table></figure><p>2、结合相关系数</p><p>主要分为一下几步：</p><ul><li>第一次训练lightGBM，得到特征重要性</li><li>挑选重要性比较高的特征，计算特征相似度，热力图也行</li><li>筛选掉相似度过高的特征</li><li>将筛选之后的特征送入lightGBM重新训练</li></ul><p>参考资料</p><p>1、<a href="https://www.cnblogs.com/hhh5460/p/5186226.html" target="_blank" rel="noopener">https://www.cnblogs.com/hhh5460/p/5186226.html</a></p><p>2、<a href="https://www.kaggle.com/juliaflower/feature-selection-lgbm-with-python/comments" target="_blank" rel="noopener">https://www.kaggle.com/juliaflower/feature-selection-lgbm-with-python/comments</a></p><p>3、美团机器学习实践</p><p>4、<a href="https://blog.csdn.net/u012017783/article/details/71872950" target="_blank" rel="noopener">https://blog.csdn.net/u012017783/article/details/71872950</a></p><p>5、<a href="https://www.cnblogs.com/holaworld/p/12631851.html" target="_blank" rel="noopener">https://www.cnblogs.com/holaworld/p/12631851.html</a></p><p>6、<a href="https://zhuanlan.zhihu.com/p/33042667" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33042667</a></p><p>7、<a href="https://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="noopener">https://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html</a></p><p>8、<a href="https://www.cnblogs.com/holaworld/p/12631933.html" target="_blank" rel="noopener">https://www.cnblogs.com/holaworld/p/12631933.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/geroge-gao/Images/master/特征选择/捕获.PNG&quot; alt&gt;&lt;/p&gt;&lt;p&gt;特征选择，即对于生成的特征集合进行筛选，得到一个子集，主要有一下三个目的&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;简化模型，增加可解释性&lt;/li&gt;
&lt;li&gt;改善性能，并且节省存储空间和计算开销&lt;/li&gt;
&lt;li&gt;改善通用性，降低过拟合风险。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特征选择主要分为三种方法，过滤方法、封账方法和嵌入方法&lt;/p&gt;&lt;h1 id=&quot;过滤方法Filter&quot;&gt;&lt;a href=&quot;#过滤方法Filter&quot; class=&quot;headerlink&quot; title=&quot;过滤方法Filter&quot;&gt;&lt;/a&gt;过滤方法Filter&lt;/h1&gt;&lt;p&gt;过滤方法主要特点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;不依赖与机器学习算法&lt;/li&gt;
&lt;li&gt;一般分为单变量和多变量&lt;/li&gt;
&lt;li&gt;单变量一般基于特征变量与目标变量之间的相关性或互信息，根据相关性排序，过滤掉最不相关特征&lt;/li&gt;
&lt;li&gt;多变量有基于相关性和一致性的特征选择&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="特征选择" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>特征工程之特征构建</title>
    <link href="http://yoursite.com/2020/07/11/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E5%BE%81%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/07/11/特征工程之特征构建/</id>
    <published>2020-07-11T14:00:53.000Z</published>
    <updated>2020-08-29T15:39:07.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类别特征"><a href="#类别特征" class="headerlink" title="类别特征"></a>类别特征</h1><ul><li>几乎总是需要做一些处理</li><li>类别特征种类过多会造成稀疏数据</li><li>难以填充缺失值</li></ul><h2 id="热独编码-Onehot-encoding"><a href="#热独编码-Onehot-encoding" class="headerlink" title="热独编码(Onehot-encoding)"></a>热独编码(Onehot-encoding)</h2><ul><li>通常和大多数线性算法一起使用</li><li>稀疏格式对内存友好</li><li>大多数方法无法处理缺失或者不可见数据</li><li>对于没有大小区分的类别特征，可以使用Oneshot-encoding</li></ul><h2 id="哈希编码-Hash-encoding"><a href="#哈希编码-Hash-encoding" class="headerlink" title="哈希编码(Hash encoding)"></a>哈希编码(Hash encoding)</h2><a id="more"></a><ul><li>固定长度的oneHot-encoding</li><li>避免数据过度稀疏</li><li>碰撞通常会降低准确率，但是也能提高</li><li>可以很好地处理新变量</li></ul><p>Label encoding</p><ul><li>给每个类别变量一个唯一的数字ID</li><li>对于非线性树模型比较有用</li><li>不会增加数据维度</li><li>随机化映射 car_var-&gt;num_id的映射，在训练，平均，对精度能有小提升(小提升)</li></ul><h2 id="计数编码-Count-encoding"><a href="#计数编码-Count-encoding" class="headerlink" title="计数编码(Count encoding)"></a>计数编码(Count encoding)</h2><ul><li>在训练集中用他们的统计量替代类别特征</li><li>对于线性和非线性算法都有用</li><li>对于异常值很敏感</li><li>增加log转换，对于统计量可能更好</li><li>用1替代无法观测数据</li><li>可能会造成冲突，同一个编码，不同的变量值</li></ul><h2 id="计数排名编码-LabelCount-encoding"><a href="#计数排名编码-LabelCount-encoding" class="headerlink" title="计数排名编码(LabelCount encoding)"></a>计数排名编码(LabelCount encoding)</h2><ul><li>通过统计量给类别特征排序</li><li>对于线性和非线性算法都有用</li><li>对异常值不敏感</li><li>不会给同一个变量不同的值</li></ul><h2 id="Category-Embedding"><a href="#Category-Embedding" class="headerlink" title="Category Embedding"></a>Category Embedding</h2><ul><li>使用神经网络对类别特征创建一个稠密的embeddings，找到不同类别特征关联性</li></ul><p>NaN encoding：</p><ul><li>给NaN 值一个明确的编码，而不是忽略</li><li>NaN里面也包含信息</li><li>小心过拟合</li><li>仅仅当训练集和测试集NaN都是同样的原因造成，或者本地验证结果证明NaN包含信息(即这种方法是有效果的)</li></ul><h1 id="数字特征"><a href="#数字特征" class="headerlink" title="数字特征"></a>数字特征</h1><ul><li>对于算法更可读</li><li>很容易填补缺失值</li></ul><h2 id="截断-Rounding"><a href="#截断-Rounding" class="headerlink" title="截断(Rounding)"></a>截断(Rounding)</h2><ul><li>对数字变量四舍五入</li><li>有损压缩，保留数据最重要的特征</li><li>有时候精度太准确只是噪声</li><li>四舍五入后的变量能够当成类别特征处理</li><li>在四舍五入之前可以进行log转换</li></ul><h2 id="分桶-Binning"><a href="#分桶-Binning" class="headerlink" title="分桶(Binning)"></a>分桶(Binning)</h2><ul><li>对数据进行分桶，并且赋予一个分桶ID</li><li>分桶能够使用分位数或者模型来找到最佳分桶</li><li>能够很好地处理超出训练集范围的数据</li></ul><p>分桶的作用，当一个特征的数值比较大，但是模型对数值比较敏感的时候，最好的方法是分桶，将数值变量分配到一个桶里。</p><h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放(Scaling)"></a>缩放(Scaling)</h2><ul><li>将数字变量缩放到一个明确的范围</li><li>Standard(Z) Scaling</li><li>MinMax Scaling</li><li>Root Scaling</li><li>Log Scaling</li></ul><p>原因：因为部分模型例如线性回归、逻辑回归等对于数据输入比较敏感将数值缩放到一个维度，</p><ul><li>标准化Standarisation和归一化Normalisation</li><li>归一化的原因<ul><li>当变量维度不同的时候，对模型产生的作用不一致，这时候需要归一化</li><li>神经网络在特征缩放之后训练速度更快</li></ul></li><li>特征缩放的时机<ul><li>KNN</li><li>K-means</li><li>NN</li></ul></li><li>树模型不需要特征缩放</li></ul><h2 id="填充-Imputation"><a href="#填充-Imputation" class="headerlink" title="填充(Imputation)"></a>填充(Imputation)</h2><ul><li>对缺失值进行填充</li><li>硬编码能够和填充结合起来</li><li>Mean：最常见的</li><li>Median：对于异常值更有鲁棒性</li><li>Igonre：忽略，后面在处理或者不处理？</li><li>使用模型对结果进行预测，然后填充</li></ul><h2 id="交叉-Interaction"><a href="#交叉-Interaction" class="headerlink" title="交叉(Interaction)"></a>交叉(Interaction)</h2><ul><li>对数字变量之间的相互影响进行编码</li><li>尝试加减乘除</li><li>使用特征选择：统计测试、或者已经训练好的特征重要性</li><li>忽略主观意愿和奇怪的关联能够有明显提升</li></ul><h2 id="高斯转换"><a href="#高斯转换" class="headerlink" title="高斯转换"></a>高斯转换</h2><ul><li>一些机器学习模型假设数据是正态分布的，例如linear和logistic回归</li><li>高斯分布能够帮助机器学习下模型表现得更好</li><li>集中不同的转换<ul><li>Logarithmic Transformation</li><li>Reciprocal Transformation</li><li>Square Root Transformation</li><li>Exponential Transformation</li><li>Boxcox Transformation</li></ul></li><li></li></ul><p>相关问题：</p><p>1.为什么要做对数变换</p><p><a href="https://www.zhihu.com/question/22012482" target="_blank" rel="noopener">https://www.zhihu.com/question/22012482</a></p><p><a href="https://tianchi.aliyun.com/notebook-ai/detail?postId=62338" target="_blank" rel="noopener">https://tianchi.aliyun.com/notebook-ai/detail?postId=62338</a></p><h2 id="异常值-Outlier"><a href="#异常值-Outlier" class="headerlink" title="异常值(Outlier)"></a>异常值(Outlier)</h2><p>1、异常点是否需要清除，需要结合具体业务</p><p>2、异常点的定义</p><ul><li><p>高于1.5倍的第三分位数和第一分位数之差</p></li><li><p>与均值的差小于三倍的标准差</p></li></ul><p>3、异常值存在的原因</p><ul><li>数据多样性</li><li>测量错误</li></ul><p>4、异常点的影响</p><ul><li>在统计分析的时候造成多种问题</li><li>对于数据均值和标准差影响比较大</li></ul><p>5、找出异常值</p><ul><li>IQR</li><li>z score</li><li>Scatter plots</li><li>Box plot</li></ul><h1 id="时间特征"><a href="#时间特征" class="headerlink" title="时间特征"></a>时间特征</h1><ul><li><p>日起相关特征，节假日之类</p></li><li><p>lag feature，根据业务决定选择lag1、lag2、。。。。</p><p>检查lag函数重要性两种方法</p><ul><li>ACF，Autocorrelation Function</li><li>PACF, Partial Autocorrelation Function</li></ul></li><li><p>rolling windows 滑动窗口</p></li><li><p>Expanding windows</p></li></ul><h1 id="空间特征"><a href="#空间特征" class="headerlink" title="空间特征"></a>空间特征</h1><ul><li>欧氏距离</li><li>球面距离</li><li>曼哈顿距离</li><li>geohash</li></ul><h1 id="文本特征"><a href="#文本特征" class="headerlink" title="文本特征"></a>文本特征</h1><h2 id="N-Gram"><a href="#N-Gram" class="headerlink" title="N-Gram"></a>N-Gram</h2><p>N-Gram是一种基于统计语言模型的算法。它的基本思想是将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。</p><p>每一个字节片段称为gram，对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。</p><p>该模型基于这样一种假设，第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计N个词同时出现的次数得到。常用的是二元的Bi-Gram和三元的Tri-Gram。</p><h2 id="词袋模型"><a href="#词袋模型" class="headerlink" title="词袋模型"></a>词袋模型</h2><p>词袋模型可以理解为将文本拆成一个个的词语，然后用一个个词作为字典来表达文本 ，字典中的词没有特定的顺序，也舍弃了句子总体结构。其中TF-IDF是一种表示方式</p><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度</p><p>TF-IDF的核心思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TF-IDF实际上是：TF*IDF。TF是词频(Term Frequency)，指的是特定词语在该文件中出现的频率。</p><script type="math/tex; mode=display">tf_{i,j}=\frac{n_{i,j}}{\sum_{k}n_{n,j}}</script><p>其中$tf_{i,j}$表示词i出现在文章j中的次数，分母表示文章j中出现档次数量总和。</p><p>IDF是逆文本频率指数(Inverse Document Frequency)。IDF的意思是在文档集D中，包含词i的数量越少，词i对于文档集越重要，此时更好区分。</p><script type="math/tex; mode=display">idf_i=log\frac{|D|}{|{j:t_i\in d_j}|}</script><p>$|D|$表示所有文档数量，文档集中出现此$t_i$的文档数。</p><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><h2 id="Jaccard相似度"><a href="#Jaccard相似度" class="headerlink" title="Jaccard相似度"></a>Jaccard相似度</h2><p>定义：两个文档中相交的单词个数除以两个文档单词总数之和</p><script type="math/tex; mode=display">J(d_1,d_2)=\frac{|d_1\cap d2|}{|d1 \cup d2|}</script><p>Jaccard距离</p><script type="math/tex; mode=display">d_j(d_1,d_2)=1-J(d_1,d_2)=\frac{|d_1\cup d2| - |d_1 \cap d_2|}{|d_1\cup d_2|}</script><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>衡量两个字符串相似度的指标，指的是两个字符串有一个字符串转成另外一个字符串需要的最少编辑操作(插入、删除、替换)次数</p><h1 id="推荐系统中的特征工程"><a href="#推荐系统中的特征工程" class="headerlink" title="推荐系统中的特征工程"></a>推荐系统中的特征工程</h1><p>推荐系统中特征工程主要分为以下几个部分</p><ul><li>用户行为数据</li><li>用户关系数据</li><li>属性标签数据，类似性别年龄、爱好等</li><li>内容数据(多模态,通过cv、nlp等技术识别图片和文本中的信息)</li><li>上下文信息，时间、地点、重大事件等。</li><li>统计类特征</li><li>组合特征</li></ul><p>参考资料</p><p>1、<a href="https://www.kaggle.com/pavansanagapati/feature-engineering-a-comprehensive-tutorial/notebook" target="_blank" rel="noopener">https://www.kaggle.com/pavansanagapati/feature-engineering-a-comprehensive-tutorial/notebook</a></p><p>2、美团机器学习实践</p><p>3、<a href="https://www.jiqizhixin.com/graph/technologies/87c62b00-48b2-4e2a-8122-9876a3d3e59e" target="_blank" rel="noopener">词袋模型</a></p><p>4、百面机器学习</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类别特征&quot;&gt;&lt;a href=&quot;#类别特征&quot; class=&quot;headerlink&quot; title=&quot;类别特征&quot;&gt;&lt;/a&gt;类别特征&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;几乎总是需要做一些处理&lt;/li&gt;
&lt;li&gt;类别特征种类过多会造成稀疏数据&lt;/li&gt;
&lt;li&gt;难以填充缺失值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;热独编码-Onehot-encoding&quot;&gt;&lt;a href=&quot;#热独编码-Onehot-encoding&quot; class=&quot;headerlink&quot; title=&quot;热独编码(Onehot-encoding)&quot;&gt;&lt;/a&gt;热独编码(Onehot-encoding)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通常和大多数线性算法一起使用&lt;/li&gt;
&lt;li&gt;稀疏格式对内存友好&lt;/li&gt;
&lt;li&gt;大多数方法无法处理缺失或者不可见数据&lt;/li&gt;
&lt;li&gt;对于没有大小区分的类别特征，可以使用Oneshot-encoding&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;哈希编码-Hash-encoding&quot;&gt;&lt;a href=&quot;#哈希编码-Hash-encoding&quot; class=&quot;headerlink&quot; title=&quot;哈希编码(Hash encoding)&quot;&gt;&lt;/a&gt;哈希编码(Hash encoding)&lt;/h2&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="特征工程" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="特征构造" scheme="http://yoursite.com/tags/%E7%89%B9%E5%BE%81%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>word embedding作用及用法</title>
    <link href="http://yoursite.com/2020/06/07/word-embedding%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/07/word-embedding作用及用法/</id>
    <published>2020-06-07T08:00:38.000Z</published>
    <updated>2020-06-11T13:50:02.589Z</updated>
    
    <content type="html"><![CDATA[<p>关于word embedding总结</p><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><p>表示词语的向量都可以称为词向量，one shot向量和distributed向量都可以表示为词向量</p><h2 id="热编码表示-one-shot"><a href="#热编码表示-one-shot" class="headerlink" title="热编码表示(one shot)"></a>热编码表示(one shot)</h2><p>优点</p><ul><li>解决了分类器不好解决离散数据的问题，</li><li>起到了扩充特征的作用</li></ul><p>缺点：</p><ul><li>首先，它是一个词袋模型，不考虑词与词之间的顺序(文本中词的顺序信息非常重要)</li><li>其次假设词与词之间是独立的(大多数情况下，词与词之间是相互影响的)</li><li>最后得到的特征是系数的</li></ul><a id="more"></a><h2 id="分布式表示"><a href="#分布式表示" class="headerlink" title="分布式表示"></a>分布式表示</h2><p><strong>核心思想</strong></p><p>通过训练将某种语言中的每一个词映射成一个固定长度的短向量（当然这里的“短”是相对于 one-hot representation 的“长”而言的），将所有这些向量放在一起形成一个词向量空间，而每一向量则为该空间中的一个点，在这个空间上引入“距离”，则可以根据词之间的距离来判断它们之间的（词法、语义上的）相似性了。</p><h3 id="基于矩阵的分布表示"><a href="#基于矩阵的分布表示" class="headerlink" title="基于矩阵的分布表示"></a>基于矩阵的分布表示</h3><h3 id="基于聚类的分布表示"><a href="#基于聚类的分布表示" class="headerlink" title="基于聚类的分布表示"></a>基于聚类的分布表示</h3><h3 id="基于神经网络的分布表示"><a href="#基于神经网络的分布表示" class="headerlink" title="基于神经网络的分布表示"></a>基于神经网络的分布表示</h3><p>1、基本概念</p><p>基于神经网络的分布表示一般称为word embedding(词嵌入)或者distributed representation</p><p>2、word2vec</p><p>两种方式</p><p>CBOW:输入一个词上下文，输出这个词</p><p>Skip-Gram：输入一个词输出这个词的上下文</p><p>embedding layer：和word2vec一样</p><h2 id="embedding-layer和word2vec"><a href="#embedding-layer和word2vec" class="headerlink" title="embedding layer和word2vec"></a>embedding layer和word2vec</h2><ul><li></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://blog.csdn.net/scotfield_msn/article/details/69075227" target="_blank" rel="noopener">DeepNLP的表示学习·词嵌入来龙去脉·深度学习（Deep Learning）·自然语言处理（NLP）·表示（Representation）</a></p><p>2、<a href="https://www.cnblogs.com/peghoty/p/3857839.html" target="_blank" rel="noopener">word2vec 中的数学原理详解</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">秒懂词向量本质</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于word embedding总结&lt;/p&gt;&lt;h2 id=&quot;词向量&quot;&gt;&lt;a href=&quot;#词向量&quot; class=&quot;headerlink&quot; title=&quot;词向量&quot;&gt;&lt;/a&gt;词向量&lt;/h2&gt;&lt;p&gt;表示词语的向量都可以称为词向量，one shot向量和distributed向量都可以表示为词向量&lt;/p&gt;&lt;h2 id=&quot;热编码表示-one-shot&quot;&gt;&lt;a href=&quot;#热编码表示-one-shot&quot; class=&quot;headerlink&quot; title=&quot;热编码表示(one shot)&quot;&gt;&lt;/a&gt;热编码表示(one shot)&lt;/h2&gt;&lt;p&gt;优点&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;解决了分类器不好解决离散数据的问题，&lt;/li&gt;
&lt;li&gt;起到了扩充特征的作用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;首先，它是一个词袋模型，不考虑词与词之间的顺序(文本中词的顺序信息非常重要)&lt;/li&gt;
&lt;li&gt;其次假设词与词之间是独立的(大多数情况下，词与词之间是相互影响的)&lt;/li&gt;
&lt;li&gt;最后得到的特征是系数的&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="词向量" scheme="http://yoursite.com/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>lightGBM论文总结</title>
    <link href="http://yoursite.com/2020/03/10/xgboost%E5%92%8ClightGBM/"/>
    <id>http://yoursite.com/2020/03/10/xgboost和lightGBM/</id>
    <published>2020-03-10T11:11:12.000Z</published>
    <updated>2020-03-20T09:38:20.507Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/优化点.PNG" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG"></p><h2 id="LightGBM提出动机"><a href="#LightGBM提出动机" class="headerlink" title="LightGBM提出动机"></a>LightGBM提出动机</h2><p>为了解决GBDT在海量数据中遇到的问题，让GBDT算法更好的适用于工业实践。</p><p>1、XGBoost的缺点</p><ul><li>需要保存特征值和排序结果，还需要保存排序的索引</li><li>每次分裂一个点的时候，都需要计算收益</li><li>对cache优化不友好，容易造成cache miss</li></ul><p>2、LightGBM的优化</p><ul><li>单边梯度采样GOSS</li><li>直方图算法</li><li>互斥特征捆绑算法</li><li>Leaf-Wise分裂算法</li><li>类别特征最有分裂</li><li>并行学习优化</li><li>cache命中率优化</li></ul><a id="more"></a><h2 id="2-数据原理"><a href="#2-数据原理" class="headerlink" title="2. 数据原理"></a>2. 数据原理</h2><h3 id="2-1-基于直方图的算法"><a href="#2-1-基于直方图的算法" class="headerlink" title="2.1.基于直方图的算法"></a>2.1.基于直方图的算法</h3><p>对于XGBoost，其实现是预排序算法，LiggtGBM是基于直方图的算法。</p><p>  <img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/直方图算法.jpg" alt></p><p>直方图算法计算过程</p><ul><li>遍历每一个叶子结点的每一个特征</li><li>为每一个特征创建一个直方图，将样本的梯度($g_i$)之和和样本数$n$保存到bin中</li><li>然后遍历所有的bin，以当前的bin作为分裂点，然后计算分裂后的左右节点梯度和节点数目</li><li>通过直方图加速法算出左右节点的梯度和$S_L$和$S_R$，已经bin的数量</li><li>计算分裂后的收益$loss=\frac{S_L^2}{n_L}+\frac{S_R^2}{n_R}-\frac{S_P^2}{n_p}$</li></ul><p>其实，思想和xgb差不多，在选择分裂点的时候，xgb用的是预排序算法，lgb用的是梯度直方图。</p><p>然后在计算上的代价也大幅降低，预排序算法每遍历一个特征值就需要计算一次分裂的增益，而直方图算法只需要计算k次（k可以认为是常数），时间复杂度从O(#data<em>#feature)优化到O(k</em>#features)。</p><p>直方图离散化优点：</p><ul><li>占用内存更小，相对于XGBoost预排序算法，无需存储特征值和排序索引</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/8-bit.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG"></p><ul><li>计算代价更小，预排序算法需要每遍历一个特征值，就计算一次收益，而直方图算法只用计算K次，时间复杂度有O(data <em> feature)下降到O(k </em> feature)</li></ul><p>当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p><h3 id="2-2-单边梯度采样GOSS"><a href="#2-2-单边梯度采样GOSS" class="headerlink" title="2.2 单边梯度采样GOSS"></a>2.2 单边梯度采样GOSS</h3><p>对于GBDT的数据，梯度越大，说明训练误差越大，这样的样本对模型的提升也越大(adaboost思想)，因此GOSS的算法的思想是保留梯度交大的样本，然后在剩余梯度较小的样本中进行采样。不直接丢掉梯度较小的样本数据的原因是会影响数据总体分布。</p><p>具体流程    </p><ul><li>首先将分裂的特征按照绝对值大小进行排序</li><li>选择梯度最大的a%的数据</li><li>在剩余的数据中随机挑选b%个数据</li><li>然后对于梯度较小的数据，乘以1个常数$\frac{1-a}{b}$</li><li>最后将挑选出来的数据进行合并，计算信息增益</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/单边梯度采样.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG"></p><h3 id="2-3-互斥特征捆绑算法"><a href="#2-3-互斥特征捆绑算法" class="headerlink" title="2.3 互斥特征捆绑算法"></a>2.3 互斥特征捆绑算法</h3><p>互斥捆绑算法的目的是为了减少特征维度，因为实际任务中，特征一般是高维稀疏的。</p><ul><li><p>对于完全互斥的特征，可以将其捆绑起来，例如one-shot产生的特征，捆绑之后不会造成信息丢失。</p></li><li><p>对于不完全互斥的特征，存在部分情况下两个特征都为非0值，可以使用<strong><em>冲突比率</em></strong>（同时不为0的样本数之和/所有样本数）对不互斥程度进行衡量，当小于一定值时，可以将两个不完全互斥的特征捆绑。</p></li></ul><p>对于特征捆绑，有两个问题</p><p>1、如何确定哪些特征需要绑在一起</p><p>2、如何构建绑定后的特征</p><p>对于第一个问题，确定那些问题需要绑定，LightGBM的做法如下</p><p>1、构建一个无向加权图，顶点表示特征，边的权值大小表示冲突比率</p><p>2、基于特征在图中的度数进行降序排序</p><p>3、遍历每个捆绑特征，检查捆绑之后特征数是否小于最大冲突数</p><ul><li>冲突数小于K，将该特征添加到捆绑</li><li>冲突数大于K，创建新的捆绑特征</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/EFB.png" alt></p><p>对于第二个问题，如何构建绑定后的特征，关键在于如何从绑定后的特征识别出原始特征中的值。基于直方图算法存储的是离散的箱子，而不是连续的特征值。LightGBM是基于特征从属于不同的箱子来构建捆绑特征的。假设特征A的原始特征取值空间为[0,10),特征B的取值空间为[0,20)，当 此时可以在特征B的区间上加上偏置10，此时B的取值空间为[10,20)，而AB绑定后的特征取值空间为[0,30)。</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/特征绑定.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E7%89%B9%E5%BE%81%E7%BB%91%E5%AE%9A.png"></p><p>EFB算法可以将很多互斥稀疏特征捆绑成少量稠密特征，避免针对特征值0的不必要计算。虽然可以优化基于直方图的算法，使用一张表保存每个特征非0取值，然后通过扫描这张表来构建直方图，这样时间复杂度就从原来的O(data)变成了O(no_zero_data)，缺点在于需要额外的算力和空间保存和更新这张表。LGB将其作为辅助功能。</p><h3 id="2-4-Leaf-Wise分裂算法"><a href="#2-4-Leaf-Wise分裂算法" class="headerlink" title="2.4 Leaf-Wise分裂算法"></a>2.4 Leaf-Wise分裂算法</h3><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/leaf_wise.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG"></p><h3 id="2-5-类别特征最优分裂"><a href="#2-5-类别特征最优分裂" class="headerlink" title="2.5 类别特征最优分裂"></a>2.5 类别特征最优分裂</h3><p>这部分没怎么看懂，参考的</p><ul><li>离散特征建立直方图的过程：统计该特征下每一种离散值出现的次数，并从高到低排序，并过滤掉出现次数较少的特征值, 然后为每一个特征值，建立一个bin容器, 对于在bin容器内出现次数较少的特征值直接过滤掉，不建立bin容器。</li><li>计算分裂阈值的过程：<ul><li>先看该特征下划分出的bin容器的个数，如果bin容器的数量小于4，直接使用one vs other方式, 逐个扫描每一个bin容器，找出最佳分裂点;</li><li>对于bin容器较多的情况, 先进行过滤，只让子集合较大的bin容器参加划分阈值计算, 对每一个符合条件的bin容器进行公式计算(公式如下: 该bin容器下所有样本的一阶梯度之和/该bin容器下所有样本的二阶梯度之和 + 正则项(参数cat_smooth)，这里为什么不是label的均值呢？其实上例中只是为了便于理解，只针对了学习一棵树且是回归问题的情况， 这时候一阶导数是Y, 二阶导数是1)， </li></ul></li></ul><h2 id="3-工程优化"><a href="#3-工程优化" class="headerlink" title="3 工程优化"></a>3 工程优化</h2><h3 id="3-1-并行学习优化"><a href="#3-1-并行学习优化" class="headerlink" title="3.1 并行学习优化"></a>3.1 并行学习优化</h3><p>LightGBM 提供以下并行学习优化算法：</p><h4 id="特征并行"><a href="#特征并行" class="headerlink" title="特征并行"></a><a href="https://lightgbm.apachecn.org/#/docs/4?id=特征并行" target="_blank" rel="noopener">特征并行</a></h4><p>适用于数据量比较少，feature比较多</p><p>传统的特征并行算法旨在于在并行化决策树中的“ <code>Find Best Split</code>.主要流程如下:</p><ol><li>垂直划分数据（不同的机器有不同的特征集）</li><li>在本地特征集寻找最佳划分点 {特征, 阈值}</li><li>本地进行各个划分的通信整合并得到最佳划分</li><li>以最佳划分方法对数据进行划分，并将数据划分结果传递给其他线程</li><li>其他线程对接受到的数据进一步划分</li></ol><p>然而，该特征并行算法在数据量很大时仍然存在计算上的局限。因此，建议在数据量很大时使用数据并行。</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/feature-parallelization.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG"></p><h4 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a><a href="https://lightgbm.apachecn.org/#/docs/4?id=数据并行" target="_blank" rel="noopener">数据并行</a></h4><p>适用于大数据，feature比较少</p><p>数据并行旨在于并行化整个决策学习过程。数据并行的主要流程如下：</p><ol><li>水平划分数据</li><li>线程以本地数据构建本地直方图</li><li>将本地直方图整合成全局整合图</li><li>在全局直方图中寻找最佳划分，然后执行此划分</li></ol><p>数据并行的缺点</p><ul><li>机器的通讯开销大约为 “O(#machine <em> #feature </em> #bin)” 。 如果使用集成的通讯算法（例如， “All Reduce”等），通讯开销大约为 “O(2 <em> #feature </em> #bin)”[8] 。</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/data-parallelization-1024x414.png" alt></p><h4 id="投票并行"><a href="#投票并行" class="headerlink" title="投票并行"></a><a href="https://lightgbm.apachecn.org/#/docs/4?id=投票并行" target="_blank" rel="noopener">投票并行</a></h4><p>大数据并且feature比较多</p><p>基于投票的并行是对于数据并行的优化，主要分为两步：</p><ul><li>通过本地数据，找到本地top k的特征</li><li>利用投票筛选出可能是全局最优点的特征</li><li>合并直方图时，只合并被选出来的部分</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/voting-based-parallel-1024x534.jpg" alt></p><h3 id="3-2-Cache命中率优化"><a href="#3-2-Cache命中率优化" class="headerlink" title="3.2 Cache命中率优化"></a>3.2 Cache命中率优化</h3><p>预排序算法：</p><ul><li>不同的特征访的梯度顺序不同</li><li>对于索引表的访问，pre_sort使用了行号和叶子节点的索引表</li><li>都是随机访问，容易造成cache miss</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/1.png" alt></p><p>lightGBM对直方图优化：</p><ul><li>梯度直方图不需要对梯度进行排序</li><li>直方图算法不需要数据到叶子id的索引表</li></ul><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/2.png" alt></p><h2 id="4-XGBoost和LightGBM区别"><a href="#4-XGBoost和LightGBM区别" class="headerlink" title="4 XGBoost和LightGBM区别"></a>4 XGBoost和LightGBM区别</h2><ul><li>xgboost是预排序算法，lightGBM是直方图算法。</li><li>分裂方式，xgb是level-wise，lgb是Leaf-Wise</li><li>lgb支持类别特征</li><li>采用了单边梯度采样和互信息捆绑进行优化</li><li>并行化，feature在节点进行分裂的时候采用了多线程并行化，而lgb采用了特征并行、数据并行、投票并行</li><li>基于分裂算法的不同，lgb对cache命中更加高效</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://cloud.tencent.com/developer/article/1528372" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1528372</a></p><p>2、<a href="https://mp.weixin.qq.com/s/M25d_43gHkk3FyG_Jhlvog" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/M25d_43gHkk3FyG_Jhlvog</a></p><p>3、<a href="https://www.biaodianfu.com/lightgbm.html" target="_blank" rel="noopener">https://www.biaodianfu.com/lightgbm.html</a></p><p>4、<a href="https://www.zhihu.com/question/266195966" target="_blank" rel="noopener">https://www.zhihu.com/question/266195966</a></p><p>5、<a href="https://lightgbm.apachecn.org/#/docs/4" target="_blank" rel="noopener">https://lightgbm.apachecn.org/#/docs/4</a></p><p>6、<a href="https://blog.csdn.net/anshuai_aw1/article/details/83040541" target="_blank" rel="noopener">直方图算法深入理解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/优化点.PNG&quot; alt=&quot;https://raw.githubusercontent.com/geroge-gao/Images/master/lightGBM/%E4%BC%98%E5%8C%96%E7%82%B9.PNG&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;LightGBM提出动机&quot;&gt;&lt;a href=&quot;#LightGBM提出动机&quot; class=&quot;headerlink&quot; title=&quot;LightGBM提出动机&quot;&gt;&lt;/a&gt;LightGBM提出动机&lt;/h2&gt;&lt;p&gt;为了解决GBDT在海量数据中遇到的问题，让GBDT算法更好的适用于工业实践。&lt;/p&gt;&lt;p&gt;1、XGBoost的缺点&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;需要保存特征值和排序结果，还需要保存排序的索引&lt;/li&gt;
&lt;li&gt;每次分裂一个点的时候，都需要计算收益&lt;/li&gt;
&lt;li&gt;对cache优化不友好，容易造成cache miss&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、LightGBM的优化&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;单边梯度采样GOSS&lt;/li&gt;
&lt;li&gt;直方图算法&lt;/li&gt;
&lt;li&gt;互斥特征捆绑算法&lt;/li&gt;
&lt;li&gt;Leaf-Wise分裂算法&lt;/li&gt;
&lt;li&gt;类别特征最有分裂&lt;/li&gt;
&lt;li&gt;并行学习优化&lt;/li&gt;
&lt;li&gt;cache命中率优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="决策树" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
      <category term="Xgboost" scheme="http://yoursite.com/tags/Xgboost/"/>
    
      <category term="lightGBM" scheme="http://yoursite.com/tags/lightGBM/"/>
    
  </entry>
  
  <entry>
    <title>XGBoost原理总结</title>
    <link href="http://yoursite.com/2020/03/09/XGBoost%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/09/XGBoost原理总结/</id>
    <published>2020-03-09T05:59:25.000Z</published>
    <updated>2020-03-20T09:15:45.091Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/a.png" alt></p><p>Xgboost, 是GBDT的一种实现方式，并且xgboost做了一些改进和优化。</p><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><h3 id="1-1-优化目标函数"><a href="#1-1-优化目标函数" class="headerlink" title="1.1 优化目标函数"></a>1.1 优化目标函数</h3><p>对于GBDT方法，都是基模型组成的加法公式。</p><script type="math/tex; mode=display">\hat y_i = \sum_{i=1}^kf_t(x_i)\tag{1}</script><p>其中$f_k$为基模型,$y_i$表示第$i$个样本预测值。</p><p>正则化损失函数</p><a id="more"></a><script type="math/tex; mode=display">\zeta^t=\sum_{i=1}^n l(y_i,\hat y_i^{(t-1)})+\Omega(f_t)\tag{2}</script><p>对于损失函数（2）进行二阶展开有：</p><script type="math/tex; mode=display">\zeta^{(t)} \approx  \sum_{i=1}^n[l(y_i,\hat y_i) +g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)\\ where\quad \Omega(f)=\gamma T+\frac{1}{2}\lambda||w||^2\tag{3}</script><p>对于损失函数，xgboost在处理的时候进行了二阶展开，其中$g_i=\frac{\partial l(y_i,\hat y_i^{(t-1)})}{\partial \hat y_i^{(t-1)}}$, $h_i=\frac{\partial ^2l(y_i,\hat y_i^{(t-1)})}{\partial (\hat y_i^{(t-1)})^2}$。其中$g_i$和$h_i$分别对应一阶倒和二阶倒数，正则项$T$表示叶子节点数目，$w$表示叶子的分数。$\gamma$空值叶子节点的个数，保证叶子节点不会过多分裂，而$\lambda$空值叶子结点的分值，避免分值过大造成过拟合。</p><p>对于第$t$步而言，前面的$t-1$步已经固定，因此有一阶、二阶梯度$g_i$和$h_i$为一个常数。因此目标函数可以化简为</p><script type="math/tex; mode=display">\hat \zeta^t=\sum_{i=1}^n[g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)\tag{4}</script><p>定义$I_j=\{x|q(x_i)=j\}$,表示为叶子结点$j$中的样本。所以上式(3)可以重写为</p><script type="math/tex; mode=display">\hat\zeta^{(t-1)}=\sum_{i=1}^n[g_if_t(x_i)+\frac{1}{2}h_if^2_t(x_i)]+\gamma T + \frac{1}{2}\lambda \sum_{j=1^T}w_j^2\tag{5}</script><script type="math/tex; mode=display">=\sum_{j=1}^T[(\sum_{i\in I_j}g_i)w_j+\frac{1}{2}(\sum_{i\in I_j}h_i+\lambda)w_j^2]+\gamma T \tag{6}</script><p>这里其实进行了一个转换，对于公式5而言，计算的损失函数是将所有数据得到损失函数。对于决策树，样本最终会落到叶子结点，因此公式6是通过叶子节点求损失值。</p><p>对于固定结构的$q(x)$，即改树节点时固定的，可以计算叶子结点$j$的最优权重$w_j^*$</p><script type="math/tex; mode=display">w_j^*=-\frac{2\sum_{i\in I_j}g_i}{\sum_{i\in I_j}h_i+\lambda}</script><p>将结果带入上式6有</p><script type="math/tex; mode=display">\hat \zeta^{(t)}=-\frac{1}{2} \sum_{j=1}^T\frac{(\sum_{i\in I_j}g_i)^2}{\sum_{i\in I_j}h_i+\lambda}\tag{7}</script><p>定$G_j=\sum_{i\in I_j}g_i$,$H_j=\sum_{i\in I_j}h_i$，则有</p><script type="math/tex; mode=display">w_j^*=-\frac{G_j}{H_j+\lambda}</script><p>将上式带入公式7化简有</p><script type="math/tex; mode=display">\zeta^{(t)}=-\frac{1}{2}\sum_{j=1}^T\frac{G_j^2}{H_j+\lambda}\tag{8}</script><p>对于Xgboost使用泰勒展开的原因是因为想统一损失函数的形式，方便自定义损失函数。</p><h3 id="1-2最佳切分点算法"><a href="#1-2最佳切分点算法" class="headerlink" title="1.2最佳切分点算法"></a>1.2最佳切分点算法</h3><p>xgboost支持两种实现，贪心算法和近似算法。sklearn中GBDT是贪心算法</p><p>1）贪心算法，和GBDT一样，暴力枚举</p><p>1、对于所有叶子节点枚举可用的特征，并且将特征值按照升序排序</p><p>2、计算节点分裂时候的收益</p><p>3、选择收益做大的节点和特征进行分裂</p><p>4、重复1，直到分裂结束</p><p>关键点在于对收益的计算</p><p>假设某一节点完成分裂，在分裂前，其目标函数为</p><script type="math/tex; mode=display">L(y,\hat y_i)=-\frac{1}{2}[\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}]+\gamma\tag{9}</script><p>分裂后的目标函数为</p><script type="math/tex; mode=display">L=-\frac{1}{2}[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}]+2\gamma\tag{10}</script><p>所以分裂一个节点的收益可以从用式（9）-（10）</p><script type="math/tex; mode=display">Gain=-\frac{1}{2}[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}]-\gamma</script><p>G表示所有叶子节点的梯度</p><p>2)近似算法</p><p>作用在于选择，当数据量比较大，无法全部读入内存时，给出近似最优解。对比贪心算法，可能在精度上有所缺失，但是提升了速度，降低了内存消耗。</p><p>该算法的核心思想是根据特征分布的分位数提出候选点，然后将特征映射到候选划分的桶之中，然后统计桶中的聚合信息(指的前面的$g$和$h$)，找到所有区间最佳分裂点。</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/近似算法.PNG" alt></p><p>1、对于特征k根据分位数找到候选集合</p><p>2、将样本映射到改候选集合对应的分区桶中</p><p>该算法有两种变体，区别在于何时剔除候选点：</p><ul><li>Global：在初始阶段就给出所有候选节点，并且在后续分裂中使用相同的分裂节点。</li><li>Local：每次分裂重新提出候选节点</li></ul><p>分位图</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/%E5%88%86%E4%BD%8D%E5%9B%BE.png" alt="123"></p><p>加权分位图：</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/加权分位图.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/%E5%8A%A0%E6%9D%83%E5%88%86%E4%BD%8D%E5%9B%BE.png"></p><p>由于前面我们知道目标函数为</p><script type="math/tex; mode=display">L=\sum_{i=1}^n[g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)\tag{11}</script><p>由于$g_i$和$h_i$是有上一轮迭代得到，因此都是常数，所以上式可以变形为：</p><script type="math/tex; mode=display">L\approx\sum_{i=1}^n\frac{1}{2}h_i[(f_t(x_i)+\frac{g_i}{h_i})^2]+\Omega(f_t)+C\\C=-\frac{g_i^2}{h_i}\tag{12}</script><p>这样损失函数就变成了加权的形式，因此对于每个样本，其实权值是不等的，所以采用加权分位图。</p><h3 id="1-3-稀疏感知分裂"><a href="#1-3-稀疏感知分裂" class="headerlink" title="1.3 稀疏感知分裂"></a>1.3 稀疏感知分裂</h3><p>在实际问题中，通常输入数据都是稀疏的，造成稀疏的原因有：</p><ul><li>数据缺失</li><li>一些统计量常常为0</li><li>特征工程的结果，如one-shot</li></ul><p>稀疏感知算法的目的是给每个节点一个默认的分裂方向，其思想非常简单，就是分别计算缺失值样本分裂到左边或者右边是的收益，选择收益大的一个分支作为最优缺省值方向</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/稀疏感知分裂.PNG" alt></p><h2 id="2-工程优化"><a href="#2-工程优化" class="headerlink" title="2. 工程优化"></a>2. 工程优化</h2><h3 id="2-1-块结构设计"><a href="#2-1-块结构设计" class="headerlink" title="2.1 块结构设计"></a>2.1 块结构设计</h3><p>树学习中最耗时的部分是数据排序。为了减少排序的成本，我们提出将数据存储在内存单元中，称之为block。每个block中的数据每列根据特征取值排序，并以压缩列（CSC）格式储存。这种输入数据布局只需要在训练前计算一次，可以在后续迭代中重复使用。</p><ul><li>每个块包含一个或者多个已经排好序的特征</li><li>缺失值将不在进行排序</li><li>每个特征值都会存储样本梯度统计值索引</li></ul><p>因为每个特征都是独立存放，因此在选择特征进行分裂的时候可以分布式实现</p><h3 id="2-2-缓存方法优化"><a href="#2-2-缓存方法优化" class="headerlink" title="2.2 缓存方法优化"></a>2.2 缓存方法优化</h3><p>算法是通过行索引提取梯度统计量，但是在排序之后就会乱掉，不能够直接访问。并且当统计量没法放进CPU缓存是，会导致访问失败，因此xgb给每个线程分配一个内部缓冲区。</p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/缓存优化.png" alt="https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96.png"></p><h3 id="2-3-核外快计算方式"><a href="#2-3-核外快计算方式" class="headerlink" title="2.3 核外快计算方式"></a>2.3 核外快计算方式</h3><p>对于数据量比较大的数据，没有办法存储到内存，可以考虑部分读取，将数据存储到硬盘，但是硬盘读取会占用大量时间</p><p>XGBoost采用两种方式降低硬盘读取开销</p><p>1、块压缩：对Block进行案列压缩，并且在读取时解压</p><p>2、块拆分：将每个块存储到不同的磁盘，然后从多个磁盘读取增加吞吐量。</p><h2 id="3-GBDT和XGBoost区别"><a href="#3-GBDT和XGBoost区别" class="headerlink" title="3. GBDT和XGBoost区别"></a>3. GBDT和XGBoost区别</h2><ul><li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。</li><li>传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li><li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li><li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）</li><li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。</li><li>对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。</li><li>xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</li><li>可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</li></ul><p>调参技巧略，直接看API就行了。。。。懒得总结了</p><p>参考资料</p><p>[1].<a href="https://www.zhihu.com/question/41354392/answer/98658997" target="_blank" rel="noopener">https://www.zhihu.com/question/41354392/answer/98658997</a></p><p>[2].<a href="https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ</a></p><p>[3].<a href="https://zhuanlan.zhihu.com/p/97753849" target="_blank" rel="noopener">行抽样、列抽样</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/geroge-gao/Images/master/Xgboost/a.png&quot; alt&gt;&lt;/p&gt;&lt;p&gt;Xgboost, 是GBDT的一种实现方式，并且xgboost做了一些改进和优化。&lt;/p&gt;&lt;h2 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 原理&quot;&gt;&lt;/a&gt;1. 原理&lt;/h2&gt;&lt;h3 id=&quot;1-1-优化目标函数&quot;&gt;&lt;a href=&quot;#1-1-优化目标函数&quot; class=&quot;headerlink&quot; title=&quot;1.1 优化目标函数&quot;&gt;&lt;/a&gt;1.1 优化目标函数&lt;/h3&gt;&lt;p&gt;对于GBDT方法，都是基模型组成的加法公式。&lt;/p&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\hat y_i = \sum_{i=1}^kf_t(x_i)\tag{1}&lt;/script&gt;&lt;p&gt;其中$f_k$为基模型,$y_i$表示第$i$个样本预测值。&lt;/p&gt;&lt;p&gt;正则化损失函数&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="决策树" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
      <category term="GBDT" scheme="http://yoursite.com/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>hadoop数据倾斜及解决办法</title>
    <link href="http://yoursite.com/2019/12/15/hadoop%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/15/hadoop数据倾斜及解决办法/</id>
    <published>2019-12-15T07:17:25.000Z</published>
    <updated>2019-12-15T07:23:50.914Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="hadoop" scheme="http://yoursite.com/categories/hadoop/"/>
    
      <category term="hive" scheme="http://yoursite.com/categories/hadoop/hive/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>关于决策树总结</title>
    <link href="http://yoursite.com/2019/11/04/%E5%85%B3%E4%BA%8E%E5%86%B3%E7%AD%96%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/04/关于决策树总结/</id>
    <published>2019-11-04T15:13:46.000Z</published>
    <updated>2019-11-04T15:25:23.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策树处理连续值"><a href="#决策树处理连续值" class="headerlink" title="决策树处理连续值"></a>决策树处理连续值</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;决策树处理连续值&quot;&gt;&lt;a href=&quot;#决策树处理连续值&quot; class=&quot;headerlink&quot; title=&quot;决策树处理连续值&quot;&gt;&lt;/a&gt;决策树处理连续值&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="决策树" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>梯度提升树</title>
    <link href="http://yoursite.com/2019/10/10/GBDT%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/10/GBDT原理/</id>
    <published>2019-10-10T15:10:38.000Z</published>
    <updated>2020-08-29T14:14:49.239Z</updated>
    
    <content type="html"><![CDATA[<p>GBDT主要由三个概念组成：Regression Decistion Tree（即DT)，Gradient Boosting（即GB)，Shrinkage（算法的一个重要演进分枝，目前大部分源码都按该版本实现）。搞定这三个概念后就能明白GBDT是如何工作的，要继续理解它如何用于搜索排序则需要额外理解RankNet概念，之后便功德圆满。下文将逐个碎片介绍，最终把整张图拼出来。 </p><a id="more"></a><h2 id="加法模型"><a href="#加法模型" class="headerlink" title="加法模型"></a>加法模型</h2><p>对于算法模型而言，一个性能弱的算法模型可能很难得到很好的效果，加法模型的思想是将性能较弱的模型通过加权得到一个性能较强的模型。形如</p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^{M}\beta_m b(x;\gamma_m)\tag{1}</script><p>其中$b(x;y_m)$表示基函数，$\gamma_m$表示基函数系数，$\beta_m$表示基函数系数。</p><h2 id="前向分布算法"><a href="#前向分布算法" class="headerlink" title="前向分布算法"></a>前向分布算法</h2><p>在给定训练集的情况下以及损失函数$L(y,f(x))$的条件下，学习加法模型$f(x)$即为最小化损失函数的问题：</p><script type="math/tex; mode=display">\min\limits_{\beta_m,\gamma_m}\sum_{i=1}^N L(y_i,\sum_{m=1}^M\beta_mb(x_i;\gamma_m))\tag{2}</script><p>前向分步算法的思想：加法模型是不同模型的组合，因此从前向后每次学习一个基函数和基函数系数来逐步优化目标函数$(1)$,从而降低复杂度。</p><p>计算流程：</p><p>(1).初始化第一个基函数$f_0(x)$</p><p>(2)对于$m=1,2,3,…,M$，极小化损失函数</p><script type="math/tex; mode=display">(\beta_m,\gamma_m)=\arg \min\limits_{\beta,\gamma}+\beta_mb(x;\gamma_m)\tag{3}</script><p>得到参数$\beta_m,\gamma_m$</p><p>(3) 更新加法模型</p><script type="math/tex; mode=display">f_m(x)=f_{m-1}(x)+\beta_mb(x;\gamma_m)\tag{4}</script><p>(4)得到加法模型</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^M\beta_mb(x;\gamma_m)\tag{5}</script><h2 id="GBDT梯度提升模型"><a href="#GBDT梯度提升模型" class="headerlink" title="GBDT梯度提升模型"></a>GBDT梯度提升模型</h2><h3 id="提升树算法"><a href="#提升树算法" class="headerlink" title="提升树算法"></a>提升树算法</h3><p>提升方法可以总结为加法模型与前向分布算法，以决策树为基函数的模型成为<strong>提升树</strong>，无论是分类问题还是回归问题，都是基于回归树(这点和统计学系方法里面不一样)，提升树算法则是采用前向分步算法来更新加法模型。对于提升树，基函数变为决策树，所以加法模型为</p><script type="math/tex; mode=display">f_m(x)=\sum_{i=1}^MT(x;w_m)\tag{6}</script><p>其中$M$为决策树的个数，$w$为决策树的参数，$T$表示决策树。</p><p>初始化第一棵决策树，第$m$部的模型为</p><script type="math/tex; mode=display">f_m(x)=f_{m-1}(x)+T(x;w)\tag{7}</script><p>通过最小化损失函数确定下一棵决策树的参数$w_m$</p><script type="math/tex; mode=display">\arg\min\limits_{w_m}\sum_{i=1}^NL(y_i,f_{m-1}+T(x_i,w_m))</script><p>当采用平方误差时</p><script type="math/tex; mode=display">L(y,f(x))=(y-f(x))^2\tag{8}</script><p>损失函数变为</p><script type="math/tex; mode=display">L(y)=(y-f_{m-1}(x)-T(x;w_m))^2</script><script type="math/tex; mode=display">=[r-T(x;w_m)]^2\tag{9}</script><p>其中残差$r=y-f_{m-1}(x)$，所以最后的目的就是为了是$T(x;w_m)$的值更加接近残差，从而达到最小化损失函数的作用。</p><h3 id="回归问题提升树"><a href="#回归问题提升树" class="headerlink" title="回归问题提升树"></a>回归问题提升树</h3><p>1.计算出第一颗树第一棵提升树</p><script type="math/tex; mode=display">f_0(x)=\arg \min\limits\sum_{i=1}^NL(y_i,c)\tag{10}</script><p>2.得到提升树的残差</p><script type="math/tex; mode=display">r_{mi}=y_i-f_{m-1}(x_i), i=1,2,3....,N\tag{11}</script><p>3.通过拟合残茶学习回归树，得到$T_m(x;w_m)$</p><p>4.更新提升树</p><script type="math/tex; mode=display">f_m(x)=f_{m-1}(x)+T(x;w_m)\tag{12}</script><h2 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h2><p>梯度提升本质其实是利用梯度下降算法来对前向分步算法进行优化求解的方法。其关键是利用<strong>损失函数负梯度</strong>在当前模型的值作为残差的近似值，进行一个拟合。</p><script type="math/tex; mode=display">r_{mi}=-[\frac{\partial L(y,f(x_i))}{\partial f(x_i)}]_{f(x_i)=f_m(x_i)}\tag{13}</script><p>利用负梯度代替残差的原因是因为只有在损失函数为平方差的时候，梯度才等于残差，但是当损失函数比较复杂的时候，此时梯度是不等于残差的。</p><p>对于特征的选择和回归树一样，同样是遍历所有特征找到最佳切分点。</p><p>回归例子可以参见统计学习方法。</p><h2 id="GBDT用于分类和回归的区别"><a href="#GBDT用于分类和回归的区别" class="headerlink" title="GBDT用于分类和回归的区别"></a>GBDT用于分类和回归的区别</h2><p>前面主要将的是GBDT的思想，利用残差不断的拟合，直到最后接近目标。但是对于对于分类和回归任务的处理，主要有以下几个方面不一样。</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>1、分裂节点的评价标准不同</p><p>对于回归类问题，分裂节点的时候主要评价方式为</p><p>(1)平方误差</p><script type="math/tex; mode=display">L(x,c)=min \sum_{i=1}^m\sum_{j\in R_i}(x_j-c_i)^2</script><p>将特征划分为m个不同的区域$R_i$，然后求出每个区域的平方误差求和，平方误差和最小的特征和切分点。</p><p>(2)绝地值误差</p><script type="math/tex; mode=display">L(x,c)=min \sum_{i=1}^m\sum_{j\in R_i}|x_j-c_i|</script><p>(3)friedman_mse：费尔德曼均方误差，改进后的均方误差，一般能够达到比较好的效果</p><p>对于分类问题，其节点分类的评价方式为</p><p>(1)信息熵(<strong>entropy</strong>)</p><script type="math/tex; mode=display">H(x)=-\sum_{i=1}^np_i\log p_i</script><p>(2)gini,基尼系数(信息增益)</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script><p>详细计算过程见统计学习方法。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在介绍分类的原理之前首先要了解一下对数损失函数</p><script type="math/tex; mode=display">L(y,P(Y|X))=log P(Y|X)\tag{14}</script><p>对于分类任务，GBDT是结合回归加分类模型计算每种分类的概率，对于二分类，采用的是logistic进行分类</p><script type="math/tex; mode=display">P(Y=1|X)=\frac{1}{1+exp(-\sum_{i=1}^Mf_i(x))}\tag{15}</script><script type="math/tex; mode=display">P(Y=0|X)=\frac{1}{1+exp(\sum_{i=1}^Mf_i(x))}\tag{16}</script><p>令$h_\theta(x)=\frac{1}{1+exp(-\sum_{i=1}^Mf_i(x))}$</p><p>所以有</p><script type="math/tex; mode=display">P(Y=1|X)=h_\theta(x)\tag{17}</script><script type="math/tex; mode=display">P(Y=0|X)=1-h_\theta(x)\tag{18}</script><script type="math/tex; mode=display">P(Y|X)=h_\theta(x)^{y_i}(1-h_\theta(x))^{1-y_i}</script><p>损失函数为</p><script type="math/tex; mode=display">J_\theta(x)=-\sum_{i=1}^N [y_ilogh_\theta(x)+(1-y_i)log(1-h_\theta(x))]\tag{19}</script><p>所以经过计算有</p><script type="math/tex; mode=display">\frac{\partial J}{\partial h_\theta(x)}=y-\hat y</script><p>对于多分类问题</p><p>损失函数为交叉熵</p><script type="math/tex; mode=display">L(y,p(y|x))=-\sum_{i=1}^M y_ilog {p_i}\tag{20}</script><p>其中$i$表示所属类别，$M$表示分类树,$p_i$表示属于$i$的概率</p><p>并且有</p><script type="math/tex; mode=display">p(y=i|x)=\frac{exp(F_i(x))}{\sum_{i=1}^Mexp(F_i(x))}\tag{21}</script><p>同样求梯度有</p><script type="math/tex; mode=display">r_{mi}=-\frac{\partial L(y_i,F(x_i))}{\partial F(x_i)}|_{f(x_i)=f_{m-1}(x_i)}</script><p>回归损失函数</p><p>(1)平方损失函数</p><script type="math/tex; mode=display">L(y,x)=\sum_{i=1}^n(y_i-f(x_i))^2</script><p>(2)绝对值损失函数</p><script type="math/tex; mode=display">L(y,x)=\sum_{i=1}^n|y_i-f(x_i)|</script><p>(3)huber损失函数</p><script type="math/tex; mode=display">L(y)=\left\{\begin{array}{rcl}\frac{1}{2}(y-f(x))^2 & & {|y-f(x)|\leq\delta}\\\delta*|y-f(x)-\frac{1}{2}\delta| & & {|y-f(x)|>\delta}\end{array} \right.</script><h2 id="GBDT的正则化"><a href="#GBDT的正则化" class="headerlink" title="GBDT的正则化"></a>GBDT的正则化</h2><p>和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。</p><p>（1）第一种是和Adaboost类似的正则化项，即<strong>步长</strong>（learning rate）。定义为ν,对于前面的弱学习器的迭代 <script type="math/tex">f_k(x)=f_{k-1}(x)+h_k(x)</script> 如果我们加上了正则化项，则有 <script type="math/tex">f_k(x)=f_{k-1}(x)+v\cdot h_k(x)</script> ν的取值范围为0&lt;ν≤10。对于同样的训练集学习效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><p>（2）第二种正则化的方式是通过<strong>子采样比例</strong>（subsample）。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。</p><p>使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。（注：这一点没明白。。）</p><p>（3）第三种是对于弱学习器即CART回归树进行正则化<strong>剪枝</strong>。在决策树章节里我们已经讲过，这里就不重复了。</p><h2 id="调参经验"><a href="#调参经验" class="headerlink" title="调参经验"></a>调参经验</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>sklearn.ensemble.<code>`RandomForestClassifier</code></p><p>Parameters</p><ul><li><p><strong>n_estimators</strong> ：树的个数，迭代次数</p><p>The number of trees in the forest.<em>Changed in version 0.22:</em> The default value of <code>n_estimators</code> changed from 10 to 100 in 0.22.</p></li><li><p><strong>criterion</strong>： 叶子结点分裂的方式，默认的是gini和entropy</p></li><li><p><strong>max_depth</strong>：树的深度，默认为空，会一直分裂，直到无法继续分裂</p></li><li><p><strong>min_samples_split</strong>： 分裂一个节点所需要的最小样本</p><ul><li>int：表示样本数</li><li>float 表示的百分比 </li></ul></li><li><p><strong>min_samples_leaf</strong>：保持一颗叶子结点所需要的样本数，该参数能够对模型进行平滑，特别在回归任务中。int和float和<strong>min_samples_split</strong>一样。</p></li><li><p><strong>min_weight_fraction_leaf</strong>：叶子结点所有权重和的最小值，<strong>如果分布相差很大或者有很多缺失值，可以引入该参数</strong></p></li></ul><ul><li><p><strong>max_features</strong>：当考虑最佳分割点是考虑的特征数。</p><ul><li>如果是float型，表示的是百分比</li><li>如果是’auto’ or ‘log2’，表示sqrt(n_features)</li><li>如果是log2, 表示log2(n_features)</li></ul></li><li><p><strong>max_leaf_nodes </strong>: 最大叶子结点，用于防止过拟合 </p></li><li><p><strong>min_impurity_split</strong>：早停的阈值，如果一个节点的不纯度高于该值，则分裂，否则为叶子结点</p><p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.<em>Deprecated since version 0.19:</em> <code>min_impurity_split</code> has been deprecated in favor of <code>min_impurity_decrease</code> in 0.19. The default value of <code>min_impurity_split</code> will change from 1e-7 to 0 in 0.23 and it will be removed in 0.25. Use <code>min_impurity_decrease</code> instead.</p></li><li><p><strong>bootstrap</strong>： 是否使用bootstrap采样，为否表示使用整个数据集</p></li><li><p><strong>oob_score</strong>：袋外精度来泛化</p><p>Whether to use out-of-bag samples to estimate the generalization accuracy.</p></li><li><p><strong>class_weight</strong>：类别权重，用于样本分布不均衡时使用</p><ul><li>‘’dict, list of dicts, “balanced”, “balanced_subsample” or None, optional (default=None）</li><li>格式为<code>{class_label: weight}</code> ，例如 {0: 1, 1: 1}</li><li>’balanced‘模式下会自动调整权值，根据训练数据中类别出现频率， n_samples/(n_class *np.bincount())</li><li>‘balanced_subsample’和balanced一样，区别在于才用的boostrap</li></ul></li><li><p><strong>max_samples</strong>：从训练集中取出的每个样本量</p><ul><li>None：表示使用所有样本</li><li>如果为int 表示为该值</li><li>float表示 百分比</li></ul></li></ul><p><em>class</em> <code>sklearn.ensemble.``GradientBoostingRegressor</code></p><ul><li><p><strong>loss</strong> ：损失函数，默认为ls</p><ul><li><p>‘ls’ 平方损失函数，损失函数为$L(y)=(y-f(x))^2$</p></li><li><p>‘lad’，绝对值 ,损失函数 $L(y)=|y-f(x)|$</p></li><li><p>‘huber’： 两者的结合</p><script type="math/tex; mode=display">L(y)=\left\{\begin{array}{rcl}\frac{1}{2}(y-f(x))^2 & & {|y-f(x)|\leq\delta}\\\delta*|y-f(x)-\frac{1}{2}\delta| & & {|y-f(x)|>\delta}\end{array} \right.</script></li></ul></li><li><p><strong>subsample</strong>：子采样比例，子采样会减少方差，增大偏差</p></li><li><p><strong>criterion</strong>： 衡量节点分裂质量的指标</p><ul><li>friedman_mse, </li><li>‘mse’</li><li>’mae‘</li></ul></li></ul><p><em>New in version 0.18.</em></p><ul><li><p><strong>min_samples_split</strong>: 和分类一样</p></li><li><p><strong>tol</strong>：学习率</p></li></ul><p>参考资料</p><p>[1]<a href="https://zhuanlan.zhihu.com/p/86281279" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86281279</a></p><p>[2].统计学习方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GBDT主要由三个概念组成：Regression Decistion Tree（即DT)，Gradient Boosting（即GB)，Shrinkage（算法的一个重要演进分枝，目前大部分源码都按该版本实现）。搞定这三个概念后就能明白GBDT是如何工作的，要继续理解它如何用于搜索排序则需要额外理解RankNet概念，之后便功德圆满。下文将逐个碎片介绍，最终把整张图拼出来。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="决策树" scheme="http://yoursite.com/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    
      <category term="集成学习" scheme="http://yoursite.com/tags/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>pandas的基本用法</title>
    <link href="http://yoursite.com/2019/10/05/pandas%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/05/pandas的基本用法/</id>
    <published>2019-10-05T03:29:03.000Z</published>
    <updated>2019-12-15T07:23:41.541Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib的基本用法</title>
    <link href="http://yoursite.com/2019/10/04/Matplotlib%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/04/Matplotlib的基本用法/</id>
    <published>2019-10-04T15:20:03.000Z</published>
    <updated>2019-10-05T02:43:47.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib的基本用法"><a href="#Matplotlib的基本用法" class="headerlink" title="Matplotlib的基本用法"></a>Matplotlib的基本用法</h1><h2 id="简单的折线图"><a href="#简单的折线图" class="headerlink" title="简单的折线图"></a>简单的折线图</h2><p><strong>plt.plot(x,y, fortmat_string)</strong></p><p>作用是定义画图的样式</p><p>x,y表示横纵左表， format可以定义画图格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入Matploylib库</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt  </span><br><span class="line">%matplotlib inline     </span><br><span class="line"><span class="comment">#画布上画图</span></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="string">'b'</span>,  linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>], <span class="string">'r'</span>,   linewidth=<span class="number">2</span>)</span><br><span class="line"><span class="comment">#在画布上显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_1_0.png" alt="png"></p><h2 id="添加标题标签及图的样式"><a href="#添加标题标签及图的样式" class="headerlink" title="添加标题标签及图的样式"></a>添加标题标签及图的样式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt  </span><br><span class="line">%matplotlib inline </span><br><span class="line">x = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">y = [<span class="number">2</span>,<span class="number">16</span>,<span class="number">4</span>]</span><br><span class="line">plt.plot(x,y)</span><br><span class="line"><span class="comment"># 图片的标题</span></span><br><span class="line">plt.title(<span class="string">'Image Title'</span>)</span><br><span class="line"><span class="comment"># 坐标轴Y轴</span></span><br><span class="line">plt.ylabel(<span class="string">'Y axis'</span>)</span><br><span class="line"><span class="comment"># 坐标轴X轴</span></span><br><span class="line">plt.xlabel(<span class="string">'X axis'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_3_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style </span><br><span class="line">style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">x = [<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">y = [<span class="number">12</span>,<span class="number">16</span>,<span class="number">6</span>]</span><br><span class="line">x2 = [<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>]</span><br><span class="line">y2 = [<span class="number">6</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">plt.plot(x,y,<span class="string">'g'</span>,label=<span class="string">'line one'</span>, linewidth=<span class="number">5</span>)</span><br><span class="line">plt.plot(x2,y2,<span class="string">'r'</span>,label=<span class="string">'line two'</span>,linewidth=<span class="number">5</span>)</span><br><span class="line">plt.title(<span class="string">'Epic Info'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Y axis'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'X axis'</span>)</span><br><span class="line"><span class="comment">#设置图例位置</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid(<span class="literal">True</span>,color=<span class="string">'k'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_4_0.png" alt="png"></p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>pyplot.bar(left, height, alpha=1, width=0.8, color=, edgecolor=, label=, lw=3)</p><p>画一个柱状图</p><p>参数</p><ul><li>left： x轴的位置序列，一般采用arange函数产生一个序列</li><li>height: y轴的数值序列，也就是柱状图的高度，即我们需要展示的数据</li><li>alpha： 透明度</li><li>width: 柱状图的宽度</li><li>color or facecolor: 柱状图的填充颜色</li><li>edgecolor: 图形边缘颜色</li><li>label: 每个图像代表的意思</li><li>linewidth or linewidths or lw：边缘or线的宽度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line">plt.bar([<span class="number">0.25</span>,<span class="number">1.25</span>,<span class="number">2.25</span>,<span class="number">3.25</span>,<span class="number">4.25</span>],[<span class="number">50</span>,<span class="number">40</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">20</span>],label=<span class="string">"BMW"</span>, color=<span class="string">'b'</span>, width=<span class="number">.5</span>)</span><br><span class="line">plt.bar([<span class="number">.75</span>,<span class="number">1.75</span>,<span class="number">2.75</span>,<span class="number">3.75</span>,<span class="number">4.75</span>],[<span class="number">80</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">60</span>],label=<span class="string">"Audi"</span>, color=<span class="string">'r'</span>,width=<span class="number">.5</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">'Days'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Distance (kms)'</span>)</span><br><span class="line">plt.title(<span class="string">'Information'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_7_0.png" alt="png"></p><h2 id="频率图"><a href="#频率图" class="headerlink" title="频率图"></a>频率图</h2><p>matplotlib.pyplot.hist(x, bins=10, range=None, normed=False, weights=None, cumulative=False, bottom=None, histtype=u’bar’, align=u’mid’, orientation=u’vertical’, rwidth=None, log=False, color=None, label=None, stacked=False)</p><p>统计每个区间出现的频率</p><p>参数</p><ul><li>x：直方图统计的数据</li><li>bins: 指定统计的间隔，如bins=10时表示以10为一个区间</li><li>color: 柱状图的颜色</li><li>histtype: 可选{‘bar’, ‘barstacked’,’step’, ‘stepfilled’}之一</li><li>density: 显示频率</li><li>stacked: 是否显示堆叠柱状图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">population_age = [<span class="number">22</span>,<span class="number">55</span>,<span class="number">62</span>,<span class="number">45</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">42</span>,<span class="number">42</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">102</span>,<span class="number">95</span>,<span class="number">85</span>,<span class="number">55</span>,<span class="number">110</span>,<span class="number">120</span>,<span class="number">70</span>,<span class="number">65</span>,<span class="number">55</span>,<span class="number">111</span>,<span class="number">115</span>,<span class="number">80</span>,<span class="number">75</span>,<span class="number">65</span>,<span class="number">54</span>,<span class="number">44</span>,<span class="number">43</span>,<span class="number">42</span>,<span class="number">48</span>]</span><br><span class="line">bins = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">100</span>]</span><br><span class="line">plt.hist(population_age, bins=<span class="number">10</span>, histtype=<span class="string">'bar'</span>, color=<span class="string">'b'</span>, rwidth=<span class="number">0.8</span>)</span><br><span class="line">plt.xlabel(<span class="string">'age groups'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number of people'</span>)</span><br><span class="line">plt.title(<span class="string">'Histogram'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_10_0.png" alt="png"></p><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">2.5</span>,<span class="number">3</span>,<span class="number">3.5</span>,<span class="number">3.6</span>]</span><br><span class="line">y = [<span class="number">7.5</span>,<span class="number">8</span>,<span class="number">8.5</span>,<span class="number">9</span>,<span class="number">9.5</span>,<span class="number">10</span>,<span class="number">10.5</span>] </span><br><span class="line">x1=[<span class="number">8</span>,<span class="number">8.5</span>,<span class="number">9</span>,<span class="number">9.5</span>,<span class="number">10</span>,<span class="number">10.5</span>,<span class="number">11</span>]</span><br><span class="line">y1=[<span class="number">3</span>,<span class="number">3.5</span>,<span class="number">3.7</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">5</span>,<span class="number">5.2</span>] </span><br><span class="line"><span class="comment"># scatter表示画散点图</span></span><br><span class="line">plt.scatter(x,y, label=<span class="string">'high income low saving'</span>,color=<span class="string">'r'</span>)</span><br><span class="line">plt.scatter(x1,y1,label=<span class="string">'low income high savings'</span>,color=<span class="string">'b'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'saving*100'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'income*1000'</span>)</span><br><span class="line">plt.title(<span class="string">'Scatter Plot'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_12_0.png" alt="png"></p><h2 id="堆叠图"><a href="#堆叠图" class="headerlink" title="堆叠图"></a>堆叠图</h2><p>matplotlib.pyplot.stackplot(x, <em>args, labels=(), colors=None, baseline=’zero’, data=None, *</em>kwargs)</p><p>画堆叠图，主要有三个参数</p><ul><li>x:需要画堆叠图的数值</li><li>laebl: 堆叠图中折现的标签</li><li>colors: 设置折线图的颜色</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sleeping =[<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">7</span>]</span><br><span class="line">eating = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">working =[<span class="number">7</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">playing = [<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">13</span>] </span><br><span class="line">labels = [<span class="string">'Sleeping'</span>, <span class="string">'Eating'</span>, <span class="string">'Working'</span>, <span class="string">'Playing'</span>]</span><br><span class="line">plt.stackplot(days, sleeping,eating,working,playing,labels=labels,colors=[<span class="string">'m'</span>,<span class="string">'c'</span>,<span class="string">'r'</span>,<span class="string">'k'</span>])  </span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">'Stack Plot'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_15_0.png" alt="png"></p><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slices = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">13</span>]</span><br><span class="line">activities = [<span class="string">'sleeping'</span>,<span class="string">'eating'</span>,<span class="string">'working'</span>,<span class="string">'playing'</span>]</span><br><span class="line">cols = [<span class="string">'c'</span>,<span class="string">'m'</span>,<span class="string">'r'</span>,<span class="string">'b'</span>] </span><br><span class="line">plt.pie(slices,  labels=activities,  colors=cols,  startangle=<span class="number">90</span>,  shadow= <span class="literal">True</span>,  explode=(<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>),  autopct=<span class="string">'%1.1f%%'</span>) </span><br><span class="line">plt.title(<span class="string">'Pie Plot'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_17_0.png" alt="png"></p><h2 id="多个子图合并"><a href="#多个子图合并" class="headerlink" title="多个子图合并"></a>多个子图合并</h2><p>plt.subplot(numRows, numCols, plotNum)</p><p>将一块画布分为多个区域，将不同图分别放入不同的子图</p><p>参数</p><ul><li>numRows：指的行数</li><li>numCols：指的列数</li><li>plotNum：子图的位置</li></ul><p>如上面所示的221，表示的是将图分为2 * 2个子图，然后使用第一个位置</p><p>子图的位置依次为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1,1) (1,2)</span><br><span class="line"></span><br><span class="line">(2,1) (2,2)</span><br></pre></td></tr></table></figure><p>依次对应的位置为1,2,3,4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(t)</span>:</span>    </span><br><span class="line">    <span class="keyword">return</span> np.exp(-t) * np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line">t1 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">t2 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.02</span>)</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(t1, f(t1), <span class="string">'bo'</span>, t2, f(t2))</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(t2, np.cos(<span class="number">2</span>*np.pi*t2))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_19_0.png" alt="png"></p><h1 id="pandas与matplotlib结合"><a href="#pandas与matplotlib结合" class="headerlink" title="pandas与matplotlib结合"></a>pandas与matplotlib结合</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>np.random.rand(nums)</p><p>随即产生nums个位于[0,1]的样本</p><p>np.random.randn(nums)</p><p>随即返回nums个标准正态分布的样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(np.random.rand(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;matplotlib.lines.Line2D at 0x24f3122c2b0&gt;]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_23_1.png" alt="png"></p><h2 id="设置坐标轴刻度"><a href="#设置坐标轴刻度" class="headerlink" title="设置坐标轴刻度"></a>设置坐标轴刻度</h2><ul><li>图名</li><li>x轴标签</li><li>y轴标签</li><li>图例</li><li>x轴边界</li><li>y轴边界</li><li>x轴刻度</li><li>y轴刻度</li><li>x轴刻度标签</li><li>y轴刻度标签</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">2</span>),columns=[<span class="string">'A'</span>,<span class="string">'B'</span>])</span><br><span class="line"></span><br><span class="line">fig = df.plot(figsize=(<span class="number">8</span>,<span class="number">4</span>))  <span class="comment"># figsize：创建图表窗口，设置窗口大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'TITLETITLETITLE'</span>)  <span class="comment"># 图名</span></span><br><span class="line">plt.xlabel(<span class="string">'XXXXXX'</span>)  <span class="comment"># x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">'YYYYYY'</span>) <span class="comment"># y轴标签</span></span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="string">'upper right'</span>) <span class="comment"># 显示图例，loc表示位置</span></span><br><span class="line"></span><br><span class="line">plt.xlim([<span class="number">0</span>,<span class="number">12</span>])  <span class="comment"># x轴边界</span></span><br><span class="line">plt.ylim([<span class="number">0</span>,<span class="number">1.5</span>])  <span class="comment"># y轴边界</span></span><br><span class="line"></span><br><span class="line">plt.xticks(range(<span class="number">10</span>))  <span class="comment"># 设置x刻度</span></span><br><span class="line">plt.yticks([<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.8</span>,<span class="number">1.0</span>,<span class="number">1.2</span>])  <span class="comment"># 设置y刻度</span></span><br><span class="line"></span><br><span class="line">fig.set_xticklabels(<span class="string">"%.1f"</span> %i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))  <span class="comment"># x轴刻度标签</span></span><br><span class="line">fig.set_yticklabels(<span class="string">"%.2f"</span> %i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.8</span>,<span class="number">1.0</span>,<span class="number">1.2</span>])  <span class="comment"># y轴刻度标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里x轴范围是0-12，但刻度只是0-9，刻度标签使得其显示1位小数</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Text(0, 0, &apos;0.00&apos;),</span><br><span class="line"> Text(0, 0, &apos;0.20&apos;),</span><br><span class="line"> Text(0, 0, &apos;0.40&apos;),</span><br><span class="line"> Text(0, 0, &apos;0.60&apos;),</span><br><span class="line"> Text(0, 0, &apos;0.80&apos;),</span><br><span class="line"> Text(0, 0, &apos;1.00&apos;),</span><br><span class="line"> Text(0, 0, &apos;1.20&apos;)]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_25_1.png" alt="png"></p><h2 id="修改图标样式"><a href="#修改图标样式" class="headerlink" title="修改图标样式"></a>修改图标样式</h2><p>pd.Series()作用是产生一个有编号的序列</p><p>np.random.randn()产生正太分布的样本，当只有一个参数是，返回n个标准正太分布的结果，当有两个或多个参数时，参数表示对应的维度</p><p>np.random.rand() 用法和上面一个函数一样，但是返回的是</p><p>np.cumsum()表示将前一行或者前一列加到后面</p><p>参数</p><p>​         a：表示传入函数的数据<br>         axi：{0,1}，axi=0时表示行相加，axi=1时表示列相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(<span class="number">100</span>).cumsum())</span><br><span class="line">s.plot(linestyle = <span class="string">'--'</span>, marker = <span class="string">'.'</span>,color=<span class="string">"r"</span>,grid=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_27_1.png" alt="png"></p><h2 id="dataframe直接画图"><a href="#dataframe直接画图" class="headerlink" title="dataframe直接画图"></a>dataframe直接画图</h2><p>DataFrame.plot(x=None, y=None, kind=’line’, ax=None, subplots=False,<br>                sharex=None, sharey=False, layout=None,figsize=None,<br>                use_index=True, title=None, grid=None, legend=True,<br>                style=None, logx=False, logy=False, loglog=False,<br>                xticks=None, yticks=None, xlim=None, ylim=None, rot=None,<br>                xerr=None,secondary_y=False, sort_columns=False, **kwds)</p><p>Parameters:<br>x : label or position, default None#指数据框列的标签或位置参数</p><p>y : label or position, default None</p><p>kind : str<br>‘line’ : line plot (default)#折线图<br>‘bar’ : vertical bar plot#条形图<br>‘barh’ : horizontal bar plot#横向条形图<br>‘hist’ : histogram#柱状图<br>‘box’ : boxplot#箱线图<br>‘kde’ : Kernel Density Estimation plot#Kernel 的密度估计图，主要对柱状图添加Kernel 概率密度线<br>‘density’ : same as ‘kde’<br>‘area’ : area plot#不了解此图<br>‘pie’ : pie plot#饼图<br>‘scatter’ : scatter plot#散点图  需要传入columns方向的索引<br>‘hexbin’ : hexbin plot#不了解此图</p><p>ax : matplotlib axes object, default None#<strong>子图(axes, 也可以理解成坐标轴) 要在其上进行绘制的matplotlib subplot对象。如果没有设置，则使用当前matplotlib subplot</strong>其中，变量和函数通过改变figure和axes中的元素（例如：title,label,点和线等等）一起描述figure和axes，也就是在画布上绘图。</p><ul><li>subplots : boolean, default False#判断图片中是否有子图</li></ul><p>Make separate subplots for each column</p><ul><li>sharex : boolean, default True if ax is None else False#如果有子图，子图共x轴刻度，标签</li></ul><p>In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in; Be aware, that passing in both an ax and sharex=True will alter all x axis labels for all axis in a figure!</p><ul><li>sharey : boolean, default False#如果有子图，子图共y轴刻度，标签</li></ul><p>In case subplots=True, share y axis and set some y axis labels to invisible</p><ul><li>layout : tuple (optional)#子图的行列布局</li></ul><p>(rows, columns) for the layout of subplots</p><ul><li><p>figsize : a tuple (width, height) in inches#图片尺寸大小</p></li><li><p>use_index : boolean, default True#默认用索引做x轴</p></li></ul><p>Use index as ticks for x axis</p><ul><li>title : string#图片的标题用字符串</li></ul><p>Title to use for the plot</p><ul><li>grid : boolean, default None (matlab style default)#图片是否有网格</li></ul><p>Axis grid lines</p><ul><li>legend : False/True/’reverse’#子图的图例，添加一个subplot图例(默认为True)</li></ul><p>Place legend on axis subplots</p><ul><li>style : list or dict#对每列折线图设置线的类型</li></ul><p>matplotlib line style per column</p><ul><li>logx : boolean, default False#设置x轴刻度是否取对数</li></ul><p>Use log scaling on x axis</p><ul><li>logy : boolean, default False</li></ul><p>Use log scaling on y axis</p><ul><li>loglog : boolean, default False#同时设置x，y轴刻度是否取对数</li></ul><p>Use log scaling on both x and y axes</p><ul><li>xticks : sequence#设置x轴刻度值，序列形式（比如列表）</li></ul><p>Values to use for the xticks</p><ul><li>yticks : sequence#设置y轴刻度，序列形式（比如列表）</li></ul><p>Values to use for the yticks</p><ul><li><p>xlim : 2-tuple/list#设置坐标轴的范围，列表或元组形式</p></li><li><p>ylim : 2-tuple/list</p></li><li><p>rot : int, default None#设置轴标签（轴刻度）的显示旋转度数</p></li></ul><p>Rotation for ticks (xticks for vertical, yticks for horizontal plots)</p><ul><li>fontsize : int, default None#设置轴刻度的字体大小</li></ul><p>Font size for xticks and yticks</p><ul><li>colormap : str or matplotlib colormap object, default None#设置图的区域颜色</li></ul><p>Colormap to select colors from. If string, load colormap with that name from matplotlib.</p><ul><li>colorbar : boolean, optional  #图片柱子</li></ul><p>If True, plot colorbar (only relevant for ‘scatter’ and ‘hexbin’ plots)</p><ul><li>position : float   </li></ul><p>Specify relative alignments for bar plot layout. From 0 (left/bottom-end) to 1 (right/top-end). Default is 0.5 (center)</p><ul><li>layout : tuple (optional)  #布局</li></ul><p>(rows, columns) for the layout of the plot</p><ul><li>table : boolean, Series or DataFrame, default False  #如果为正，则选择DataFrame类型的数据并且转换匹配matplotlib的布局。</li></ul><p>If True, draw a table using the data in the DataFrame and the data will be transposed to meet matplotlib’s default layout. If a Series or DataFrame is passed, use passed data to draw a table.</p><ul><li>yerr : DataFrame, Series, array-like, dict and str</li></ul><p>See Plotting with Error Bars for detail.</p><ul><li><p>xerr : same types as yerr.</p></li><li><p>stacked : boolean, default False in line and</p></li></ul><p>bar plots, and True in area plot. If True, create stacked plot.</p><ul><li><p>sort_columns : boolean, default False  # 以字母表顺序绘制各列，默认使用前列顺序</p></li><li><p>secondary_y : boolean or sequence, default False  ##设置第二个y轴（右y轴）</p></li></ul><p>Whether to plot on the secondary y-axis If a list/tuple, which columns to plot on secondary y-axis</p><ul><li>mark_right : boolean, default True</li></ul><p>When using a secondary_y axis, automatically mark the column labels with “(right)” in the legend</p><ul><li>kwds : keywords</li></ul><p>Options to pass to matplotlib plotting method</p><p><strong>Returns:axes : matplotlib.AxesSubplot or np.array of them</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接用风格样式设置</span></span><br><span class="line"><span class="comment"># 透明度与颜色版</span></span><br><span class="line"><span class="comment"># s.plot(style="--.",alpha = 0.8,colormap = 'Reds_r')</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">100</span>, <span class="number">4</span>),columns=list(<span class="string">'ABCD'</span>)).cumsum()</span><br><span class="line">df.plot(style = <span class="string">'--.'</span>,alpha = <span class="number">0.8</span>,colormap = <span class="string">'summer_r'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot at 0x24f379a4cc0&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_29_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">df.plot(style = <span class="string">'--o'</span>)</span><br><span class="line">plt.text(<span class="number">5</span>,<span class="number">0.5</span>,<span class="string">'Hello'</span>,fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text(5, 0.5, &apos;Hello&apos;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_30_1.png" alt="png"></p><h2 id="子图绘制"><a href="#子图绘制" class="headerlink" title="子图绘制"></a>子图绘制</h2><h3 id="figure对象"><a href="#figure对象" class="headerlink" title="figure对象"></a>figure对象</h3><p>plt.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=<class 'matplotlib.figure.figure'>, **kwargs)</class></p><p>作用创建一块画布</p><p>num相当于id，如果没有id则递增创建，如果已存在则返回该存在的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig1 = plt.figure(num=<span class="number">1</span>,figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(np.random.rand(<span class="number">50</span>).cumsum(),<span class="string">'k--'</span>)</span><br><span class="line">fig2 = plt.figure(num=<span class="number">2</span>,figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(<span class="number">50</span>-np.random.rand(<span class="number">50</span>).cumsum(),<span class="string">'k--'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;matplotlib.lines.Line2D at 0x24f3780f6d8&gt;]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_32_1.png" alt="png"></p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_32_2.png" alt="png"></p><h3 id="先创建子图然后填充"><a href="#先创建子图然后填充" class="headerlink" title="先创建子图然后填充"></a>先创建子图然后填充</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先建立子图然后填充图表</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>),facecolor = <span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个子图曲线图</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(np.random.rand(<span class="number">50</span>).cumsum(),<span class="string">'k--'</span>)</span><br><span class="line">plt.plot(np.random.randn(<span class="number">50</span>).cumsum(),<span class="string">'b--'</span>)</span><br><span class="line"><span class="comment"># 第二个字图，直方图</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax2.hist(np.random.rand(<span class="number">50</span>),alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个饼状图</span></span><br><span class="line">slices = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">13</span>]</span><br><span class="line">activities = [<span class="string">'sleeping'</span>,<span class="string">'eating'</span>,<span class="string">'working'</span>,<span class="string">'playing'</span>]</span><br><span class="line">cols = [<span class="string">'c'</span>,<span class="string">'m'</span>,<span class="string">'r'</span>,<span class="string">'b'</span>]</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">223</span>)</span><br><span class="line">ax3.pie(slices,  labels=activities,  colors=cols,  startangle=<span class="number">90</span>,  shadow= <span class="literal">True</span>,  explode=(<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>),  autopct=<span class="string">'%1.1f%%'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四个折线图</span></span><br><span class="line">ax4 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>) </span><br><span class="line">df2 = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">4</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">ax4.plot(df2,alpha=<span class="number">0.5</span>,linestyle=<span class="string">'--'</span>,marker=<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;matplotlib.lines.Line2D at 0x24f38c19940&gt;,</span><br><span class="line"> &lt;matplotlib.lines.Line2D at 0x24f3905ed68&gt;,</span><br><span class="line"> &lt;matplotlib.lines.Line2D at 0x24f3905ef28&gt;,</span><br><span class="line"> &lt;matplotlib.lines.Line2D at 0x24f3906b0f0&gt;]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_34_1.png" alt="png"></p><h3 id="使用subplots子图数组填充子图"><a href="#使用subplots子图数组填充子图" class="headerlink" title="使用subplots子图数组填充子图"></a>使用subplots子图数组填充子图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的figure，并返回一个subplot对象的numpy数组 → plt.subplot</span></span><br><span class="line"></span><br><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">3</span>,figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="number">1000</span>).cumsum())</span><br><span class="line">print(axes, axes.shape, type(axes))</span><br><span class="line"><span class="comment"># 生成图表对象的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过数组访问对应的子图</span></span><br><span class="line">ax1 = axes[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">ax1.plot(ts)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38EFABA8&gt;</span><br><span class="line">  &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38F13BA8&gt;</span><br><span class="line">  &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38CA4C88&gt;]</span><br><span class="line"> [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38CC8DA0&gt;</span><br><span class="line">  &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38CECEB8&gt;</span><br><span class="line">  &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F38D17320&gt;]] (2, 3) &lt;class &apos;numpy.ndarray&apos;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;matplotlib.lines.Line2D at 0x24f38d39978&gt;]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_36_2.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.subplots 参数调整</span></span><br><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">2</span>,sharex=<span class="literal">True</span>,sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># sharex,sharey：是否共享x，y刻度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        axes[i,j].hist(np.random.randn(<span class="number">500</span>),color=<span class="string">'k'</span>,alpha=<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># wspace,hspace：用于控制宽度和高度的百分比，比如subplot之间的间距</span></span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0</span>,hspace=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_37_0.png" alt="png"></p><h3 id="多系列子图绘制"><a href="#多系列子图绘制" class="headerlink" title="多系列子图绘制"></a>多系列子图绘制</h3><p>plt.plot():</p><ul><li>subplots, 是否分别绘制子图,为true的时候表示分开绘制，为false表示在一个图立面绘制</li><li>layout：挥之子图矩阵，按顺序填充</li></ul><p>subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)</p><p> 有六个可选参数来控制子图布局。值均为0~1之间。其中left、bottom、right、top围成的区域就是子图的区域。wspace、hspace分别表示子图之间左右、上下的间距。实际的默认值由matplotlibrc文件控制的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index=ts.index, columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line">df = df.cumsum()</span><br><span class="line">df.plot(style = <span class="string">'--.'</span>,alpha = <span class="number">0.4</span>,grid = <span class="literal">True</span>,figsize = (<span class="number">20</span>,<span class="number">8</span>),</span><br><span class="line">       subplots = <span class="literal">True</span>,</span><br><span class="line">       layout = (<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">       sharex = <span class="literal">False</span>)</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0.1</span>,hspace=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_39_0.png" alt="png"></p><h2 id="基本图表绘制"><a href="#基本图表绘制" class="headerlink" title="基本图表绘制"></a>基本图表绘制</h2><h3 id="Series-与-DataFrame-绘图"><a href="#Series-与-DataFrame-绘图" class="headerlink" title="Series 与 DataFrame 绘图"></a>Series 与 DataFrame 绘图</h3><p>plt.plot(kind=’line’, ax=None, figsize=None, use_index=True, title=None, grid=None, legend=False,<br>style=None, logx=False, logy=False, loglog=False, xticks=None, yticks=None, xlim=None, ylim=None,<br>rot=None, fontsize=None, colormap=None, table=False, yerr=None, xerr=None, label=None, secondary_y=False, **kwds)</p><p>参数含义：</p><ul><li>series的index为横坐标</li><li>value为纵坐标</li><li>kind → line,bar,barh…（折线图，柱状图，柱状图-横…）</li><li>label → 图例标签，Dataframe格式以列名为label</li><li>style → 风格字符串，这里包括了linestyle（-），marker（.），color（g）</li><li>color → 颜色，有color指定时候，以color颜色为准</li><li>alpha → 透明度，0-1</li><li>use_index → 将索引用为刻度标签，默认为True</li><li>rot → 旋转刻度标签，0-360</li><li>grid → 显示网格，一般直接用plt.grid</li><li>xlim,ylim → x,y轴界限</li><li>xticks,yticks → x,y轴刻度值</li><li>figsize → 图像大小</li><li>title → 图名</li><li>legend → 是否显示图例，一般直接用plt.legend()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">1000</span>), index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>)) <span class="comment"># pandas 时间序列</span></span><br><span class="line">ts = ts.cumsum()</span><br><span class="line">ts.plot(kind=<span class="string">'line'</span>,</span><br><span class="line">       label = <span class="string">"what"</span>,</span><br><span class="line">       style = <span class="string">'--.'</span>,</span><br><span class="line">       color = <span class="string">'g'</span>,</span><br><span class="line">       alpha = <span class="number">0.4</span>,</span><br><span class="line">       use_index = <span class="literal">True</span>,</span><br><span class="line">       rot = <span class="number">45</span>,</span><br><span class="line">       grid = <span class="literal">True</span>,</span><br><span class="line">       ylim = [<span class="number">-50</span>,<span class="number">50</span>],</span><br><span class="line">       yticks = list(range(<span class="number">-50</span>,<span class="number">50</span>,<span class="number">10</span>)),</span><br><span class="line">       figsize = (<span class="number">8</span>,<span class="number">4</span>),</span><br><span class="line">       title = <span class="string">'TEST_TEST'</span>,</span><br><span class="line">       legend = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 对网格项进行更加细致的设置</span></span><br><span class="line"><span class="comment">#plt.grid(True, linestyle = "--",color = "gray", linewidth = "0.5",axis = 'x')  # 网格</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_41_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># subplots → 是否将各个列绘制到不同图表，默认False</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index=ts.index, columns=list(<span class="string">'ABCD'</span>)).cumsum()</span><br><span class="line">df.plot(kind=<span class="string">'line'</span>,</span><br><span class="line">       style = <span class="string">'--.'</span>,</span><br><span class="line">       alpha = <span class="number">0.4</span>,</span><br><span class="line">       use_index = <span class="literal">True</span>,</span><br><span class="line">       rot = <span class="number">45</span>,</span><br><span class="line">       grid = <span class="literal">True</span>,</span><br><span class="line">       figsize = (<span class="number">8</span>,<span class="number">4</span>),</span><br><span class="line">       title = <span class="string">'test'</span>,</span><br><span class="line">       legend = <span class="literal">True</span>,</span><br><span class="line">       subplots = <span class="literal">False</span>,</span><br><span class="line">       colormap = <span class="string">'Greens'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot at 0x24f32b0f630&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_42_1.png" alt="png"></p><h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><ul><li>plt.bar()<ul><li>x,y参数：x，y值</li><li>width：宽度比例</li><li>facecolor柱状图里填充的颜色、edgecolor是边框的颜色</li><li>left-每个柱x轴左边界,bottom-每个柱y轴下边界 → bottom扩展即可化为甘特图 Gantt Chart</li><li>align：决定整个bar图分布，默认left表示默认从左边界开始绘制,center会将图绘制在中间位置<br>xerr/yerr ：x/y方向error bar</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的figure，并返回一个subplot对象的numpy数组</span></span><br><span class="line">fig,axes = plt.subplots(<span class="number">4</span>,<span class="number">1</span>,figsize = (<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">s = pd.Series(np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">16</span>),index = list(<span class="string">'abcdefghijklmnop'</span>))  </span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">3</span>), columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单系列柱状图方法一：plt.plot(kind='bar/barh')</span></span><br><span class="line">s.plot(kind=<span class="string">'bar'</span>,color = <span class="string">'k'</span>,grid = <span class="literal">True</span>,alpha = <span class="number">0.5</span>,ax = axes[<span class="number">0</span>])  <span class="comment"># ax参数 → 选择第几个子图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多系列柱状图</span></span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">3</span>), columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,ax = axes[<span class="number">1</span>],grid = <span class="literal">True</span>,colormap=<span class="string">'Reds_r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多系列堆叠图</span></span><br><span class="line"><span class="comment"># stacked → 堆叠</span></span><br><span class="line">df.plot(kind=<span class="string">'bar'</span>,ax = axes[<span class="number">2</span>],grid = <span class="literal">True</span>,colormap=<span class="string">'Blues_r'</span>,stacked=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># The bars are positioned at y with the given align. Their dimensions are given by width and height. The horizontal baseline is left (default 0). </span></span><br><span class="line"><span class="comment"># https://matplotlib.org/api/_as_gen/matplotlib.pyplot.barh.html?highlight=barh#matplotlib.pyplot.barh</span></span><br><span class="line">df.plot.barh(ax = axes[<span class="number">3</span>],grid = <span class="literal">True</span>,stacked=<span class="literal">True</span>,colormap = <span class="string">'BuGn_r'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot at 0x24f32cf0550&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_44_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y1 = np.random.rand(<span class="number">10</span>)</span><br><span class="line">y2 = -np.random.rand(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.bar(x,y1,width = <span class="number">1</span>,facecolor = <span class="string">'yellowgreen'</span>,edgecolor = <span class="string">'white'</span>,yerr = y1*<span class="number">0.1</span>)</span><br><span class="line">plt.bar(x,y2,width = <span class="number">1</span>,facecolor = <span class="string">'lightskyblue'</span>,edgecolor = <span class="string">'white'</span>,yerr = y2*<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(x,y1):</span><br><span class="line">    plt.text(i<span class="number">-0.2</span>,j<span class="number">-0.15</span>,<span class="string">'%.2f'</span> % j, color = <span class="string">'white'</span>)</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> zip(x,y2):</span><br><span class="line">    plt.text(i<span class="number">-0.2</span>,j+<span class="number">0.05</span>,<span class="string">'%.2f'</span> % -j, color = <span class="string">'white'</span>)</span><br><span class="line"><span class="comment"># 给图添加text</span></span><br><span class="line"><span class="comment"># zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_45_0.png" alt="png"></p><h3 id="面积图"><a href="#面积图" class="headerlink" title="面积图"></a>面积图</h3><ul><li>stacked：是否堆叠，默认情况下，区域图被堆叠</li><li>为了产生堆积面积图，每列必须是正值或全部负值！</li><li>当数据有NaN时候，自动填充0，图标签需要清洗掉缺失值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,figsize = (<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">4</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">df1.plot.area(colormap = <span class="string">'Greens_r'</span>,alpha = <span class="number">0.5</span>,ax = axes[<span class="number">0</span>])</span><br><span class="line">df2.plot.area(stacked=<span class="literal">False</span>,colormap = <span class="string">'Set2'</span>,alpha = <span class="number">0.5</span>,ax = axes[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot at 0x24f3288f668&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_47_1.png" alt="png"></p><h3 id="填图"><a href="#填图" class="headerlink" title="填图"></a>填图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,figsize = (<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">500</span>)</span><br><span class="line">y1 = np.sin(<span class="number">4</span> * np.pi * x) * np.exp(<span class="number">-5</span> * x)</span><br><span class="line">y2 = -np.sin(<span class="number">4</span> * np.pi * x) * np.exp(<span class="number">-5</span> * x)</span><br><span class="line"></span><br><span class="line">axes[<span class="number">0</span>].fill(x, y1, <span class="string">'r'</span>,alpha=<span class="number">0.5</span>,label=<span class="string">'y1'</span>)</span><br><span class="line">axes[<span class="number">0</span>].fill(x, y2, <span class="string">'g'</span>,alpha=<span class="number">0.5</span>,label=<span class="string">'y2'</span>)</span><br><span class="line"><span class="comment"># 对函数与坐标轴之间的区域进行填充，使用fill函数</span></span><br><span class="line"><span class="comment"># 也可写成：plt.fill(x, y1, 'r',x, y2, 'g',alpha=0.5)</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">5</span> * np.pi, <span class="number">1000</span>) </span><br><span class="line">y1 = np.sin(x)  </span><br><span class="line">y2 = np.sin(<span class="number">2</span> * x)  </span><br><span class="line">axes[<span class="number">1</span>].fill_between(x, y1, y2, color =<span class="string">'b'</span>,alpha=<span class="number">0.5</span>,label=<span class="string">'area'</span>)  </span><br><span class="line"><span class="comment"># 填充两个函数之间的区域，使用fill_between函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    axes[i].legend()</span><br><span class="line">    axes[i].grid()</span><br><span class="line"><span class="comment"># 添加图例、格网</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_49_0.png" alt="png"></p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>plt.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, hold=None, data=None)</p><ul><li>参数含义：<ul><li>第一个参数：数据</li><li>explode：指定每部分的偏移量</li><li>labels：标签</li><li>colors：颜色</li><li>autopct：饼图上的数据标签显示方式</li><li>pctdistance：每个饼切片的中心和通过autopct生成的文本开始之间的比例</li><li>labeldistance：被画饼标记的直径,默认值：1.1</li><li>shadow：阴影</li><li>startangle：开始角度</li><li>radius：半径</li><li>frame：图框</li><li>counterclock：指定指针方向，顺时针或者逆时针</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(<span class="number">3</span> * np.random.rand(<span class="number">4</span>), index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], name=<span class="string">'series'</span>)</span><br><span class="line">plt.axis(<span class="string">'equal'</span>)  <span class="comment"># 保证长宽相等</span></span><br><span class="line">plt.pie(s,</span><br><span class="line">       explode = [<span class="number">0.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">       labels = s.index,</span><br><span class="line">       colors=[<span class="string">'r'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">       autopct=<span class="string">'%.2f%%'</span>,</span><br><span class="line">       pctdistance=<span class="number">0.6</span>,</span><br><span class="line">       labeldistance = <span class="number">1.2</span>,</span><br><span class="line">       shadow = <span class="literal">True</span>,</span><br><span class="line">       startangle=<span class="number">0</span>,</span><br><span class="line">       radius=<span class="number">1.5</span>,</span><br><span class="line">       frame=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_51_0.png" alt="png"></p><h3 id="直方图-1"><a href="#直方图-1" class="headerlink" title="直方图"></a>直方图</h3><p>plt.hist(x, bins=10, range=None, normed=False, weights=None, cumulative=False, bottom=None,<br>histtype=’bar’, align=’mid’, orientation=’vertical’,rwidth=None, log=False, color=None, label=None,<br>stacked=False, hold=None, data=None, **kwargs)</p><ul><li>参数<ul><li>bin：箱子的宽度</li><li>normed 标准化</li><li>histtype 风格，bar，barstacked，step，stepfilled</li><li>orientation 水平还是垂直{‘horizontal’, ‘vertical’}</li><li>align : {‘left’, ‘mid’, ‘right’}, optional(对齐方式)</li><li>stacked：是否堆叠</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">s = pd.Series(np.random.randn(<span class="number">1000</span>))</span><br><span class="line">s.hist(bins = <span class="number">20</span>,</span><br><span class="line">       histtype = <span class="string">'bar'</span>,</span><br><span class="line">       align = <span class="string">'mid'</span>,</span><br><span class="line">       orientation = <span class="string">'vertical'</span>,</span><br><span class="line">       alpha=<span class="number">0.5</span>,</span><br><span class="line">       normed =<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 密度图</span></span><br><span class="line">s.plot(kind=<span class="string">'kde'</span>,style=<span class="string">'k--'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files (x86)\Anaconda3\lib\site-packages\pandas\plotting\_core.py:2477: MatplotlibDeprecationWarning: </span><br><span class="line">The &apos;normed&apos; kwarg was deprecated in Matplotlib 2.1 and will be removed in 3.1. Use &apos;density&apos; instead.</span><br><span class="line">  ax.hist(values, bins=bins, **kwds)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_53_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 堆叠直方图</span></span><br><span class="line"></span><br><span class="line">plt.figure(num=<span class="number">1</span>)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'a'</span>: np.random.randn(<span class="number">1000</span>) + <span class="number">1</span>, <span class="string">'b'</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">                    <span class="string">'c'</span>: np.random.randn(<span class="number">1000</span>) - <span class="number">1</span>, <span class="string">'d'</span>: np.random.randn(<span class="number">1000</span>)<span class="number">-2</span>&#125;,</span><br><span class="line">                   columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df.plot.hist(stacked=<span class="literal">True</span>,</span><br><span class="line">             bins=<span class="number">20</span>,</span><br><span class="line">             colormap=<span class="string">'Greens_r'</span>,</span><br><span class="line">             alpha=<span class="number">0.5</span>,</span><br><span class="line">             grid=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 使用DataFrame.plot.hist()和Series.plot.hist()方法绘制</span></span><br><span class="line"></span><br><span class="line">df.hist(bins=<span class="number">50</span>)</span><br><span class="line"><span class="comment"># 生成多个直方图</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F34C1B710&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F34C4D2E8&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F34C80898&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F34CB2E48&gt;]],</span><br><span class="line">      dtype=object)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Figure size 432x288 with 0 Axes&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_54_2.png" alt="png"></p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_54_3.png" alt="png"></p><h3 id="散点图-1"><a href="#散点图-1" class="headerlink" title="散点图"></a>散点图</h3><p>plt.scatter(x, y, s=20, c=None, marker=’o’, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None,<br>verts=None, edgecolors=None, hold=None, data=None, **kwargs)</p><p>参数含义：</p><ul><li>s：散点的大小</li><li>c：散点的颜色</li><li>vmin,vmax：亮度设置，标量</li><li>cmap：colormap</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">x = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">y = np.random.randn(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x,y,marker=<span class="string">'.'</span>,</span><br><span class="line">           s = np.random.randn(<span class="number">1000</span>)*<span class="number">100</span>,</span><br><span class="line">           cmap = <span class="string">'Reds_r'</span>,</span><br><span class="line">           c = y,</span><br><span class="line">           alpha = <span class="number">0.8</span>,)</span><br><span class="line">plt.grid()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files (x86)\Anaconda3\lib\site-packages\matplotlib\collections.py:857: RuntimeWarning: invalid value encountered in sqrt</span><br><span class="line">  scale = np.sqrt(self._sizes) * dpi / 72.0 * self._factor</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_56_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pd.scatter_matrix()散点矩阵</span></span><br><span class="line"><span class="comment"># pd.scatter_matrix(frame, alpha=0.5, figsize=None, ax=None, </span></span><br><span class="line"><span class="comment"># grid=False, diagonal='hist', marker='.', density_kwds=None, hist_kwds=None, range_padding=0.05, **kwds)</span></span><br><span class="line"><span class="comment"># diagonal：(&#123;‘hist’, ‘kde’&#125;)，必须且只能在&#123;‘hist’, ‘kde’&#125;中选择1个 → 每个指标的频率图</span></span><br><span class="line"><span class="comment"># range_padding：(float, 可选)，图像在x轴、y轴原点附近的留白(padding)，该值越大，留白距离越大，图像远离坐标原点</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">100</span>,<span class="number">4</span>),columns = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">pd.plotting.scatter_matrix(df,figsize=(<span class="number">10</span>,<span class="number">6</span>),</span><br><span class="line">                 marker = <span class="string">'o'</span>,</span><br><span class="line">                 diagonal=<span class="string">'kde'</span>,</span><br><span class="line">                 alpha = <span class="number">0.5</span>,</span><br><span class="line">                 range_padding=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F39EB5828&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F222278&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F37E518&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F391F98&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F3AF128&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F3C5278&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F3DC3C8&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F3F3550&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F3F3588&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F41FC18&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F43C208&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F4507B8&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F466D68&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F483358&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F498908&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3F4AFEB8&gt;]],</span><br><span class="line">      dtype=object)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_57_1.png" alt="png"></p><h3 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h3><p>箱型图：又称为盒须图、盒式图、盒状图或箱线图，是一种用作显示一组数据分散情况资料的统计图</p><p>包含一组数据的：最大值、最小值、中位数、上四分位数（Q1）、下四分位数（Q3）、异常值</p><p>① 中位数 → 一组数据平均分成两份，中间的数</p><p>② 下四分位数Q1 → 是将序列平均分成四份，计算(n+1)/4与(n-1)/4两种，一般使用(n+1)/4</p><p>③ 上四分位数Q3 → 是将序列平均分成四份，计算(1+n)/4*3=6.75</p><p>④ 内限 → T形的盒须就是内限，最大值区间Q3+1.5IQR,最小值区间Q1-1.5IQR （IQR=Q3-Q1）</p><p>⑤ 外限 → T形的盒须就是内限，最大值区间Q3+3IQR,最小值区间Q1-3IQR （IQR=Q3-Q1）</p><p>⑥ 异常值 → 内限之外 - 中度异常，外限之外 - 极度异常</p><p>plt.plot.box(),plt.boxplot()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.plot.box()绘制</span></span><br><span class="line"></span><br><span class="line">fig,axes = plt.subplots(<span class="number">2</span>,<span class="number">1</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">5</span>), columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</span><br><span class="line">color = dict(boxes=<span class="string">'DarkGreen'</span>, whiskers=<span class="string">'DarkOrange'</span>, medians=<span class="string">'DarkBlue'</span>, caps=<span class="string">'Gray'</span>)</span><br><span class="line"><span class="comment"># 箱型图着色</span></span><br><span class="line"><span class="comment"># boxes → 箱线</span></span><br><span class="line"><span class="comment"># whiskers → 分位数与error bar横线之间竖线的颜色</span></span><br><span class="line"><span class="comment"># medians → 中位数线颜色</span></span><br><span class="line"><span class="comment"># caps → error bar横线颜色</span></span><br><span class="line"></span><br><span class="line">df.plot.box(ylim=[<span class="number">0</span>,<span class="number">1.2</span>],</span><br><span class="line">           grid = <span class="literal">True</span>,</span><br><span class="line">           color = color,</span><br><span class="line">           ax = axes[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;matplotlib.axes._subplots.AxesSubplot at 0x24f394cc9b0&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_59_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>, <span class="number">5</span>), columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># 创建图表、数据</span></span><br><span class="line"></span><br><span class="line">f = df.boxplot(sym = <span class="string">'o'</span>,  <span class="comment"># 异常点形状，参考marker</span></span><br><span class="line">               vert = <span class="literal">True</span>,  <span class="comment"># 是否垂直</span></span><br><span class="line">               whis = <span class="number">1.5</span>,  <span class="comment"># IQR，默认1.5，也可以设置区间比如[5,95]，代表强制上下边缘为数据95%和5%位置</span></span><br><span class="line">               patch_artist = <span class="literal">True</span>,  <span class="comment"># 上下四分位框内是否填充，True为填充</span></span><br><span class="line">               meanline = <span class="literal">False</span>,showmeans=<span class="literal">True</span>,  <span class="comment"># 是否有均值线及其形状</span></span><br><span class="line">               showbox = <span class="literal">True</span>,  <span class="comment"># 是否显示箱线</span></span><br><span class="line">               showcaps = <span class="literal">True</span>,  <span class="comment"># 是否显示边缘线</span></span><br><span class="line">               showfliers = <span class="literal">True</span>,  <span class="comment"># 是否显示异常值</span></span><br><span class="line">               notch = <span class="literal">False</span>,  <span class="comment"># 中间箱体是否缺口</span></span><br><span class="line">               return_type=<span class="string">'dict'</span>  <span class="comment"># 返回类型为字典</span></span><br><span class="line">              ) </span><br><span class="line">plt.title(<span class="string">'boxplot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> box <span class="keyword">in</span> f[<span class="string">'boxes'</span>]:</span><br><span class="line">    box.set( color=<span class="string">'b'</span>, linewidth=<span class="number">1</span>)        <span class="comment"># 箱体边框颜色</span></span><br><span class="line">    box.set( facecolor = <span class="string">'b'</span> ,alpha=<span class="number">0.5</span>)    <span class="comment"># 箱体内部填充颜色</span></span><br><span class="line"><span class="keyword">for</span> whisker <span class="keyword">in</span> f[<span class="string">'whiskers'</span>]:</span><br><span class="line">    whisker.set(color=<span class="string">'k'</span>, linewidth=<span class="number">0.5</span>,linestyle=<span class="string">'-'</span>)</span><br><span class="line"><span class="keyword">for</span> cap <span class="keyword">in</span> f[<span class="string">'caps'</span>]:</span><br><span class="line">    cap.set(color=<span class="string">'gray'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> median <span class="keyword">in</span> f[<span class="string">'medians'</span>]:</span><br><span class="line">    median.set(color=<span class="string">'DarkBlue'</span>, linewidth=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> flier <span class="keyword">in</span> f[<span class="string">'fliers'</span>]:</span><br><span class="line">    flier.set(marker=<span class="string">'o'</span>, color=<span class="string">'y'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># boxes, 箱线</span></span><br><span class="line"><span class="comment"># medians, 中位值的横线,</span></span><br><span class="line"><span class="comment"># whiskers, 从box到error bar之间的竖线.</span></span><br><span class="line"><span class="comment"># fliers, 异常值</span></span><br><span class="line"><span class="comment"># caps, error bar横线</span></span><br><span class="line"><span class="comment"># means, 均值的横线,</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_60_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.boxplot()绘制</span></span><br><span class="line"><span class="comment"># 分组汇总</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>,<span class="number">2</span>), columns=[<span class="string">'Col1'</span>, <span class="string">'Col2'</span>] )</span><br><span class="line">df[<span class="string">'X'</span>] = pd.Series([<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>])</span><br><span class="line">df[<span class="string">'Y'</span>] = pd.Series([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>])</span><br><span class="line"></span><br><span class="line">df.boxplot(by = <span class="string">'X'</span>)</span><br><span class="line">df.boxplot(column=[<span class="string">'Col1'</span>,<span class="string">'Col2'</span>], by=[<span class="string">'X'</span>,<span class="string">'Y'</span>])</span><br><span class="line"><span class="comment"># columns：按照数据的列分子图</span></span><br><span class="line"><span class="comment"># by：按照列分组做箱型图</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F3519AD68&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000024F34B67C88&gt;],</span><br><span class="line">      dtype=object)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_61_1.png" alt="png"></p><p><img src="https://raw.githubusercontent.com/geroge-gao/Images/master/matplotlib基本用法/output_61_2.png" alt="png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Matplotlib的基本用法&quot;&gt;&lt;a href=&quot;#Matplotlib的基本用法&quot; class=&quot;headerlink&quot; title=&quot;Matplotlib的基本用法&quot;&gt;&lt;/a&gt;Matplotlib的基本用法&lt;/h1&gt;&lt;h2 id=&quot;简单的折线图&quot;&gt;&lt;a href=&quot;#简单的折线图&quot; class=&quot;headerlink&quot; title=&quot;简单的折线图&quot;&gt;&lt;/a&gt;简单的折线图&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;plt.plot(x,y, fortmat_string)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作用是定义画图的样式&lt;/p&gt;&lt;p&gt;x,y表示横纵左表， format可以定义画图格式&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#导入Matploylib库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; matplotlib &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%matplotlib inline     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#画布上画图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.plot([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;,  linewidth=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.plot([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;,   linewidth=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#在画布上显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="matplotlib" scheme="http://yoursite.com/tags/matplotlib/"/>
    
      <category term="可视化" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
</feed>
